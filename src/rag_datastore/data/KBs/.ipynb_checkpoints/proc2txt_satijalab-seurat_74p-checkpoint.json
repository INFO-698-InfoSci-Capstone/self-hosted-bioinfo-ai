[
  {
    "processed_text": "Articles All vignettes Map COVID PBMC datasets to a healthy reference Sketch integration using a 1 million cell dataset from Parse Biosciences Documentation Archive Integrating scRNA-seq and scATAC-seq data Cell-Cycle Scoring and Regression Interoperability between single-cell object formats Differential expression testing Seurat - Dimensional Reduction Vignette Seurat Command List Seurat Extension Packages Parallelization in Seurat with future Getting Started with Seurat Introduction to Seurat v5 Demultiplexing with hashtag oligos (HTOs) Installation Instructions for Seurat Installation Instructions for Seurat Introduction to scRNA-seq integration Tips for integrating large datasets Mapping and annotating query datasets Fast integration using reciprocal PCA (RPCA) Seurat - Interaction Tips Seurat - Combining Two 10X Runs Mixscape Vignette Multimodal reference mapping Using Seurat with multimodal data Seurat - Guided Clustering Tutorial Introduction to SCTransform, v2 regularization Using sctransform in Seurat Documentation Archive Integrating scRNA-seq and scATAC-seq data Using BPCells with Seurat Objects Cell-Cycle Scoring and Regression Interoperability between single-cell object formats Differential expression testing Seurat - Dimensional Reduction Vignette Seurat v5 Command Cheat Sheet Seurat Extension Packages Parallelization in Seurat with future Getting Started with Seurat Demultiplexing with hashtag oligos (HTOs) Integrative analysis in Seurat v5 Dictionary Learning for cross-modality integration Introduction to scRNA-seq integration Tips for integrating large datasets Mapping and annotating query datasets Fast integration using reciprocal PCA (RPCA) Seurat - Interaction Tips Seurat - Combining Two 10X Runs Mixscape Vignette Multimodal reference mapping Using Seurat with multimodal data Seurat - Guided Clustering Tutorial Introduction to SCTransform, v2 regularization Using sctransform in Seurat Sketch-based analysis in Seurat v5 Analysis, visualization, and integration of spatial datasets with Seurat Analysis of Image-based Spatial Data in Seurat Changes in Seurat v4 Data visualization methods in Seurat Weighted Nearest Neighbor Analysis Analysis, visualization, and integration of spatial datasets with Seurat Analysis of Image-based Spatial Data in Seurat Changes in Seurat v4 Data visualization methods in Seurat Weighted Nearest Neighbor Analysis",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/",
      "title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat • Seurat",
      "ogTitle": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "language": "en",
      "og:title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "scrapeId": "53deb2b6-7d28-410c-a8f2-f304b1a1cdc7",
      "viewport": "width=device-width, initial-scale=1.0",
      "sourceURL": "https://satijalab.org/seurat/articles/",
      "statusCode": 200,
      "ogDescription": "Seurat",
      "og:description": "Seurat"
    }
  },
  {
    "processed_text": "Installation Instructions for Seurat Source: vignettes/install_v5.Rmd install_v5.Rmd To install Seurat, R version 4.0 or greater is required. We also recommend installing R Studio . Seurat 5: Install from CRAN anchor Seurat is available on CRAN for all platforms. To install, run: ```sourceCode R Enter commands in R (or R studio, if installed) install.packages('Seurat') library(Seurat) ``` Seurat does not require, but makes use of, packages developed by other labs that can substantially enhance speed and performance. These include presto (Korunsky/Raychaudhari labs), BPCells (Greenleaf Lab), and glmGamPoi (Huber Lab). We recommend users install these along with Seurat: sourceCode R setRepositories(ind = 1:3, addURLs = c('https://satijalab.r-universe.dev', 'https://bnprks.r-universe.dev/')) install.packages(c(\"BPCells\", \"presto\", \"glmGamPoi\")) We also recommend installing these additional packages, which are used in our vignettes, and enhance the functionality of Seurat: Signac : analysis of single-cell chromatin data SeuratData : automatically load datasets pre-packaged as Seurat objects Azimuth : local annotation of scRNA-seq and scATAC-seq queries across multiple organs and tissues SeuratWrappers : enables use of additional integration and differential expression methods ```sourceCode R Install the remotes package if (!requireNamespace(\"remotes\", quietly = TRUE)) { install.packages(\"remotes\") } install.packages('Signac') remotes::install_github(\"satijalab/seurat-data\", quiet = TRUE) remotes::install_github(\"satijalab/azimuth\", quiet = TRUE) remotes::install_github(\"satijalab/seurat-wrappers\", quiet = TRUE) ``` Install previous versions of Seurat anchor Install Seurat v4 anchor Seurat v4.4.0 can be installed with the following commands: sourceCode R remotes::install_version(\"SeuratObject\", \"4.1.4\", repos = c(\"https://satijalab.r-universe.dev\", getOption(\"repos\"))) remotes::install_version(\"Seurat\", \"4.4.0\", repos = c(\"https://satijalab.r-universe.dev\", getOption(\"repos\"))) Older versions of Seurat anchor Old versions of Seurat, from Seurat v2.0.1 and up, are hosted in CRAN’s archive. To install an old version of Seurat, run: ```sourceCode R Install the remotes package install.packages('remotes') Replace 'X.X.X' with your desired version remotes::install_version(package = 'Seurat', version = package_version('X.X.X')) ``` For versions of Seurat older than those not hosted on CRAN (versions 1.3.0 and 1.4.0), please download the packaged source code from our releases page and install from the tarball . Install the development version of Seurat anchor Install the development version of Seurat - directly from GitHub . ```sourceCode R Enter commands in R (or R studio, if installed) Install the remotes package install.packages('remotes') remotes::install_github(repo = 'satijalab/seurat', ref = 'develop') library(Seurat) ``` Docker anchor We provide docker images for Seurat via dockerhub . To pull the latest image from the command line: sourceCode bash docker pull satijalab/seurat:latest To use as a base image in a new Dockerfile: sourceCode bash FROM satijalab/seurat:latest",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/install_v5",
      "title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat • Seurat",
      "ogTitle": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "language": "en",
      "og:title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "scrapeId": "dd2835a2-86f0-4cb5-a598-01e327656fcf",
      "viewport": "width=device-width, initial-scale=1.0",
      "sourceURL": "https://satijalab.org/seurat/articles/install_v5",
      "statusCode": 200,
      "ogDescription": "Seurat",
      "og:description": "Seurat"
    }
  },
  {
    "processed_text": "Seurat Extension Packages Source: vignettes/seurat5_extensions.Rmd seurat5_extensions.Rmd In addition to the core Seurat package, we provide several extensions that enhance the functionality and utility of Seurat. A brief description of each is listed below with links to more complete documentation and examples. Signac anchor Signac is an R toolkit that extends Seurat for the analysis, interpretation, and exploration of single-cell chromatin datasets. The software supports the following features: Calculating single-cell QC metrics Dimensional reduction, visualization, and clustering Identifying cell type-specific peaks Visualizing ‘pseudo-bulk’ coverage tracks Integration with single-cell RNA-seq datasets For documentation and vignettes, click here . SeuratData anchor SeuratData is a mechanism for distributing datasets in the form of Seurat objects using R’s internal package and data management systems. It represents an easy way for users to get access to datasets that are used in the Seurat vignettes. For more information, click here . SeuratWrappers anchor In order to facilitate the use of community tools with Seurat, we provide the SeuratWrappers package, which contains code to run other analysis tools on Seurat objects. For a full list of supported packages and vignettes, please see our vignettes page. SeuratDisk anchor The SeuratDisk package introduces the h5Seurat file format for the storage and analysis of multimodal single-cell and spatially-resolved expression experiments. The SeuratDisk package provides functions to save Seurat objects as h5Seurat files, and functions for rapid on-disk conversion between h5Seurat and AnnData formats with the goal of enhancing interoperability between Seurat and Scanpy. For more information, click here Azimuth anchor Azimuth is a web application that uses an annotated reference dataset to automate the processing, analysis, and interpretation of a new single-cell RNA-seq experiment. Azimuth leverages a ‘reference-based mapping’ pipeline that inputs a counts matrix of gene expression in single cells, and performs normalization, visualization, cell annotation, and differential expression (biomarker discovery). All results can be explored within the app, and easily downloaded for additional downstream analysis. To use the Azimuth web app, visit the Azimuth website here .",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/seurat5_extensions",
      "title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat • Seurat",
      "ogTitle": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "language": "en",
      "og:title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "scrapeId": "05a521cb-7070-4fef-82bf-1252443ac627",
      "viewport": "width=device-width, initial-scale=1.0",
      "sourceURL": "https://satijalab.org/seurat/articles/seurat5_extensions",
      "statusCode": 200,
      "ogDescription": "Seurat",
      "og:description": "Seurat"
    }
  },
  {
    "processed_text": "Using Seurat with multimodal data Compiled: 2023-11-16 Source: vignettes/multimodal_vignette.Rmd multimodal_vignette.Rmd Load in the data anchor The ability to make simultaneous measurements of multiple data types from the same cell, known as multimodal analysis, represents a new and exciting frontier for single-cell genomics. For example, CITE-seq enables the simultaneous measurements of transcriptomes and cell-surface proteins from the same cell. Other exciting multimodal technologies, such as the 10x multiome kit allow for the paired measurements of cellular transcriptome and chromatin accessibility (i.e scRNA-seq+scATAC-seq). Other modalities that can be measured alongside cellular transcriptomes include genetic perturbations, cellular methylomes, and hashtag oligos from Cell Hashing . We have designed Seurat to enable for the seamless storage, analysis, and exploration of diverse multimodal single-cell datasets. In this vignette, we present an introductory workflow for creating a multimodal Seurat object and performing an initial analysis. For example, we demonstrate how to cluster a CITE-seq dataset on the basis of the measured cellular transcriptomes, and subsequently discover cell surface proteins that are enriched in each cluster. We note that Seurat also enables more advanced techniques for the analysis of multimodal data, in particular the application of our Weighted Nearest Neighbors (WNN) approach that enables simultaneous clustering of cells based on a weighted combination of both modalities, and you can explore this functionality here . Here, we analyze a dataset of 8,617 cord blood mononuclear cells (CBMCs), where transcriptomic measurements are paired with abundance estimates for 11 surface proteins, whose levels are quantified with DNA-barcoded antibodies. First, we load in two count matrices : one for the RNA measurements, and one for the antibody-derived tags (ADT). You can download the ADT file here and the RNA file here sourceCode R library(Seurat) library(ggplot2) library(patchwork) ```sourceCode R Load in the RNA UMI matrix Note that this dataset also contains ~5% of mouse cells, which we can use as negative controls for the protein measurements. For this reason, the gene expression matrix has HUMAN_ or MOUSE_ appended to the beginning of each gene. cbmc.rna <- as.sparse(read.csv(file = \"/brahms/shared/vignette-data/GSE100866_CBMC_8K_13AB_10X-RNA_umi.csv.gz\", sep = \",\", header = TRUE, row.names = 1)) To make life a bit easier going forward, we're going to discard all but the top 100 most highly expressed mouse genes, and remove the 'HUMAN_' from the CITE-seq prefix cbmc.rna <- CollapseSpeciesExpressionMatrix(cbmc.rna) Load in the ADT UMI matrix cbmc.adt <- as.sparse(read.csv(file = \"/brahms/shared/vignette-data/GSE100866_CBMC_8K_13AB_10X-ADT_umi.csv.gz\", sep = \",\", header = TRUE, row.names = 1)) Note that since measurements were made in the same cells, the two matrices have identical column names all.equal(colnames(cbmc.rna), colnames(cbmc.adt)) ``` ``` [1] TRUE ``` Setup a Seurat object, add the RNA and protein data anchor Now we create a Seurat object, and add the ADT data as a second assay ```sourceCode R creates a Seurat object based on the scRNA-seq data cbmc <- CreateSeuratObject(counts = cbmc.rna) We can see that by default, the cbmc object contains an assay storing RNA measurement Assays(cbmc) ``` ``` [1] \"RNA\" ``` ```sourceCode R create a new assay to store ADT information adt_assay <- CreateAssay5Object(counts = cbmc.adt) add this assay to the previously created Seurat object cbmc[[\"ADT\"]] <- adt_assay Validate that the object now contains multiple assays Assays(cbmc) ``` ``` [1] \"RNA\" \"ADT\" ``` ```sourceCode R Extract a list of features measured in the ADT assay rownames(cbmc[[\"ADT\"]]) ``` ``` [1] \"CD3\" \"CD4\" \"CD8\" \"CD45RA\" \"CD56\" \"CD16\" \"CD10\" \"CD11c\" [9] \"CD14\" \"CD19\" \"CD34\" \"CCR5\" \"CCR7\" ``` ```sourceCode R Note that we can easily switch back and forth between the two assays to specify the default for visualization and analysis List the current default assay DefaultAssay(cbmc) ``` ``` [1] \"RNA\" ``` ```sourceCode R Switch the default to ADT DefaultAssay(cbmc) <- \"ADT\" DefaultAssay(cbmc) ``` ``` [1] \"ADT\" ``` Cluster cells on the basis of their scRNA-seq profiles anchor The steps below represent a quick clustering of the PBMCs based on the scRNA-seq data. For more detail on individual steps or more advanced options, see our PBMC clustering guided tutorial here ```sourceCode R Note that all operations below are performed on the RNA assay Set and verify that the default assay is RNA DefaultAssay(cbmc) <- \"RNA\" DefaultAssay(cbmc) ``` ``` [1] \"RNA\" ``` ```sourceCode R perform visualization and clustering steps cbmc <- NormalizeData(cbmc) cbmc <- FindVariableFeatures(cbmc) cbmc <- ScaleData(cbmc) cbmc <- RunPCA(cbmc, verbose = FALSE) cbmc <- FindNeighbors(cbmc, dims = 1:30) cbmc <- FindClusters(cbmc, resolution = 0.8, verbose = FALSE) cbmc <- RunUMAP(cbmc, dims = 1:30) DimPlot(cbmc, label = TRUE) ``` Visualize multiple modalities side-by-side anchor Now that we have obtained clusters from scRNA-seq profiles, we can visualize the expression of either protein or RNA molecules in our dataset. Importantly, Seurat provides a couple ways to switch between modalities, and specify which modality you are interested in analyzing or visualizing. This is particularly important as, in some cases, the same feature can be present in multiple modalities - for example this dataset contains independent measurements of the B cell marker CD19 (both protein and RNA levels). ```sourceCode R Normalize ADT data, DefaultAssay(cbmc) <- \"ADT\" cbmc <- NormalizeData(cbmc, normalization.method = \"CLR\", margin = 2) DefaultAssay(cbmc) <- \"RNA\" Note that the following command is an alternative but returns the same result cbmc <- NormalizeData(cbmc, normalization.method = \"CLR\", margin = 2, assay = \"ADT\") Now, we will visualize CD14 levels for RNA and protein By setting the default assay, we can visualize one or the other DefaultAssay(cbmc) <- \"ADT\" p1 <- FeaturePlot(cbmc, \"CD19\", cols = c(\"lightgrey\", \"darkgreen\")) + ggtitle(\"CD19 protein\") DefaultAssay(cbmc) <- \"RNA\" p2 <- FeaturePlot(cbmc, \"CD19\") + ggtitle(\"CD19 RNA\") place plots side-by-side p1 | p2 ``` ```sourceCode R Alternately, we can use specific assay keys to specify a specific modality Identify the key for the RNA and protein assays Key(cbmc[[\"RNA\"]]) ``` ``` [1] \"rna_\" ``` sourceCode R Key(cbmc[[\"ADT\"]]) ``` [1] \"adt_\" ``` ```sourceCode R Now, we can include the key in the feature name, which overrides the default assay p1 <- FeaturePlot(cbmc, \"adt_CD19\", cols = c(\"lightgrey\", \"darkgreen\")) + ggtitle(\"CD19 protein\") p2 <- FeaturePlot(cbmc, \"rna_CD19\") + ggtitle(\"CD19 RNA\") p1 | p2 ``` Identify cell surface markers for scRNA-seq clusters anchor We can leverage our paired CITE-seq measurements to help annotate clusters derived from scRNA-seq, and to identify both protein and RNA markers. ```sourceCode R as we know that CD19 is a B cell marker, we can identify cluster 6 as expressing CD19 on the surface VlnPlot(cbmc, \"adt_CD19\") ``` ```sourceCode R we can also identify alternative protein and RNA markers for this cluster through differential expression adt_markers <- FindMarkers(cbmc, ident.1 = 6, assay = \"ADT\") rna_markers <- FindMarkers(cbmc, ident.1 = 6, assay = \"RNA\") head(adt_markers) ``` ``` p_val avg_log2FC pct.1 pct.2 p_val_adj CD19 2.067533e-215 2.5741873 1 1 2.687793e-214 CD45RA 8.108073e-109 0.5300346 1 1 1.054049e-107 CD4 1.123162e-107 -1.6707420 1 1 1.460110e-106 CD14 7.212876e-106 -1.0332070 1 1 9.376739e-105 CD3 1.639633e-87 -1.5823056 1 1 2.131523e-86 CCR5 2.552859e-63 0.3753989 1 1 3.318716e-62 ``` sourceCode R head(rna_markers) ``` p_val avg_log2FC pct.1 pct.2 p_val_adj IGHM 0 6.660187 0.977 0.044 0 CD79A 0 6.748356 0.965 0.045 0 TCL1A 0 7.428099 0.904 0.028 0 CD79B 0 5.525568 0.944 0.089 0 IGHD 0 7.811884 0.857 0.015 0 MS4A1 0 7.523215 0.851 0.016 0 ``` Additional visualizations of multimodal data anchor ```sourceCode R Draw ADT scatter plots (like biaxial plots for FACS). Note that you can even 'gate' cells if desired by using HoverLocator and FeatureLocator FeatureScatter(cbmc, feature1 = \"adt_CD19\", feature2 = \"adt_CD3\") ``` ```sourceCode R view relationship between protein and RNA FeatureScatter(cbmc, feature1 = \"adt_CD3\", feature2 = \"rna_CD3E\") ``` sourceCode R FeatureScatter(cbmc, feature1 = \"adt_CD4\", feature2 = \"adt_CD8\") ```sourceCode R Let's look at the raw (non-normalized) ADT counts. You can see the values are quite high, particularly in comparison to RNA values. This is due to the significantly higher protein copy number in cells, which significantly reduces 'drop-out' in ADT data FeatureScatter(cbmc, feature1 = \"adt_CD4\", feature2 = \"adt_CD8\", slot = \"counts\") ``` Loading data from 10X multi-modal experiments anchor Seurat is also able to analyze data from multimodal 10X experiments processed using CellRanger v3; as an example, we recreate the plots above using a dataset of 7,900 peripheral blood mononuclear cells (PBMC), freely available from 10X Genomics here . ```sourceCode R pbmc10k.data <- Read10X(data.dir = \"/brahms/shared/vignette-data/pbmc10k/filtered_feature_bc_matrix/\") rownames(x = pbmc10k.data[[\"Antibody Capture\"]]) <- gsub(pattern = \" [control ]*TotalSeqB\", replacement = \"\", x = rownames(x = pbmc10k.data[[\"Antibody Capture\"]])) pbmc10k <- CreateSeuratObject(counts = pbmc10k.data[[\"Gene Expression\"]], min.cells = 3, min.features = 200) pbmc10k <- NormalizeData(pbmc10k) pbmc10k[[\"ADT\"]] <- CreateAssayObject(pbmc10k.data[[\"Antibody Capture\"]][, colnames(x = pbmc10k)]) pbmc10k <- NormalizeData(pbmc10k, assay = \"ADT\", normalization.method = \"CLR\") plot1 <- FeatureScatter(pbmc10k, feature1 = \"adt_CD19\", feature2 = \"adt_CD3\", pt.size = 1) plot2 <- FeatureScatter(pbmc10k, feature1 = \"adt_CD4\", feature2 = \"adt_CD8a\", pt.size = 1) plot3 <- FeatureScatter(pbmc10k, feature1 = \"adt_CD3\", feature2 = \"CD3E\", pt.size = 1) (plot1 + plot2 + plot3) & NoLegend() ``` sourceCode R plot <- FeatureScatter(cbmc, feature1 = \"adt_CD19\", feature2 = \"adt_CD3\") + NoLegend() + theme(axis.title = element_text(size = 18), legend.text = element_text(size = 18)) ggsave(filename = \"../output/images/citeseq_plot.jpg\", height = 7, width = 12, plot = plot, quality = 50) Additional functionality for multimodal data in Seurat anchor Seurat v4 also includes additional functionality for the analysis, visualization, and integration of multimodal datasets. For more information, please explore the resources below: Defining cellular identity from multimodal data using WNN analysis in Seurat v4 vignette Mapping scRNA-seq data onto CITE-seq references vignette Introduction to the analysis of spatial transcriptomics analysis vignette Analysis of 10x multiome (paired scRNA-seq + ATAC) using WNN analysis vignette Signac: Analysis, interpretation, and exploration of single-cell chromatin datasets package Mixscape: an analytical toolkit for pooled single-cell genetic screens vignette Bridge integration: mapping multi-omic datasets across molecular modalities vignette Session Info sourceCode R sessionInfo() ``` R version 4.2.2 Patched (2022-11-10 r83330) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.6 LTS Matrix products: default BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats graphics grDevices utils datasets methods base other attached packages: [1] patchwork_1.1.3 ggplot2_3.4.4 Seurat_5.0.1 testthat_3.2.0 [5] SeuratObject_5.0.1 sp_2.1-1 loaded via a namespace (and not attached): [1] spam_2.10-0 systemfonts_1.0.4 plyr_1.8.9 [4] igraph_1.5.1 lazyeval_0.2.2 splines_4.2.2 [7] RcppHNSW_0.5.0 listenv_0.9.0 scattermore_1.2 [10] usethis_2.1.6 digest_0.6.33 htmltools_0.5.6.1 [13] fansi_1.0.5 magrittr_2.0.3 memoise_2.0.1 [16] tensor_1.5 cluster_2.1.4 ROCR_1.0-11 [19] limma_3.54.1 remotes_2.4.2.1 globals_0.16.2 [22] matrixStats_1.0.0 R.utils_2.12.2 pkgdown_2.0.7 [25] spatstat.sparse_3.0-3 prettyunits_1.2.0 colorspace_2.1-0 [28] ggrepel_0.9.4 textshaping_0.3.6 xfun_0.40 [31] dplyr_1.1.3 callr_3.7.3 crayon_1.5.2 [34] jsonlite_1.8.7 progressr_0.14.0 spatstat.data_3.0-3 [37] survival_3.5-7 zoo_1.8-12 glue_1.6.2 [40] polyclip_1.10-6 gtable_0.3.4 leiden_0.4.3 [43] pkgbuild_1.4.2 future.apply_1.11.0 abind_1.4-5 [46] scales_1.2.1 spatstat.random_3.2-1 miniUI_0.1.1.1 [49] Rcpp_1.0.11 viridisLite_0.4.2 xtable_1.8-4 [52] reticulate_1.34.0 dotCall64_1.1-0 profvis_0.3.7 [55] htmlwidgets_1.6.2 httr_1.4.7 RColorBrewer_1.1-3 [58] ellipsis_0.3.2 ica_1.0-3 R.methodsS3_1.8.2 [61] farver_2.1.1 urlchecker_1.0.1 pkgconfig_2.0.3 [64] uwot_0.1.16 sass_0.4.7 deldir_1.0-9 [67] utf8_1.2.4 labeling_0.4.3 tidyselect_1.2.0 [70] rlang_1.1.1 reshape2_1.4.4 later_1.3.1 [73] munsell_0.5.0 tools_4.2.2 cachem_1.0.8 [76] cli_3.6.1 generics_0.1.3 devtools_2.4.5 [79] ggridges_0.5.4 evaluate_0.22 stringr_1.5.0 [82] fastmap_1.1.1 goftest_1.2-3 yaml_2.3.7 [85] ragg_1.2.5 processx_3.8.2 knitr_1.45 [88] fs_1.6.3 fitdistrplus_1.1-11 purrr_1.0.2 [91] RANN_2.6.1 nlme_3.1-162 pbapply_1.7-2 [94] future_1.33.0 mime_0.12 formatR_1.14 [97] R.oo_1.25.0 ggrastr_1.0.1 brio_1.1.3 [100] compiler_4.2.2 rstudioapi_0.14 beeswarm_0.4.0 [103] plotly_4.10.3 png_0.1-8 spatstat.utils_3.0-4 [106] tibble_3.2.1 bslib_0.5.1 stringi_1.7.12 [109] highr_0.10 ps_1.7.5 desc_1.4.2 [112] RSpectra_0.16-1 lattice_0.21-9 Matrix_1.6-1.1 [115] vctrs_0.6.4 pillar_1.9.0 lifecycle_1.0.4 [118] spatstat.geom_3.2-7 lmtest_0.9-40 jquerylib_0.1.4 [121] RcppAnnoy_0.0.21 data.table_1.14.8 cowplot_1.1.1 [124] irlba_2.3.5.1 httpuv_1.6.12 R6_2.5.1 [127] promises_1.2.1 KernSmooth_2.23-22 gridExtra_2.3 [130] vipor_0.4.5 parallelly_1.36.0 sessioninfo_1.2.2 [133] codetools_0.2-19 fastDummies_1.7.3 MASS_7.3-58.2 [136] pkgload_1.3.3 rprojroot_2.0.4 withr_2.5.2 [139] presto_1.0.0 sctransform_0.4.1 parallel_4.2.2 [142] grid_4.2.2 tidyr_1.3.0 rmarkdown_2.25 [145] Rtsne_0.16 spatstat.explore_3.2-5 shiny_1.7.5.1 [148] ggbeeswarm_0.7.1 ```",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/multimodal_vignette",
      "title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat • Seurat",
      "ogTitle": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "language": "en",
      "og:title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "scrapeId": "0651e985-9800-4110-9049-9bff9f17f3d2",
      "viewport": "width=device-width, initial-scale=1.0",
      "sourceURL": "https://satijalab.org/seurat/articles/multimodal_vignette",
      "statusCode": 200,
      "ogDescription": "Seurat",
      "og:description": "Seurat"
    }
  },
  {
    "processed_text": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat Compiled: 2024-05-06 Source: vignettes/visiumhd_analysis_vignette.Rmd visiumhd_analysis_vignette.Rmd Visium HD support in Seurat anchor We have previously released support Seurat for sequencing-based spatial transcriptomic (ST) technologies, including 10x visium and SLIDE-seq. We have now updated Seurat to be compatible with the Visium HD technology, which performs profiling at substantially higher spatial resolution than previous versions. Users can install the Visium HD-compatible release from Github. Existing Seurat workflows for clustering, visualization, and downstream analysis have been updated to support both Visium and Visium HD data. We note that Visium HD data is generated from spatially patterned olignocleotides labeled in 2um x 2um bins. However, since the data from this resolution is sparse, adjacent bins are pooled together to create 8um and 16um resolutions. 10x recommends the use of 8um binned data for analysis, but Seurat supports in the simultaneous loading of multiple binnings - and stores them in a single object as multiple assays. In this vignette, we provide an overview of some of the spatial workflows that Seurat supports for analyzing Visium HD data, in particular: Unsupervised clustering Identification of spatial tissue domains Subsetting spatial regions Integration with scRNA-seq data Comparing the spatial localization of different cell types Please note that Visium HD is a new data type, and we expect to update this vignette as we test additional methods for spatial data analysis. We strongly encourage users to explore how different parameter settings affect their results, to analyze data iteratively (and in collaboration with biological experts), and to orthogonally validate unexpected or surprising biological findings. We focus our analysis on a Visium HD dataset from the mouse brain, available to download here but also run clustering workflow on a dataset from the mouse intestine. Install Seurat Update anchor ```sourceCode R packages required for Visium HD install.packages(\"hdf5r\") install.packages(\"arrow\") ``` sourceCode R library(Seurat) library(ggplot2) library(patchwork) library(dplyr) Load Visium HD data anchor Visium HD mouse brain dataset is available for download here The Seurat can store multiple binnings/resolutions in different assays bin.size parameter specifies resolutions to load (8 and 16um are loaded by default) Users can switch between resolutions by changing the assay ```sourceCode R localdir <- \"/brahms/lis/visium_hd/mouse/new_mousebrain/\" object <- Load10X_Spatial(data.dir = localdir, bin.size = c(8, 16)) Setting default assay changes between 8um and 16um binning Assays(object) DefaultAssay(object) <- \"Spatial.008um\" ``` ```sourceCode R vln.plot <- VlnPlot(object, features = \"nCount_Spatial.008um\", pt.size = 0) + theme(axis.text = element_text(size = 4)) + NoLegend() count.plot <- SpatialFeaturePlot(object, features = \"nCount_Spatial.008um\") + theme(legend.position = \"right\") note that many spots have very few counts, in-part due to low cellular density in certain tissue regions vln.plot | count.plot ``` Normalize datasets anchor In this vignette we use standard log-normalization for spatial data. We note that the best normalization methods for spatial data are still being developed and evaluated, and encourage users to read manuscripts from the Phipson/Davis and Fan labs to learn more about potential caveats for spatial normalization. ```sourceCode R normalize both 8um and 16um bins DefaultAssay(object) <- \"Spatial.008um\" object <- NormalizeData(object) DefaultAssay(object) <- \"Spatial.016um\" object <- NormalizeData(object) ``` Visualize gene expression anchor Adjusting pt.size.factor (set to 1.2 by default) helps to visualize molecular and histological info in this HD dataset You can also adjust the shape , and stroke (outline) parameters for visualization ```sourceCode R switch spatial resolution to 16um from 8um DefaultAssay(object) <- \"Spatial.016um\" p1 <- SpatialFeaturePlot(object, features = \"Rorb\") + ggtitle(\"Rorb expression (16um)\") switch back to 8um DefaultAssay(object) <- \"Spatial.008um\" p2 <- SpatialFeaturePlot(object, features = \"Hpca\") + ggtitle(\"Hpca expression (8um)\") p1 | p2 ``` Unsupervised clustering anchor While the standard scRNA-seq clustering workflow can also be applied to spatial datasets - we have observed that when working with Visium HD datasets, the Seurat v5 sketch clustering workflow exhibits improved performance, especially for identifying rare and spatially restricted groups. As described in Hao et al, Nature Biotechnology 2023 and Hie et al , sketch-based analyses aim to ‘subsample’ large datasets in a way that preserves rare populations. Here, we sketch the Visium HD dataset, perform clustering on the subsampled cells, and then project the cluster labels back to the full dataset. Details of the sketching procedure and workflow are described in Hao et al, Nature Biotechnology 2023 and the Seurat v5 sketch clustering vignette . Since the full Visium HD dataset fits in memory, we do not use any of the on-disk capabilities of Seurat v5 in this vignette. ```sourceCode R note that data is already normalized DefaultAssay(object) <- \"Spatial.008um\" object <- FindVariableFeatures(object) object <- ScaleData(object) we select 50,0000 cells and create a new 'sketch' assay object <- SketchData( object = object, ncells = 50000, method = \"LeverageScore\", sketched.assay = \"sketch\" ) ``` ```sourceCode R switch analysis to sketched cells DefaultAssay(object) <- \"sketch\" perform clustering workflow object <- FindVariableFeatures(object) object <- ScaleData(object) object <- RunPCA(object, assay = \"sketch\", reduction.name = \"pca.sketch\") object <- FindNeighbors(object, assay = \"sketch\", reduction = \"pca.sketch\", dims = 1:50) object <- FindClusters(object, cluster.name = \"seurat_cluster.sketched\", resolution = 3) object <- RunUMAP(object, reduction = \"pca.sketch\", reduction.name = \"umap.sketch\", return.model = T, dims = 1:50) ``` Now we can project the cluster labels, and dimensional reductions (PCA and UMAP) that we learned from the 50,000 sketched cells - to the entire dataset, using the ProjectData function. In the resulting object, for all cells: cluster labels will be stored in object$seurat_cluster.projected Projected PCA embeddings will be stored in object[[\"pca.008um\"]] Projected UMAP embeddings will be stored in object[[\"umap.sketch\"]] sourceCode R object <- ProjectData( object = object, assay = \"Spatial.008um\", full.reduction = \"full.pca.sketch\", sketched.assay = \"sketch\", sketched.reduction = \"pca.sketch\", umap.model = \"umap.sketch\", dims = 1:50, refdata = list(seurat_cluster.projected = \"seurat_cluster.sketched\") ) We can visualize the clustering results for the sketched cells, as well as the projected clustering results for the full dataset: ```sourceCode R DefaultAssay(object) <- \"sketch\" Idents(object) <- \"seurat_cluster.sketched\" p1 <- DimPlot(object, reduction = \"umap.sketch\", label = F) + ggtitle(\"Sketched clustering (50,000 cells)\") + theme(legend.position = \"bottom\") switch to full dataset DefaultAssay(object) <- \"Spatial.008um\" Idents(object) <- \"seurat_cluster.projected\" p2 <- DimPlot(object, reduction = \"full.umap.sketch\", label = F) + ggtitle(\"Projected clustering (full dataset)\") + theme(legend.position = \"bottom\") p1 | p2 ``` Of course, we can now also visualize the unsupervised clusters based on their spatial location. Note that running SpatialDimPlot(object, interactive = TRUE) , also enables interactive visualization and exploration. sourceCode R SpatialDimPlot(object, label = T, repel = T, label.size = 4) When there are many different clusters (some of which are spatially restricted and others are mixed), plotting the spatial location of all clusters can be challenging to interpret. We find it helpful to plot the spatial location of different clusters individually. For example, we highlight the spatial localization of a few clusters below, which happen to correspond to different cortical layers: sourceCode R Idents(object) <- \"seurat_cluster.projected\" cells <- CellsByIdentities(object, idents = c(0, 4, 32, 34, 35)) p <- SpatialDimPlot(object, cells.highlight = cells[setdiff(names(cells), \"NA\")], cols.highlight = c(\"#FFFF00\", \"grey50\"), facet.highlight = T, combine = T ) + NoLegend() p We can also find and visualize the top gene expression markers for each cluster: ```sourceCode R Crete downsampled object to make visualization either DefaultAssay(object) <- \"Spatial.008um\" Idents(object) <- \"seurat_cluster.projected\" object_subset <- subset(object, cells = Cells(object[[\"Spatial.008um\"]]), downsample = 1000) Order clusters by similarity DefaultAssay(object_subset) <- \"Spatial.008um\" Idents(object_subset) <- \"seurat_cluster.projected\" object_subset <- BuildClusterTree(object_subset, assay = \"Spatial.008um\", reduction = \"full.pca.sketch\", reorder = T) markers <- FindAllMarkers(object_subset, assay = \"Spatial.008um\", only.pos = TRUE) markers %>% group_by(cluster) %>% dplyr::filter(avg_log2FC > 1) %>% slice_head(n = 5) %>% ungroup() -> top5 object_subset <- ScaleData(object_subset, assay = \"Spatial.008um\", features = top5$gene) p <- DoHeatmap(object_subset, assay = \"Spatial.008um\", features = top5$gene, size = 2.5) + theme(axis.text = element_text(size = 5.5)) + NoLegend() p ``` Identifying spatially-defined tissue domains anchor While the previous analyses consider each bin independently, spatial data enables cells to be defined not just by their neighborhood, but also by their broader spatial context. In Singhal et al. , the authors introduce BANKSY, Building Aggregates with a Neighborhood Kernel and Spatial Yardstick (BANKSY). BANKSY performs multiple tasks, but we find it particularly valuable for identifying and segmenting tissue domains. When performing clustering, BANKSY augments a spot’s expression pattern with both the mean and the gradient of gene expression levels in a spot’s broader neighborhood. We thank the authors for enabling BANKSY to be compatible with Seurat via the SeuratWrappers framework, which requires separate installation of the BANKSY package: sourceCode R if (!requireNamespace(\"Banksy\", quietly = TRUE)) { remotes::install_github(\"prabhakarlab/Banksy@devel\") } library(SeuratWrappers) library(Banksy) Before running BANKSY, there are two important model parameters that users should consider: k_geom : Local neighborhood size. Larger values will yield larger domains lambda : Influence of the neighborhood. Larger values yield more spatially coherent domains The RunBanksy function creates a new BANKSY assay, which can be used for dimensional reduction and clustering: sourceCode R object <- RunBanksy(object, lambda = 0.8, verbose = TRUE, assay = \"Spatial.008um\", slot = \"data\", features = \"variable\", k_geom = 50 ) sourceCode R DefaultAssay(object) <- \"BANKSY\" object <- RunPCA(object, assay = \"BANKSY\", reduction.name = \"pca.banksy\", features = rownames(object), npcs = 30) object <- FindNeighbors(object, reduction = \"pca.banksy\", dims = 1:30) object <- FindClusters(object, cluster.name = \"banksy_cluster\", resolution = 0.5) sourceCode R Idents(object) <- \"banksy_cluster\" p <- SpatialDimPlot(object, group.by = \"banksy_cluster\", label = T, repel = T, label.size = 4) p As with unsupervised clustering, we can highlight the spatial location of each tissue domain individually: sourceCode R banksy_cells <- CellsByIdentities(object) p <- SpatialDimPlot(object, cells.highlight = banksy_cells[setdiff(names(banksy_cells), \"NA\")], cols.highlight = c(\"#FFFF00\", \"grey50\"), facet.highlight = T, combine = T) + NoLegend() p Subset out anatomical regions anchor Users may wish to segment or subset out a restricted region for further downstream analysis. For example, here we create a coordinate-defined segmentation mask marking cortical and hippocampal regions from the entire dataset using the CreateSegmentation function, and then identify cells that fall into this region with the Overlay function. The list of coordinates is available for download here , and users can identify these boundaries when exploring their own datasets using the interactive=TRUE argument to SpatialDimPlot . ```sourceCode R cortex.coordinates <- as.data.frame(read.csv(\"/brahms/lis/visium_hd/final_mouse/cortex-hippocampus_coordinates.csv\")) cortex <- CreateSegmentation(cortex.coordinates) object[[\"cortex\"]] <- Overlay(object[[\"slice1.008um\"]], cortex) cortex <- subset(object, cells = Cells(object[[\"cortex\"]])) ``` Integration with scRNA-seq data (deconvolution) anchor Seurat v5 also includes support for Robust Cell Type Decomposition , a computational approach to deconvolve spot-level data from spatial datasets, when provided with an scRNA-seq reference. RCTD has been shown to accurately annotate spatial data from a variety of technologies, including SLIDE-seq, Visium, and the 10x Xenium in-situ spatial platform. We observe good performance with Visium HD as well. To run RCTD, we first install the spacexr package from GitHub which implements RCTD. When running RCTD, we follow the instructions from the RCTD vignette . sourceCode R if (!requireNamespace(\"spacexr\", quietly = TRUE)) { devtools::install_github(\"dmcable/spacexr\", build_vignettes = FALSE) } library(spacexr) RCTD takes an scRNA-seq dataset as a reference, and a spatial dataset as a query. For a reference, we use a mouse scRNA-seq dataset from the Allen Brain Atlas, available for download here . The reference scRNAs-eq dataset has been reduced to 200,000 cells (and rare cell types <25 cells have been removed). We use the cortex Visium HD object as the spatial query. For computational efficiency, we sketch the spatial query dataset, apply RCTD to deconvolute the ‘sketched’ cortical cells and annotate them, and then project these annotations to the full cortical dataset. ```sourceCode R sketch the cortical subset of the Visium HD dataset DefaultAssay(cortex) <- \"Spatial.008um\" cortex <- FindVariableFeatures(cortex) cortex <- SketchData( object = cortex, ncells = 50000, method = \"LeverageScore\", sketched.assay = \"sketch\" ) DefaultAssay(cortex) <- \"sketch\" cortex <- ScaleData(cortex) cortex <- RunPCA(cortex, assay = \"sketch\", reduction.name = \"pca.cortex.sketch\", verbose = T) cortex <- FindNeighbors(cortex, reduction = \"pca.cortex.sketch\", dims = 1:50) cortex <- RunUMAP(cortex, reduction = \"pca.cortex.sketch\", reduction.name = \"umap.cortex.sketch\", return.model = T, dims = 1:50, verbose = T) ``` ```sourceCode R load in the reference scRNA-seq dataset ref <- readRDS(\"/brahms/satijar/allen_scRNAseq_ref.Rds\") ``` ```sourceCode R Idents(ref) <- \"subclass_label\" counts <- ref[[\"RNA\"]]$counts cluster <- as.factor(ref$subclass_label) nUMI <- ref$nCount_RNA levels(cluster) <- gsub(\"/\", \"-\", levels(cluster)) cluster <- droplevels(cluster) create the RCTD reference object reference <- Reference(counts, cluster, nUMI) counts_hd <- cortex[[\"sketch\"]]$counts cortex_cells_hd <- colnames(cortex[[\"sketch\"]]) coords <- GetTissueCoordinates(cortex)[cortex_cells_hd, 1:2] create the RCTD query object query <- SpatialRNA(coords, counts_hd, colSums(counts_hd)) ``` ```sourceCode R run RCTD RCTD <- create.RCTD(query, reference, max_cores = 28) RCTD <- run.RCTD(RCTD, doublet_mode = \"doublet\") add results back to Seurat object cortex <- AddMetaData(cortex, metadata = RCTD@results$results_df) ``` ```sourceCode R project RCTD labels from sketched cortical cells to all cortical cells cortex$first_type <- as.character(cortex$first_type) cortex$first_type[is.na(cortex$first_type)] <- \"Unknown\" cortex <- ProjectData( object = cortex, assay = \"Spatial.008um\", full.reduction = \"pca.cortex\", sketched.assay = \"sketch\", sketched.reduction = \"pca.cortex.sketch\", umap.model = \"umap.cortex.sketch\", dims = 1:50, refdata = list(full_first_type = \"first_type\") ) ``` ```sourceCode R DefaultAssay(object) <- \"Spatial.008um\" we only ran RCTD on the cortical cells set labels to all other cells as \"Unknown\" object[[]][, \"full_first_type\"] <- \"Unknown\" object$full_first_type[Cells(cortex)] <- cortex$full_first_type[Cells(cortex)] ``` ```sourceCode R Idents(object) <- \"full_first_type\" now we can spatially map the location of any scRNA-seq cell type start with Layered (starts with L), excitatory neurons in the cortex cells <- CellsByIdentities(object) excitatory_names <- sort(grep(\"^L.* CTX\", names(cells), value = TRUE)) p <- SpatialDimPlot(object, cells.highlight = cells[excitatory_names], cols.highlight = c(\"#FFFF00\", \"grey50\"), facet.highlight = T, combine = T, ncol = 4) p ``` We can now look for associations between the scRNA-seq labels of individual bins, and their tissue domain identity (as assigned by BANKSY). By asking which domains the excitatory neuron cells fall in, we can rename the BANKSY clusters as neuronal layers: ```sourceCode R plot_cell_types <- function(data, label) { p <- ggplot(data, aes(x = get(label), y = n, fill = full_first_type)) + geom_bar(stat = \"identity\", position = \"stack\") + geom_text(aes(label = ifelse(n >= min_count_to_show_label, full_first_type, \"\")), position = position_stack(vjust = 0.5), size = 2) + xlab(label) + ylab(\"# of Spots\") + ggtitle(paste0(\"Distribution of Cell Types across \", label)) + theme_minimal() } cell_type_banksy_counts <- object[[]] %>% dplyr::filter(full_first_type %in% excitatory_names) %>% dplyr::count(full_first_type, banksy_cluster) min_count_to_show_label <- 20 p <- plot_cell_types(cell_type_banksy_counts, \"banksy_cluster\") p ``` Based on this plot, we can now assign cells (even if they are not excitatory neurons) to individual neuronal layers. sourceCode R Idents(object) <- \"banksy_cluster\" object$layer_id <- \"Unknown\" object$layer_id[WhichCells(object, idents = c(7))] <- \"Layer 2/3\" object$layer_id[WhichCells(object, idents = c(15))] <- \"Layer 4\" object$layer_id[WhichCells(object, idents = c(5))] <- \"Layer 5\" object$layer_id[WhichCells(object, idents = c(1))] <- \"Layer 6\" Finally, we can visualize the spatial distribution of other cell types, and ask which cortical layers they fall in. For example, in contrast to excitatory neurons, inhibitory (GABAergic) interneurons in the cortex are not spatially restricted to individual layers - but they do show biases. In our previous analysis of STARmap data , and consistent with previous work , we found that SST and PV interneuron classes tend to be restricted to layers 4-6, while VIP and Lamp5 interneurons tend to be located in layers 2/3. These results were based on an in-situ imaging technology which captures single-cell profiles - and here we ask whether we can find the same result in Visium HD spot-based data. ```sourceCode R set ID to RCTD label Idents(object) <- \"full_first_type\" Visualize distribution of 4 interneuron subtypes inhibitory_names <- c(\"Sst\", \"Pvalb\", \"Vip\", \"Lamp5\") cell_ids <- CellsByIdentities(object, idents = inhibitory_names) p <- SpatialDimPlot(object, cells.highlight = cell_ids, cols.highlight = c(\"#FFFF00\", \"grey50\"), facet.highlight = T, combine = T, ncol = 4) p ``` ```sourceCode R create barplot to show proportions of cell types of interest layer_table <- table(object$full_first_type, object$layer_id)[inhibitory_names, 1:4] neuron_props <- reshape2::melt(prop.table(layer_table), margin = 1) ggplot(neuron_props, aes(x = Var1, y = value, fill = Var2)) + geom_bar(stat = \"identity\", position = \"fill\") + labs(x = \"Cell type\", y = \"Proportion\", fill = \"Layer\") + theme_classic() ``` We recapitulate the same findings, previously identified in in-situ imaging data, in the Visium HD dataset. This highlights that the 8um binning of Visium HD, even though it does not represent true single cell resolution, is capable of accurately localizing scRNA-seq-defined cell types, although we strongly encourage users to orthogonally validate unexpected or surprising biological findings. Unsupervised clustering: mouse intestine anchor We briefly demonstrate our sketch-clustering workflow on a second Visium HD dataset, from the Mouse Small Intestine (FFPE), available for download here . We identify clusters, visualize their spatial locations, and report their top gene expression markers: sourceCode R localdir <- \"/brahms/lis/visium_hd/Visium_HD_Public_Data/HD_public_data/Visium_HD_Mouse_Small_Intestine/outs\" object <- Load10X_Spatial(data.dir = localdir, bin.size = 8) sourceCode R DefaultAssay(object) <- \"Spatial.008um\" object <- NormalizeData(object) object <- FindVariableFeatures(object) object <- ScaleData(object) sourceCode R object <- SketchData( object = object, ncells = 50000, method = \"LeverageScore\", sketched.assay = \"sketch\" ) sourceCode R DefaultAssay(object) <- \"sketch\" object <- FindVariableFeatures(object) object <- ScaleData(object) object <- RunPCA(object, assay = \"sketch\", reduction.name = \"pca.sketch\") object <- FindNeighbors(object, assay = \"sketch\", reduction = \"pca.sketch\", dims = 1:50) object <- FindClusters(object, cluster.name = \"seurat_cluster.sketched\", resolution = 3) object <- RunUMAP(object, reduction = \"pca.sketch\", reduction.name = \"umap.sketch\", return.model = T, dims = 1:50) sourceCode R object <- ProjectData( object = object, assay = \"Spatial.008um\", full.reduction = \"full.pca.sketch\", sketched.assay = \"sketch\", sketched.reduction = \"pca.sketch\", umap.model = \"umap.sketch\", dims = 1:50, refdata = list(seurat_cluster.projected = \"seurat_cluster.sketched\") ) ```sourceCode R Idents(object) <- \"seurat_cluster.projected\" DefaultAssay(object) <- \"Spatial.008um\" p1 <- DimPlot(object, reduction = \"umap.sketch\", label = F) + theme(legend.position = \"bottom\") p2 <- SpatialDimPlot(object, label = F) + theme(legend.position = \"bottom\") p1 | p2 ``` We visualize the location of each cluster individually: sourceCode R Idents(object) <- \"seurat_cluster.projected\" cells <- CellsByIdentities(object, idents = c(1, 5, 18, 26)) p <- SpatialDimPlot(object, cells.highlight = cells[setdiff(names(cells), \"NA\")], cols.highlight = c(\"#FFFF00\", \"grey50\"), facet.highlight = T, combine = T) + NoLegend() p ```sourceCode R DefaultAssay(object) <- \"Spatial.008um\" Idents(object) <- \"seurat_cluster.projected\" object_subset <- subset(object, cells = Cells(object[[\"Spatial.008um\"]]), downsample = 1000) DefaultAssay(object_subset) <- \"Spatial.008um\" Idents(object_subset) <- \"seurat_cluster.projected\" object_subset <- BuildClusterTree(object_subset, assay = \"Spatial.008um\", reduction = \"full.pca.sketch\", reorder = T) markers <- FindAllMarkers(object_subset, assay = \"Spatial.008um\", only.pos = TRUE) markers %>% group_by(cluster) %>% dplyr::filter(avg_log2FC > 1) %>% slice_head(n = 5) %>% ungroup() -> top5 object_subset <- ScaleData(object_subset, assay = \"Spatial.008um\", features = top5$gene) p <- DoHeatmap(object_subset, assay = \"Spatial.008um\", features = top5$gene, size = 2.5) + theme(axis.text = element_text(size = 5.5)) + NoLegend() p ``` Session Info sourceCode R sessionInfo() ``` R version 4.3.2 (2023-10-31) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.6 LTS Matrix products: default BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C time zone: America/New_York tzcode source: system (glibc) attached base packages: [1] stats graphics grDevices utils datasets methods base other attached packages: [1] dplyr_1.1.4 patchwork_1.2.0 ggplot2_3.5.0 [4] Seurat_5.1.0 testthat_3.2.1 SeuratObject_5.0.1.9011 [7] sp_2.1-4 loaded via a namespace (and not attached): [1] RColorBrewer_1.1-3 rstudioapi_0.15.0 jsonlite_1.8.8 [4] magrittr_2.0.3 ggbeeswarm_0.7.2 spatstat.utils_3.0-4 [7] farver_2.1.1 rmarkdown_2.26 fs_1.6.3 [10] ragg_1.2.7 vctrs_0.6.5 ROCR_1.0-11 [13] memoise_2.0.1 spatstat.explore_3.2-6 htmltools_0.5.7 [16] usethis_2.2.3 sass_0.4.8 sctransform_0.4.1 [19] parallelly_1.37.1 KernSmooth_2.23-22 bslib_0.6.1 [22] htmlwidgets_1.6.4 desc_1.4.3 ica_1.0-3 [25] plyr_1.8.9 plotly_4.10.4 zoo_1.8-12 [28] cachem_1.0.8 igraph_2.0.2 mime_0.12 [31] lifecycle_1.0.4 pkgconfig_2.0.3 Matrix_1.6-5 [34] R6_2.5.1 fastmap_1.1.1 fitdistrplus_1.1-11 [37] future_1.33.1 shiny_1.8.0 digest_0.6.34 [40] colorspace_2.1-0 tensor_1.5 rprojroot_2.0.4 [43] RSpectra_0.16-1 irlba_2.3.5.1 pkgload_1.3.4 [46] textshaping_0.3.7 labeling_0.4.3 progressr_0.14.0 [49] fansi_1.0.6 spatstat.sparse_3.0-3 polyclip_1.10-6 [52] abind_1.4-5 httr_1.4.7 compiler_4.3.2 [55] remotes_2.4.2.1 withr_3.0.0 fastDummies_1.7.3 [58] highr_0.10 pkgbuild_1.4.3 R.utils_2.12.3 [61] MASS_7.3-60.0.1 sessioninfo_1.2.2 tools_4.3.2 [64] vipor_0.4.7 lmtest_0.9-40 ape_5.7-1 [67] beeswarm_0.4.0 httpuv_1.6.14 future.apply_1.11.1 [70] goftest_1.2-3 R.oo_1.26.0 glue_1.7.0 [73] nlme_3.1-164 R.cache_0.16.0 promises_1.2.1 [76] grid_4.3.2 Rtsne_0.17 cluster_2.1.6 [79] reshape2_1.4.4 generics_0.1.3 gtable_0.3.4 [82] spatstat.data_3.0-4 R.methodsS3_1.8.2 tidyr_1.3.1 [85] data.table_1.15.2 utf8_1.2.4 spatstat.geom_3.2-9 [88] RcppAnnoy_0.0.22 ggrepel_0.9.5 RANN_2.6.1 [91] pillar_1.9.0 stringr_1.5.1 limma_3.58.1 [94] spam_2.10-0 RcppHNSW_0.6.0 later_1.3.2 [97] splines_4.3.2 lattice_0.22-5 deldir_2.0-4 [100] survival_3.5-8 tidyselect_1.2.0 miniUI_0.1.1.1 [103] pbapply_1.7-2 knitr_1.45 gridExtra_2.3 [106] scattermore_1.2 xfun_0.42 statmod_1.5.0 [109] brio_1.1.4 devtools_2.4.5 matrixStats_1.2.0 [112] stringi_1.8.3 lazyeval_0.2.2 yaml_2.3.8 [115] evaluate_0.23 codetools_0.2-20 tibble_3.2.1 [118] cli_3.6.2 uwot_0.1.16 xtable_1.8-4 [121] reticulate_1.35.0 systemfonts_1.0.5 munsell_0.5.0 [124] jquerylib_0.1.4 styler_1.10.2 Rcpp_1.0.12 [127] spatstat.random_3.2-3 globals_0.16.2 png_0.1-8 [130] ggrastr_1.0.2 parallel_4.3.2 ellipsis_0.3.2 [133] pkgdown_2.0.7 presto_1.0.0 dotCall64_1.1-1 [136] profvis_0.3.8 urlchecker_1.0.1 listenv_0.9.1 [139] viridisLite_0.4.2 scales_1.3.0 ggridges_0.5.6 [142] leiden_0.4.3.1 purrr_1.0.2 rlang_1.1.3 [145] cowplot_1.1.3 ```",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/visiumhd_analysis_vignette",
      "title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat • Seurat",
      "ogTitle": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "language": "en",
      "og:title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "scrapeId": "09c36e0f-338f-47a6-89a7-0f8729cb9a45",
      "viewport": "width=device-width, initial-scale=1.0",
      "sourceURL": "https://satijalab.org/seurat/articles/visiumhd_analysis_vignette",
      "statusCode": 200,
      "ogDescription": "Seurat",
      "og:description": "Seurat"
    }
  },
  {
    "processed_text": "",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/seurat5_get_started.html",
      "error": "Not Found",
      "scrapeId": "08400abc-3b54-4505-ac46-bbd45483a9a4",
      "sourceURL": "https://satijalab.org/seurat/articles/seurat5_get_started.html",
      "statusCode": 404
    }
  },
  {
    "processed_text": "",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/seurat5_conversion_vignette.html",
      "error": "Not Found",
      "scrapeId": "0d82cc88-8853-41c0-9995-93b630ffd8b1",
      "sourceURL": "https://satijalab.org/seurat/articles/seurat5_conversion_vignette.html",
      "statusCode": 404
    }
  },
  {
    "processed_text": "Cell-Cycle Scoring and Regression Compiled: 2023-10-31 Source: vignettes/cell_cycle_vignette.Rmd cell_cycle_vignette.Rmd We demonstrate how to mitigate the effects of cell cycle heterogeneity in scRNA-seq data by calculating cell cycle phase scores based on canonical markers, and regressing these out of the data during pre-processing. We demonstrate this on a dataset of murine hematopoietic progenitors ( Nestorowa et al ., Blood 2016 ).You can download the files needed to run this vignette here . ```sourceCode R library(Seurat) Read in the expression matrix The first row is a header row, the first column is rownames exp.mat <- read.table(file = \"/brahms/shared/vignette-data/cell_cycle_vignette_files/nestorawa_forcellcycle_expressionMatrix.txt\", header = TRUE, as.is = TRUE, row.names = 1) A list of cell cycle markers, from Tirosh et al, 2015, is loaded with Seurat. We can segregate this list into markers of G2/M phase and markers of S phase s.genes <- cc.genes$s.genes g2m.genes <- cc.genes$g2m.genes Create our Seurat object and complete the initalization steps marrow <- CreateSeuratObject(counts = Matrix::Matrix(as.matrix(exp.mat), sparse = T)) marrow <- NormalizeData(marrow) marrow <- FindVariableFeatures(marrow, selection.method = \"vst\") marrow <- ScaleData(marrow, features = rownames(marrow)) ``` If we run a PCA on our object, using the variable genes we found in FindVariableFeatures() above, we see that while most of the variance can be explained by lineage, PC8 and PC10 are split on cell-cycle genes including TOP2A and MKI67 . We will attempt to regress this signal from the data, so that cell-cycle heterogeneity does not contribute to PCA or downstream analysis. sourceCode R marrow <- RunPCA(marrow, features = VariableFeatures(marrow), ndims.print = 6:10, nfeatures.print = 10) ``` PC_ 6 Positive: SELL, ARL6IP1, CCL9, CD34, ADGRL4, BPIFC, NUSAP1, FAM64A, CD244, C030034L19RIK Negative: LY6C2, AA467197, CYBB, MGST2, ITGB2, PF4, CD74, ATP1B1, GP1BB, TREM3 PC_ 7 Positive: F13A1, LY86, CFP, IRF8, CSF1R, TIFAB, IFI209, CCR2, TNS4, MS4A6C Negative: HDC, CPA3, PGLYRP1, MS4A3, NKG7, UBE2C, CCNB1, NUSAP1, PLK1, FUT8 PC_ 8 Positive: NUSAP1, UBE2C, KIF23, PLK1, CENPF, FAM64A, CCNB1, H2AFX, ID2, CDC20 Negative: WFDC17, SLC35D3, ADGRL4, VLDLR, CD33, H2AFY, P2RY14, IFI206, CCL9, CD34 PC_ 9 Positive: IGKC, JCHAIN, LY6D, MZB1, CD74, IGLC2, FCRLA, IGKV4-50, IGHM, IGHV9-1 Negative: SLC2A6, HBA-A1, HBA-A2, IGHV8-7, FCER1G, F13A1, HBB-BS, PLD4, HBB-BT, IGFBP4 PC_ 10 Positive: H2AFX, FAM64A, ZFP383, NUSAP1, CDC25B, CENPF, GBP10, TOP2A, GBP6, GFRA1 Negative: CTSW, XKRX, PRR5L, RORA, MBOAT4, A630014C17RIK, ZFP105, COL9A3, CLEC2I, TRAT1 ``` sourceCode R DimHeatmap(marrow, dims = c(8, 10)) Assign Cell-Cycle Scores anchor First, we assign each cell a score, based on its expression of G2/M and S phase markers. These marker sets should be anticorrelated in their expression levels, and cells expressing neither are likely not cycling and in G1 phase. We assign scores in the CellCycleScoring() function, which stores S and G2/M scores in object meta data, along with the predicted classification of each cell in either G2M, S or G1 phase. CellCycleScoring() can also set the identity of the Seurat object to the cell-cycle phase by passing set.ident = TRUE (the original identities are stored as old.ident ). Please note that Seurat does not use the discrete classifications (G2M/G1/S) in downstream cell cycle regression. Instead, it uses the quantitative scores for G2M and S phase. However, we provide our predicted classifications in case they are of interest. ```sourceCode R marrow <- CellCycleScoring(marrow, s.features = s.genes, g2m.features = g2m.genes, set.ident = TRUE) view cell cycle scores and phase assignments head(marrow[[]]) ``` ``` orig.ident nCount_RNA nFeature_RNA S.Score G2M.Score Phase Prog_013 Prog 2563089 10211 -0.14248691 -0.4680395 G1 Prog_019 Prog 3030620 9991 -0.16915786 0.5851766 G2M Prog_031 Prog 1293487 10192 -0.34627038 -0.3971879 G1 Prog_037 Prog 1357987 9599 -0.44270212 0.6820229 G2M Prog_008 Prog 4079891 10540 0.55854051 0.1284359 S Prog_014 Prog 2569783 10788 0.07116218 0.3166073 G2M old.ident Prog_013 Prog Prog_019 Prog Prog_031 Prog Prog_037 Prog Prog_008 Prog Prog_014 Prog ``` ```sourceCode R Visualize the distribution of cell cycle markers across RidgePlot(marrow, features = c(\"PCNA\", \"TOP2A\", \"MCM6\", \"MKI67\"), ncol = 2) ``` ```sourceCode R Running a PCA on cell cycle genes reveals, unsurprisingly, that cells separate entirely by phase marrow <- RunPCA(marrow, features = c(s.genes, g2m.genes)) DimPlot(marrow) ``` sourceCode R library(ggplot2) plot <- DimPlot(marrow) + theme(axis.title = element_text(size = 18), legend.text = element_text(size = 18)) + guides(colour = guide_legend(override.aes = list(size = 10))) ggsave(filename = \"../output/images/cell_cycle_vignette.jpg\", height = 7, width = 12, plot = plot, quality = 50) We score single cells based on the scoring strategy described in Tirosh et al . 2016 . See ?AddModuleScore() in Seurat for more information, this function can be used to calculate supervised module scores for any gene list. Regress out cell cycle scores during data scaling anchor We now attempt to subtract (‘regress out’) this source of heterogeneity from the data. For users of Seurat v1.4, this was implemented in RegressOut . However, as the results of this procedure are stored in the scaled data slot (therefore overwriting the output of ScaleData() ), we now merge this functionality into the ScaleData() function itself. For each gene, Seurat models the relationship between gene expression and the S and G2M cell cycle scores. The scaled residuals of this model represent a ‘corrected’ expression matrix, that can be used downstream for dimensional reduction. sourceCode R marrow <- ScaleData(marrow, vars.to.regress = c(\"S.Score\", \"G2M.Score\"), features = rownames(marrow)) ```sourceCode R Now, a PCA on the variable genes no longer returns components associated with cell cycle marrow <- RunPCA(marrow, features = VariableFeatures(marrow), nfeatures.print = 10) ``` ``` PC_ 1 Positive: BLVRB, CAR2, KLF1, AQP1, CES2G, ERMAP, CAR1, FAM132A, RHD, SPHK1 Negative: TMSB4X, H2AFY, CORO1A, PLAC8, EMB, MPO, PRTN3, CD34, LCP1, BC035044 PC_ 2 Positive: ANGPT1, ADGRG1, MEIS1, ITGA2B, MPL, DAPP1, APOE, RAB37, GATA2, F2R Negative: LY6C2, ELANE, HP, IGSF6, ANXA3, CTSG, CLEC12A, TIFAB, SLPI, ALAS1 PC_ 3 Positive: APOE, GATA2, NKG7, MUC13, MS4A3, RAB44, HDC, CPA3, FCGR3, TUBA8 Negative: FLT3, DNTT, LSP1, WFDC17, MYL10, GIMAP6, LAX1, GPR171, TBXA2R, SATB1 PC_ 4 Positive: CSRP3, ST8SIA6, DNTT, MPEG1, SCIN, LGALS1, CMAH, RGL1, APOE, MFSD2B Negative: PROCR, MPL, HLF, MMRN1, SERPINA3G, ESAM, GSTM1, D630039A03RIK, MYL10, LY6A PC_ 5 Positive: CPA3, LMO4, IKZF2, IFITM1, FUT8, MS4A2, SIGLECF, CSRP3, HDC, RAB44 Negative: PF4, GP1BB, SDPR, F2RL2, RAB27B, SLC14A1, TREML1, PBX1, F2R, TUBA8 ``` ```sourceCode R When running a PCA on only cell cycle genes, cells no longer separate by cell-cycle phase marrow <- RunPCA(marrow, features = c(s.genes, g2m.genes)) DimPlot(marrow) ``` As the best cell cycle markers are extremely well conserved across tissues and species, we have found this procedure to work robustly and reliably on diverse datasets. Alternate Workflow anchor The procedure above removes all signal associated with cell cycle. In some cases, we’ve found that this can negatively impact downstream analysis, particularly in differentiating processes (like murine hematopoiesis), where stem cells are quiescent and differentiated cells are proliferating (or vice versa). In this case, regressing out all cell cycle effects can blur the distinction between stem and progenitor cells as well. As an alternative, we suggest regressing out the difference between the G2M and S phase scores. This means that signals separating non-cycling cells and cycling cells will be maintained, but differences in cell cycle phase among proliferating cells (which are often uninteresting), will be regressed out of the data sourceCode R marrow$CC.Difference <- marrow$S.Score - marrow$G2M.Score marrow <- ScaleData(marrow, vars.to.regress = \"CC.Difference\", features = rownames(marrow)) ```sourceCode R cell cycle effects strongly mitigated in PCA marrow <- RunPCA(marrow, features = VariableFeatures(marrow), nfeatures.print = 10) ``` ``` PC_ 1 Positive: BLVRB, KLF1, ERMAP, FAM132A, CAR2, RHD, CES2G, SPHK1, AQP1, SLC38A5 Negative: TMSB4X, CORO1A, PLAC8, H2AFY, LAPTM5, CD34, LCP1, TMEM176B, IGFBP4, EMB PC_ 2 Positive: APOE, GATA2, RAB37, ANGPT1, ADGRG1, MEIS1, MPL, F2R, PDZK1IP1, DAPP1 Negative: CTSG, ELANE, LY6C2, HP, CLEC12A, ANXA3, IGSF6, TIFAB, SLPI, MPO PC_ 3 Positive: APOE, GATA2, NKG7, MUC13, ITGA2B, TUBA8, CPA3, RAB44, SLC18A2, CD9 Negative: DNTT, FLT3, WFDC17, LSP1, MYL10, LAX1, GIMAP6, IGHM, CD24A, MN1 PC_ 4 Positive: CSRP3, ST8SIA6, SCIN, LGALS1, APOE, ITGB7, MFSD2B, RGL1, DNTT, IGHV1-23 Negative: MPL, MMRN1, PROCR, HLF, SERPINA3G, ESAM, PTGS1, D630039A03RIK, NDN, PPIC PC_ 5 Positive: GP1BB, PF4, SDPR, F2RL2, TREML1, RAB27B, SLC14A1, PBX1, PLEK, TUBA8 Negative: HDC, LMO4, CSRP3, IFITM1, FCGR3, HLF, CPA3, PROCR, PGLYRP1, IKZF2 ``` ```sourceCode R when running a PCA on cell cycle genes, actively proliferating cells remain distinct from G1 cells however, within actively proliferating cells, G2M and S phase cells group together marrow <- RunPCA(marrow, features = c(s.genes, g2m.genes)) DimPlot(marrow) ``` Session Info sourceCode R sessionInfo() ``` R version 4.2.2 Patched (2022-11-10 r83330) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.6 LTS Matrix products: default BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats graphics grDevices utils datasets methods base other attached packages: [1] ggplot2_3.4.4 Seurat_5.0.0 SeuratObject_5.0.0 sp_2.1-1 loaded via a namespace (and not attached): [1] ggbeeswarm_0.7.1 Rtsne_0.16 colorspace_2.1-0 [4] deldir_1.0-9 ellipsis_0.3.2 ggridges_0.5.4 [7] rprojroot_2.0.3 RcppHNSW_0.5.0 fs_1.6.3 [10] spatstat.data_3.0-3 farver_2.1.1 leiden_0.4.3 [13] listenv_0.9.0 ggrepel_0.9.4 RSpectra_0.16-1 [16] fansi_1.0.5 codetools_0.2-19 splines_4.2.2 [19] cachem_1.0.8 knitr_1.45 polyclip_1.10-6 [22] spam_2.10-0 jsonlite_1.8.7 ica_1.0-3 [25] cluster_2.1.4 png_0.1-8 uwot_0.1.16 [28] spatstat.sparse_3.0-3 sctransform_0.4.1 shiny_1.7.5.1 [31] compiler_4.2.2 httr_1.4.7 Matrix_1.6-1.1 [34] fastmap_1.1.1 lazyeval_0.2.2 cli_3.6.1 [37] later_1.3.1 formatR_1.14 htmltools_0.5.6.1 [40] tools_4.2.2 igraph_1.5.1 dotCall64_1.1-0 [43] gtable_0.3.4 glue_1.6.2 reshape2_1.4.4 [46] RANN_2.6.1 dplyr_1.1.3 Rcpp_1.0.11 [49] scattermore_1.2 jquerylib_0.1.4 pkgdown_2.0.7 [52] vctrs_0.6.4 nlme_3.1-162 spatstat.explore_3.2-5 [55] progressr_0.14.0 lmtest_0.9-40 spatstat.random_3.2-1 [58] xfun_0.40 stringr_1.5.0 globals_0.16.2 [61] mime_0.12 miniUI_0.1.1.1 lifecycle_1.0.3 [64] irlba_2.3.5.1 goftest_1.2-3 future_1.33.0 [67] MASS_7.3-58.2 zoo_1.8-12 scales_1.2.1 [70] spatstat.utils_3.0-4 ragg_1.2.5 promises_1.2.1 [73] parallel_4.2.2 RColorBrewer_1.1-3 yaml_2.3.7 [76] gridExtra_2.3 memoise_2.0.1 reticulate_1.34.0 [79] pbapply_1.7-2 ggrastr_1.0.1 sass_0.4.7 [82] stringi_1.7.12 highr_0.10 desc_1.4.2 [85] fastDummies_1.7.3 rlang_1.1.1 pkgconfig_2.0.3 [88] systemfonts_1.0.4 matrixStats_1.0.0 evaluate_0.22 [91] lattice_0.21-9 tensor_1.5 ROCR_1.0-11 [94] purrr_1.0.2 labeling_0.4.3 patchwork_1.1.3 [97] htmlwidgets_1.6.2 cowplot_1.1.1 tidyselect_1.2.0 [100] parallelly_1.36.0 RcppAnnoy_0.0.21 plyr_1.8.9 [103] magrittr_2.0.3 R6_2.5.1 generics_0.1.3 [106] withr_2.5.2 pillar_1.9.0 fitdistrplus_1.1-11 [109] abind_1.4-5 survival_3.5-7 tibble_3.2.1 [112] future.apply_1.11.0 KernSmooth_2.23-22 utf8_1.2.4 [115] spatstat.geom_3.2-7 plotly_4.10.3 rmarkdown_2.25 [118] grid_4.2.2 data.table_1.14.8 digest_0.6.33 [121] xtable_1.8-4 tidyr_1.3.0 httpuv_1.6.12 [124] textshaping_0.3.6 munsell_0.5.0 beeswarm_0.4.0 [127] viridisLite_0.4.2 vipor_0.4.5 bslib_0.5.1 ```",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/cell_cycle_vignette",
      "title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat • Seurat",
      "ogTitle": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "language": "en",
      "og:title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "scrapeId": "1524d438-9ee8-4848-90ef-8f83cfa00406",
      "viewport": "width=device-width, initial-scale=1.0",
      "sourceURL": "https://satijalab.org/seurat/articles/cell_cycle_vignette",
      "statusCode": 200,
      "ogDescription": "Seurat",
      "og:description": "Seurat"
    }
  },
  {
    "processed_text": "Fast integration using reciprocal PCA (RPCA) Compiled: October 31, 2023 Source: vignettes/integration_rpca.Rmd integration_rpca.Rmd In this vignette, we present a slightly modified workflow for the integration of scRNA-seq datasets. Instead of utilizing canonical correlation analysis (‘CCA’) to identify anchors, we instead utilize reciprocal PCA (‘RPCA’). When determining anchors between any two datasets using RPCA, we project each dataset into the others PCA space and constrain the anchors by the same mutual neighborhood requirement. The commands for both workflows are largely identical, but the two methods may be applied in different context. By identifying shared sources of variation between datasets, CCA is well-suited for identifying anchors when cell types are conserved, but there are very substantial differences in gene expression across experiments. CCA-based integration therefore enables integrative analysis when experimental conditions or disease states introduce very strong expression shifts, or when integrating datasets across modalities and species. However, CCA-based integration may also lead to overcorrection, especially when a large proportion of cells are non-overlapping across datasets. RPCA-based integration runs significantly faster, and also represents a more conservative approach where cells in different biological states are less likely to ‘align’ after integration. We therefore recommend RPCA during integrative analysis where: A substantial fraction of cells in one dataset have no matching type in the other Datasets originate from the same platform (i.e. multiple lanes of 10x genomics) There are a large number of datasets or cells to integrate (see here for more tips on integrating large datasets) Below, we demonstrate the use of reciprocal PCA to align the same stimulated and resting datasets first analyzed in our introduction to scRNA-seq integration vignette. While the list of commands is nearly identical, this workflow requires users to run principal components analysis (PCA) individually on each dataset prior to integration. Users should also set the ‘reduction’ argument to ‘rpca’, when running FindIntegrationAnchors() . ```sourceCode R library(Seurat) library(SeuratData) install dataset InstallData(\"ifnb\") ``` ```sourceCode R load dataset ifnb <- LoadData(\"ifnb\") split the dataset into a list of two seurat objects (stim and CTRL) ifnb.list <- SplitObject(ifnb, split.by = \"stim\") normalize and identify variable features for each dataset independently ifnb.list <- lapply(X = ifnb.list, FUN = function(x) { x <- NormalizeData(x) x <- FindVariableFeatures(x, selection.method = \"vst\", nfeatures = 2000) }) select features that are repeatedly variable across datasets for integration run PCA on each dataset using these features features <- SelectIntegrationFeatures(object.list = ifnb.list) ifnb.list <- lapply(X = ifnb.list, FUN = function(x) { x <- ScaleData(x, features = features, verbose = FALSE) x <- RunPCA(x, features = features, verbose = FALSE) }) ``` Perform integration anchor We then identify anchors using the FindIntegrationAnchors() function, which takes a list of Seurat objects as input, and use these anchors to integrate the two datasets together with IntegrateData() . sourceCode R immune.anchors <- FindIntegrationAnchors(object.list = ifnb.list, anchor.features = features, reduction = \"rpca\") ```sourceCode R this command creates an 'integrated' data assay immune.combined <- IntegrateData(anchorset = immune.anchors) ``` Now we can run a single integrated analysis on all cells! ```sourceCode R specify that we will perform downstream analysis on the corrected data note that the original unmodified data still resides in the 'RNA' assay DefaultAssay(immune.combined) <- \"integrated\" Run the standard workflow for visualization and clustering immune.combined <- ScaleData(immune.combined, verbose = FALSE) immune.combined <- RunPCA(immune.combined, npcs = 30, verbose = FALSE) immune.combined <- RunUMAP(immune.combined, reduction = \"pca\", dims = 1:30) immune.combined <- FindNeighbors(immune.combined, reduction = \"pca\", dims = 1:30) immune.combined <- FindClusters(immune.combined, resolution = 0.5) ``` ```sourceCode R Visualization p1 <- DimPlot(immune.combined, reduction = \"umap\", group.by = \"stim\") p2 <- DimPlot(immune.combined, reduction = \"umap\", group.by = \"seurat_annotations\", label = TRUE, repel = TRUE) p1 + p2 ``` Modifying the strength of integration anchor The results show that rpca-based integration is more conservative, and in this case, do not perfectly align a subset of cells (which are naive and memory T cells) across experiments. You can increase the strength of alignment by increasing the k.anchor parameter, which is set to 5 by default. Increasing this parameter to 20 will assist in aligning these populations. ```sourceCode R immune.anchors <- FindIntegrationAnchors(object.list = ifnb.list, anchor.features = features, reduction = \"rpca\", k.anchor = 20) immune.combined <- IntegrateData(anchorset = immune.anchors) immune.combined <- ScaleData(immune.combined, verbose = FALSE) immune.combined <- RunPCA(immune.combined, npcs = 30, verbose = FALSE) immune.combined <- RunUMAP(immune.combined, reduction = \"pca\", dims = 1:30) immune.combined <- FindNeighbors(immune.combined, reduction = \"pca\", dims = 1:30) immune.combined <- FindClusters(immune.combined, resolution = 0.5) ``` ``` Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck Number of nodes: 13999 Number of edges: 594845 Running Louvain algorithm... Maximum modularity in 10 random starts: 0.9098 Number of communities: 15 Elapsed time: 2 seconds ``` ```sourceCode R Visualization p1 <- DimPlot(immune.combined, reduction = \"umap\", group.by = \"stim\") p2 <- DimPlot(immune.combined, reduction = \"umap\", label = TRUE, repel = TRUE) p1 + p2 ``` sourceCode R library(ggplot2) plot <- DimPlot(immune.combined, group.by = \"stim\") + xlab(\"UMAP 1\") + ylab(\"UMAP 2\") + theme(axis.title = element_text(size = 18), legend.text = element_text(size = 18)) + guides(colour = guide_legend(override.aes = list(size = 10))) ggsave(filename = \"../output/images/rpca_integration.jpg\", height = 7, width = 12, plot = plot, quality = 50) Now that the datasets have been integrated, you can follow the previous steps in the introduction to scRNA-seq integration vignette to identify cell types and cell type-specific responses. Performing integration on datasets normalized with SCTransform anchor As an additional example, we repeat the analyses performed above, but normalize the datasets using SCTransform . We may choose to set the method parameter to glmGamPoi (install here ) in order to enable faster estimation of regression parameters in SCTransform() . sourceCode R ifnb <- LoadData(\"ifnb\") ifnb.list <- SplitObject(ifnb, split.by = \"stim\") ifnb.list <- lapply(X = ifnb.list, FUN = SCTransform, method = \"glmGamPoi\") features <- SelectIntegrationFeatures(object.list = ifnb.list, nfeatures = 3000) ifnb.list <- PrepSCTIntegration(object.list = ifnb.list, anchor.features = features) ifnb.list <- lapply(X = ifnb.list, FUN = RunPCA, features = features) sourceCode R immune.anchors <- FindIntegrationAnchors(object.list = ifnb.list, normalization.method = \"SCT\", anchor.features = features, dims = 1:30, reduction = \"rpca\", k.anchor = 20) immune.combined.sct <- IntegrateData(anchorset = immune.anchors, normalization.method = \"SCT\", dims = 1:30) ``` [1] 1 [1] 2 ``` sourceCode R immune.combined.sct <- RunPCA(immune.combined.sct, verbose = FALSE) immune.combined.sct <- RunUMAP(immune.combined.sct, reduction = \"pca\", dims = 1:30) ```sourceCode R Visualization p1 <- DimPlot(immune.combined.sct, reduction = \"umap\", group.by = \"stim\") p2 <- DimPlot(immune.combined.sct, reduction = \"umap\", group.by = \"seurat_annotations\", label = TRUE, repel = TRUE) p1 + p2 ``` Session Info sourceCode R sessionInfo() ``` R version 4.2.2 Patched (2022-11-10 r83330) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.6 LTS Matrix products: default BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats graphics grDevices utils datasets methods base other attached packages: [1] ggplot2_3.4.4 thp1.eccite.SeuratData_3.1.5 [3] stxBrain.SeuratData_0.1.1 ssHippo.SeuratData_3.1.4 [5] pbmcsca.SeuratData_3.0.0 pbmcref.SeuratData_1.0.0 [7] pbmcMultiome.SeuratData_0.1.4 pbmc3k.SeuratData_3.1.4 [9] panc8.SeuratData_3.0.2 ifnb.SeuratData_3.0.0 [11] hcabm40k.SeuratData_3.0.0 cbmc.SeuratData_3.1.4 [13] bmcite.SeuratData_0.3.0 SeuratData_0.2.2.9001 [15] Seurat_5.0.0 SeuratObject_5.0.0 [17] sp_2.1-1 loaded via a namespace (and not attached): [1] spam_2.10-0 systemfonts_1.0.4 [3] plyr_1.8.9 igraph_1.5.1 [5] lazyeval_0.2.2 splines_4.2.2 [7] RcppHNSW_0.5.0 listenv_0.9.0 [9] scattermore_1.2 GenomeInfoDb_1.34.9 [11] digest_0.6.33 htmltools_0.5.6.1 [13] fansi_1.0.5 magrittr_2.0.3 [15] memoise_2.0.1 tensor_1.5 [17] cluster_2.1.4 ROCR_1.0-11 [19] globals_0.16.2 matrixStats_1.0.0 [21] pkgdown_2.0.7 spatstat.sparse_3.0-3 [23] colorspace_2.1-0 rappdirs_0.3.3 [25] ggrepel_0.9.4 textshaping_0.3.6 [27] xfun_0.40 dplyr_1.1.3 [29] RCurl_1.98-1.12 crayon_1.5.2 [31] jsonlite_1.8.7 progressr_0.14.0 [33] spatstat.data_3.0-3 survival_3.5-7 [35] zoo_1.8-12 glue_1.6.2 [37] polyclip_1.10-6 gtable_0.3.4 [39] zlibbioc_1.44.0 XVector_0.38.0 [41] leiden_0.4.3 DelayedArray_0.24.0 [43] future.apply_1.11.0 BiocGenerics_0.44.0 [45] abind_1.4-5 scales_1.2.1 [47] spatstat.random_3.2-1 miniUI_0.1.1.1 [49] Rcpp_1.0.11 viridisLite_0.4.2 [51] xtable_1.8-4 reticulate_1.34.0 [53] dotCall64_1.1-0 stats4_4.2.2 [55] htmlwidgets_1.6.2 httr_1.4.7 [57] RColorBrewer_1.1-3 ellipsis_0.3.2 [59] ica_1.0-3 farver_2.1.1 [61] pkgconfig_2.0.3 sass_0.4.7 [63] uwot_0.1.16 deldir_1.0-9 [65] utf8_1.2.4 labeling_0.4.3 [67] tidyselect_1.2.0 rlang_1.1.1 [69] reshape2_1.4.4 later_1.3.1 [71] munsell_0.5.0 tools_4.2.2 [73] cachem_1.0.8 cli_3.6.1 [75] generics_0.1.3 ggridges_0.5.4 [77] evaluate_0.22 stringr_1.5.0 [79] fastmap_1.1.1 yaml_2.3.7 [81] ragg_1.2.5 goftest_1.2-3 [83] knitr_1.45 fs_1.6.3 [85] fitdistrplus_1.1-11 purrr_1.0.2 [87] RANN_2.6.1 sparseMatrixStats_1.10.0 [89] pbapply_1.7-2 future_1.33.0 [91] nlme_3.1-162 mime_0.12 [93] formatR_1.14 compiler_4.2.2 [95] plotly_4.10.3 png_0.1-8 [97] spatstat.utils_3.0-4 tibble_3.2.1 [99] glmGamPoi_1.10.2 bslib_0.5.1 [101] stringi_1.7.12 highr_0.10 [103] desc_1.4.2 RSpectra_0.16-1 [105] lattice_0.21-9 Matrix_1.6-1.1 [107] vctrs_0.6.4 pillar_1.9.0 [109] lifecycle_1.0.3 spatstat.geom_3.2-7 [111] lmtest_0.9-40 jquerylib_0.1.4 [113] RcppAnnoy_0.0.21 bitops_1.0-7 [115] data.table_1.14.8 cowplot_1.1.1 [117] irlba_2.3.5.1 GenomicRanges_1.50.2 [119] httpuv_1.6.12 patchwork_1.1.3 [121] R6_2.5.1 promises_1.2.1 [123] KernSmooth_2.23-22 gridExtra_2.3 [125] IRanges_2.32.0 parallelly_1.36.0 [127] codetools_0.2-19 fastDummies_1.7.3 [129] MASS_7.3-58.2 SummarizedExperiment_1.28.0 [131] rprojroot_2.0.3 withr_2.5.2 [133] sctransform_0.4.1 GenomeInfoDbData_1.2.9 [135] S4Vectors_0.36.2 parallel_4.2.2 [137] grid_4.2.2 tidyr_1.3.0 [139] DelayedMatrixStats_1.20.0 rmarkdown_2.25 [141] MatrixGenerics_1.10.0 Rtsne_0.16 [143] spatstat.explore_3.2-5 Biobase_2.58.0 [145] shiny_1.7.5.1 ```",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/integration_rpca",
      "title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat • Seurat",
      "ogTitle": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "language": "en",
      "og:title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "scrapeId": "1449a45f-43f6-4b85-907b-a3037ee7a551",
      "viewport": "width=device-width, initial-scale=1.0",
      "sourceURL": "https://satijalab.org/seurat/articles/integration_rpca",
      "statusCode": 200,
      "ogDescription": "Seurat",
      "og:description": "Seurat"
    }
  },
  {
    "processed_text": "Map COVID PBMC datasets to a healthy reference Compiled: 2023-11-15 Source: vignettes/COVID_SCTMapping.Rmd COVID_SCTMapping.Rmd library(Seurat) library(BPCells) library(dplyr) library(patchwork) library(ggplot2) options(future.globals.maxSize = 1e9) Introduction: Reference mapping analysis in Seurat v5 anchor In Seurat v5, we introduce a scalable approach for reference mapping datasets from separate studies or individuals. Reference mapping is a powerful approach to identify consistent labels across studies and perform cross-dataset analysis. We emphasize that while individual datasets are manageable in size, the aggregate of many datasets often amounts to millions of cell which do not fit in-memory. Furthermore, cross-dataset analysis is often challenged by disparate or unique cell type labels. Through reference mapping, we annotate all cells with a common reference for consistent cell type labels. Importantly, we never simultaneously load all of the cells in-memory to maintain low memory usage. In this vignette, we reference map three publicly available datasets totaling 1,498,064 cells and 277 donors which are available through CZI cellxgene collections : Ahern, et al., Nature 2022 , Jin, et al., Science 2021 , and Yoshida, et al., Nature 2022 . Each dataset consists of PBMCs from both healthy donors and donors diagnosed with COVID-19. Using the harmonized annotations, we demonstrate how to prepare a pseudobulk object to perform differential expression analysis across disease within cell types. Prior to running this vignette, please install Seurat v5 and see the BPCells vignette to construct the on-disk object used in this vignette. Additionally, we map to our annotated CITE-seq reference containing 162,000 cells and 228 antibodies ( Hao , Hao , et al., Cell 2021 ) which is available for download here . Load the PBMC Reference Dataset and Query Datasets anchor We first load the reference (available here ) and normalize the query Seurat object prepared in the BPCells interaction vignette . The query object consists of datasets from three different studies constructed using the CreateSeuratObject function, which accepts a list of BPCells matrices as input. Within the Seurat object, the three datasets reside in the RNA assay in three separate layers on-disk. sourceCode R reference <- readRDS(\"/brahms/hartmana/vignette_data/pbmc_multimodal_2023.rds\") object <- readRDS(\"/brahms/mollag/seurat_v5/vignette_data/merged_covid_object.rds\") object <- NormalizeData(object, verbose = FALSE) Mapping anchor Using the same code from the v4 reference mapping vignette , we find anchors between the reference and query in the precomputed supervised PCA. We recommend the use of supervised PCA for CITE-seq reference datasets, and demonstrate how to compute this transformation in v4 reference mapping vignette . In Seurat v5, we only need to call FindTransferAnchors and MapQuery once to map all three datasets as they are all contained within the query object. Furthermore, utilizing the on-disk capabilities of BPCells , we map 1.5 million cells without ever loading them all into memory. sourceCode R anchor <- FindTransferAnchors( reference = reference, query = object, reference.reduction = \"spca\", normalization.method = \"SCT\", dims = 1:50 ) object <- MapQuery( anchorset = anchor, query = object, reference = reference, refdata = list( celltype.l1 = \"celltype.l1\", celltype.l2 = \"celltype.l2\" ), reduction.model = \"wnn.umap\" ) Explore the mapping results anchor Next, we visualize all cells from the three studies which have been projected into a UMAP-space defined by the reference. Each cell is annotated at two levels of granularity ( predicted.celltype.l1 and predicted.celltype.l2 ). We can compare the differing ontologies used in the original annotations ( cell_type ) to the now harmonized annotations ( predicted.celltype.l2 , for example) that were predicted from reference-mapping. Previously, the lack of standardization prevented us from directly performing integrative analysis across studies, but now we can easily compare. sourceCode R DimPlot(object, reduction = \"ref.umap\", group.by = \"cell_type\", alpha = 0.1, label = TRUE, split.by = \"publication\", ncol = 3, label.size = 3) + NoLegend() sourceCode R DimPlot(object, reduction = \"ref.umap\", group.by = \"predicted.celltype.l2\", alpha = 0.1, label = TRUE, split.by = \"publication\", ncol = 3, label.size = 3) + NoLegend() Differential composition analysis anchor We utilize our harmonized annotations to identify differences in the proportion of different cell types between healthy individuals and COVID-19 patients. For example, we noticed a reduction in MAIT cells as well as an increase in plasmablasts among COVID-19 patients. ```sourceCode R df_comp <- as.data.frame.matrix(table(object$donor_id, object$predicted.celltype.l2)) select.donors <- rownames(df_comp)[rowSums(df_comp) > 50] df_comp <- df_comp[select.donors, ] df_comp_relative <- sweep(x = df_comp, MARGIN = 1, STATS = rowSums(df_comp), FUN = \"/\") df_disease <- as.data.frame.matrix(table(object$donor_id, object$disease))[select.donors, ] df_comp_relative$disease <- \"other\" df_comp_relative$disease[df_disease$normal != 0] <- \"normal\" df_comp_relative$disease[df_disease$ COVID-19 != 0] <- \"COVID-19\" df_comp_relative$disease <- factor(df_comp_relative$disease, levels = c(\"normal\", \"COVID-19\", \"other\")) df_comp_relative <- df_comp_relative[df_comp_relative$disease %in% c(\"normal\", \"COVID-19\"), ] ``` ```sourceCode R p1 <- ggplot(data = df_comp_relative, mapping = aes(x = disease, y = MAIT, fill = disease)) + geom_boxplot(outlier.shape = NA) + scale_fill_manual(values = c(\"#377eb8\", \"#e41a1c\")) + xlab(\"\") + ylab(\"relative abundance\") + ggtitle(\"MAIT\") + geom_jitter(color = \"black\", size = 0.4, alpha = 0.9) + theme_bw() + theme( axis.title = element_text(size = 12), axis.text = element_text(size = 12), plot.title = element_text(size = 15, hjust = 0.5, face = \"bold\") ) p2 <- ggplot(data = df_comp_relative, mapping = aes(x = disease, y = Plasmablast, fill = disease)) + geom_boxplot(outlier.shape = NA) + scale_fill_manual(values = c(\"#377eb8\", \"#e41a1c\")) + xlab(\"\") + ylab(\"relative abundance\") + ggtitle(\"Plasmablast\") + geom_jitter(color = \"black\", size = 0.4, alpha = 0.9) + theme_bw() + theme( axis.title = element_text(size = 12), axis.text = element_text(size = 12), plot.title = element_text(size = 15, hjust = 0.5, face = \"bold\") ) p1 + p2 + plot_layout(ncol = 2) ``` Differential expression analysis anchor In addition to composition analysis, we use an aggregation-based (pseudobulk) workflow to explore differential genes between healthy individuals and COVID-19 donors. We aggregate all cells within the same cell type and donor using the AggregateExpression function. This returns a Seurat object where each ‘cell’ represents the pseudobulk profile of one cell type in one individual. sourceCode R bulk <- AggregateExpression(object, return.seurat = TRUE, assays = \"RNA\", group.by = c(\"predicted.celltype.l2\", \"donor_id\", \"disease\") ) sourceCode R bulk <- subset(bulk, subset = disease %in% c(\"normal\", \"COVID-19\")) bulk <- subset(bulk, subset = predicted.celltype.l2 != \"Doublet\") bulk$disease <- factor(bulk$disease, levels = c(\"normal\", \"COVID-19\")) Once a pseudobulk object is created, we can perform cell type-specific differential expression analysis between healthy individuals and COVID-19 donors. Here, we only visualize certain interferon-stimulated genes which are often upregulated during viral infection. sourceCode R p1 <- VlnPlot( object = bulk, features = \"IFI6\", group.by = \"predicted.celltype.l2\", split.by = \"disease\", cols = c(\"#377eb8\", \"#e41a1c\") ) p2 <- VlnPlot( object = bulk, features = c(\"ISG15\"), group.by = \"predicted.celltype.l2\", split.by = \"disease\", cols = c(\"#377eb8\", \"#e41a1c\") ) p3 <- VlnPlot( object = bulk, features = c(\"IFIT5\"), group.by = \"predicted.celltype.l2\", split.by = \"disease\", cols = c(\"#377eb8\", \"#e41a1c\") ) p1 + p2 + p3 + plot_layout(ncol = 1) Session Info sourceCode R sessionInfo() ``` R version 4.2.2 Patched (2022-11-10 r83330) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.6 LTS Matrix products: default BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats graphics grDevices utils datasets methods base other attached packages: [1] ggplot2_3.4.4 patchwork_1.1.3 dplyr_1.1.3 BPCells_0.1.0 [5] Seurat_5.0.1 testthat_3.2.0 SeuratObject_5.0.1 sp_2.1-1 loaded via a namespace (and not attached): [1] utf8_1.2.4 spatstat.explore_3.2-5 reticulate_1.34.0 [4] R.utils_2.12.2 tidyselect_1.2.0 htmlwidgets_1.6.2 [7] grid_4.2.2 Rtsne_0.16 devtools_2.4.5 [10] munsell_0.5.0 codetools_0.2-19 ragg_1.2.5 [13] ica_1.0-3 future_1.33.0 miniUI_0.1.1.1 [16] withr_2.5.2 spatstat.random_3.2-1 colorspace_2.1-0 [19] progressr_0.14.0 highr_0.10 knitr_1.45 [22] rstudioapi_0.14 stats4_4.2.2 ROCR_1.0-11 [25] tensor_1.5 listenv_0.9.0 labeling_0.4.3 [28] GenomeInfoDbData_1.2.9 polyclip_1.10-6 farver_2.1.1 [31] rprojroot_2.0.4 parallelly_1.36.0 vctrs_0.6.4 [34] generics_0.1.3 xfun_0.40 R6_2.5.1 [37] GenomeInfoDb_1.34.9 ggbeeswarm_0.7.1 bitops_1.0-7 [40] spatstat.utils_3.0-4 cachem_1.0.8 promises_1.2.1 [43] scales_1.2.1 beeswarm_0.4.0 gtable_0.3.4 [46] globals_0.16.2 processx_3.8.2 goftest_1.2-3 [49] spam_2.10-0 rlang_1.1.1 systemfonts_1.0.4 [52] splines_4.2.2 lazyeval_0.2.2 spatstat.geom_3.2-7 [55] yaml_2.3.7 reshape2_1.4.4 abind_1.4-5 [58] httpuv_1.6.12 tools_4.2.2 usethis_2.1.6 [61] ellipsis_0.3.2 jquerylib_0.1.4 RColorBrewer_1.1-3 [64] BiocGenerics_0.44.0 sessioninfo_1.2.2 ggridges_0.5.4 [67] Rcpp_1.0.11 plyr_1.8.9 zlibbioc_1.44.0 [70] purrr_1.0.2 RCurl_1.98-1.12 ps_1.7.5 [73] prettyunits_1.2.0 deldir_1.0-9 pbapply_1.7-2 [76] cowplot_1.1.1 urlchecker_1.0.1 S4Vectors_0.36.2 [79] zoo_1.8-12 ggrepel_0.9.4 cluster_2.1.4 [82] fs_1.6.3 magrittr_2.0.3 data.table_1.14.8 [85] RSpectra_0.16-1 scattermore_1.2 lmtest_0.9-40 [88] RANN_2.6.1 fitdistrplus_1.1-11 R.cache_0.16.0 [91] matrixStats_1.0.0 pkgload_1.3.3 mime_0.12 [94] evaluate_0.22 xtable_1.8-4 fastDummies_1.7.3 [97] IRanges_2.32.0 gridExtra_2.3 compiler_4.2.2 [100] tibble_3.2.1 KernSmooth_2.23-22 crayon_1.5.2 [103] R.oo_1.25.0 htmltools_0.5.6.1 later_1.3.1 [106] tidyr_1.3.0 MASS_7.3-58.2 Matrix_1.6-1.1 [109] brio_1.1.3 cli_3.6.1 R.methodsS3_1.8.2 [112] parallel_4.2.2 dotCall64_1.1-0 igraph_1.5.1 [115] GenomicRanges_1.50.2 pkgconfig_2.0.3 pkgdown_2.0.7 [118] plotly_4.10.3 spatstat.sparse_3.0-3 vipor_0.4.5 [121] bslib_0.5.1 XVector_0.38.0 stringr_1.5.0 [124] callr_3.7.3 digest_0.6.33 sctransform_0.4.1 [127] RcppAnnoy_0.0.21 spatstat.data_3.0-3 rmarkdown_2.25 [130] leiden_0.4.3 uwot_0.1.16 shiny_1.7.5.1 [133] lifecycle_1.0.4 nlme_3.1-162 jsonlite_1.8.7 [136] desc_1.4.2 viridisLite_0.4.2 fansi_1.0.5 [139] pillar_1.9.0 lattice_0.21-9 ggrastr_1.0.1 [142] fastmap_1.1.1 httr_1.4.7 pkgbuild_1.4.2 [145] survival_3.5-7 glue_1.6.2 remotes_2.4.2.1 [148] png_0.1-8 stringi_1.7.12 sass_0.4.7 [151] profvis_0.3.7 textshaping_0.3.6 RcppHNSW_0.5.0 [154] memoise_2.0.1 styler_1.10.2 irlba_2.3.5.1 [157] future.apply_1.11.0 ```",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/covid_sctmapping",
      "title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat • Seurat",
      "ogTitle": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "language": "en",
      "og:title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "scrapeId": "17a6aceb-bd85-45a5-9455-8080a68b1d85",
      "viewport": "width=device-width, initial-scale=1.0",
      "sourceURL": "https://satijalab.org/seurat/articles/covid_sctmapping",
      "statusCode": 200,
      "ogDescription": "Seurat",
      "og:description": "Seurat"
    }
  },
  {
    "processed_text": "",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/seurat5_future_vignette.html",
      "error": "Not Found",
      "scrapeId": "1539a596-7143-4270-afa8-1db7772b4aaf",
      "sourceURL": "https://satijalab.org/seurat/articles/seurat5_future_vignette.html",
      "statusCode": 404
    }
  },
  {
    "processed_text": "Documentation Archive Source: vignettes/seurat5_archive.Rmd seurat5_archive.Rmd In version 4, the Seurat documentation was transitioned to pkgdown. Here we provide access to all previous versions of the documentation. Version 2-3 tutorials anchor PBMC scATAC-seq Vignette anchor v3.2 v3.1 v3.0 Cell-Cycle Scoring and Regression anchor v3.2 v3.1 v3.0 v2.4 Interoperability between single-cell object formats anchor v3.2 v3.1 v3.0 v2.4 Differential expression testing anchor v3.2 v3.1 v3.0 v2.4 Seurat - Dimensional Reduction Vignette anchor v3.2 v3.1 v3.0 v2.4 Parallelization in Seurat with future anchor v3.2 v3.1 v3.0 Demultiplexing with hashtag oligos (HTOs) anchor v3.2 v3.1 v3.0 v2.4 Tutorial: Integrating stimulated vs. control PBMC datasets to learn cell- type specific responses anchor v3.2 v3.1 v3.0 v2.4 Integration and Label Transfer anchor v3.2 v3.1 v3.0 Seurat - Interaction Tips anchor v3.2 v3.1 v3.0 v2.4 Guided Clustering of the Microwell-seq Mouse Cell Atlas anchor v3.2 v3.1 v3.0 v2.4 Mixscape Vignette anchor v3.2 v3.1 Using Seurat with multi-modal data anchor v3.2 v3.1 v3.0 v2.4 Guided tutorial — 2,700 PBMCs anchor v3.2 v3.1 v3.0 v2.4 v1.4 Using sctransform in Seurat anchor v3.2 v3.1 v3.0 Analysis, visualization, and integration of spatial datasets with Seurat anchor v3.2 New data visualization methods in v3.0 anchor v3.2 v3.1 v3.0 v2.4 Version 1.3-1.4 tutorials anchor For versions 1.3-1.4, we provide access to the old documentation pages here Version <=1.2 tutorials anchor For versions <=1.2, we provide access to the old documentation pages here",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/seurat5_archive",
      "title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat • Seurat",
      "ogTitle": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "language": "en",
      "og:title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "scrapeId": "18636dd1-83a1-4eee-b61d-1bc756dd0d0a",
      "viewport": "width=device-width, initial-scale=1.0",
      "sourceURL": "https://satijalab.org/seurat/articles/seurat5_archive",
      "statusCode": 200,
      "ogDescription": "Seurat",
      "og:description": "Seurat"
    }
  },
  {
    "processed_text": "Using BPCells with Seurat Objects Compiled: October 20, 2023 Source: vignettes/v5/seurat5_bpcells_interaction_vignette.Rmd seurat5_bpcells_interaction_vignette.Rmd BPCells is an R package that allows for computationally efficient single-cell analysis. It utilizes bit-packing compression to store counts matrices on disk and C++ code to cache operations. We leverage the high performance capabilities of BPCells to work with Seurat objects in memory while accessing the counts on disk. In this vignette, we show how to use BPCells to load data, work with a Seurat objects in a more memory-efficient way, and write out Seurat objects with BPCells matrices. We will show the methods for interacting with both a single dataset in one file or multiple datasets across multiple files using BPCells. BPCells allows us to easily analyze these large datasets in memory, and we encourage users to check out some of our other vignettes here and here to see further applications. ``` library(BPCells) library(Seurat) library(SeuratObject) library(SeuratDisk) library(Azimuth) ``` We use BPCells functionality to both load in our data and write the counts layers to bitpacked compressed binary files on disk to improve computation speeds. BPCells has multiple functions for reading in files. Load Data anchor Load Data from one h5 file anchor In this section, we will load a dataset of mouse brain cells freely available from 10x Genomics. This includes 1.3 Million single cells that were sequenced on the Illumina NovaSeq 6000. The raw data can be found here . To read in the file, we will use open_matrix_10x_hdf5, a BPCells function written to read in feature matrices from 10x. We then write a matrix directory, load the matrix, and create a Seurat object. ```sourceCode R brain.data <- open_matrix_10x_hdf5( path = \"/brahms/hartmana/vignette_data/1M_neurons_filtered_gene_bc_matrices_h5.h5\" ) Write the matrix to a directory write_matrix_dir( mat = brain.data, dir = '/brahms/hartmana/vignette_data/bpcells/brain_counts') Now that we have the matrix on disk, we can load it brain.mat <- open_matrix_dir(dir = \"/brahms/hartmana/vignette_data/bpcells/brain_counts\") brain.mat <- Azimuth:::ConvertEnsembleToSymbol(mat = brain.mat, species = \"mouse\") Create Seurat Object brain <- CreateSeuratObject(counts = brain.mat) ``` What if I already have a Seurat Object? You can use BPCells to convert the matrices in your already created Seurat objects to on-disk matrices. Note, that this is only possible for V5 assays. As an example, if you’d like to convert the counts matrix of your RNA assay to a BPCells matrix, you can use the following: ```sourceCode R obj <- readRDS(\"/path/to/reference.rds\") # Write the counts layer to a directory write_matrix_dir(mat = obj[[\"RNA\"]]$counts, dir = '/brahms/hartmana/vignette_data/bpcells/brain_counts') counts.mat <- open_matrix_dir(dir = \"/brahms/hartmana/vignette_data/bpcells/brain_counts\") obj[[\"RNA\"]]$counts <- counts.mat ``` Example Analsyis anchor Once this conversion is done, you can perform typical Seurat functions on the object. For example, we can normalize data and visualize features by automatically accessing the on-disk counts. sourceCode R VlnPlot(brain, features = c(\"Sox10\", \"Slc17a7\", \"Aif1\"), ncol = 3, layer = \"counts\", alpha = 0.1) ```sourceCode R We then normalize and visualize again brain <- NormalizeData(brain, normalization.method = \"LogNormalize\") VlnPlot(brain, features = c(\"Sox10\", \"Slc17a7\", \"Aif1\"), ncol = 3, layer = \"data\", alpha = 0.1) ``` Saving Seurat objects with on-disk layers anchor If you save your object and load it in in the future, Seurat will access the on-disk matrices by their path, which is stored in the assay level data. saveRDS() can still be used to save your Seurat objects with on-disk matrices as shown below. Note, if you move the object across computers or to a place that no longer has access to the paths where the on-disk matrices are stored, you will have to move the folders that contain the on-disk matrices as well. We are actively working on functionality to make this process easier for users. sourceCode R saveRDS( object = brain, file = \"obj.Rds\" ) If needed, a layer with an on-disk matrix can be converted to an in-memory matrix using the as() function. For the purposes of this demo, we’ll subset the object so that it takes up less space in memory. sourceCode R brain <- subset(brain, downsample = 1000) brain[[\"RNA\"]]$counts <- as(object = brain[[\"RNA\"]]$counts, Class = \"dgCMatrix\") Load data from multiple h5ad files anchor You can also download data from multiple matrices. In this section, we create a Seurat object using multiple peripheral blood mononuclear cell (PBMC) samples that are freely available for download from CZI here . We download data from Ahern et al. (2022) Nature , Jin et al. (2021) Science , and Yoshida et al. (2022) Nature . We use the BPCells function to read h5ad files. ```sourceCode R file.dir <- \"/brahms/hartmana/vignette_data/h5ad_files/\" files.set <- c(\"ahern_pbmc.h5ad\", \"jin_pbmc.h5ad\", \"yoshida_pbmc.h5ad\") Loop through h5ad files and output BPCells matrices on-disk data.list <- c() metadata.list <- c() for (i in 1:length(files.set)) { path <- paste0(file.dir, files.set[i]) data <- open_matrix_anndata_hdf5(path) write_matrix_dir( mat = data, dir = paste0(gsub(\".h5ad\", \"\", path), \"_BP\") ) # Load in BP matrices mat <- open_matrix_dir(dir = paste0(gsub(\".h5ad\", \"\", path), \"_BP\")) mat <- Azimuth:::ConvertEnsembleToSymbol(mat = mat, species = \"human\") # Get metadata metadata.list[[i]] <- LoadH5ADobs(path = path) data.list[[i]] <- mat } Name layers names(data.list) <- c(\"ahern\", \"jin\", \"yoshida\") Add Metadata for (i in 1:length(metadata.list)) { metadata.list[[i]]$publication <- names(data.list)[i] } metadata.list <- lapply(metadata.list, function(x) { x <- x[, c(\"publication\", \"sex\", \"cell_type\", \"donor_id\", \"disease\")] return(x) }) metadata <- Reduce(rbind, metadata.list) ``` When we create the Seurat object with the list of matrices from each publication, we can then see that multiple counts layers exist that represent each dataset. This object contains over a million cells, yet only takes up minimal space in memory! merged.object <- CreateSeuratObject(counts = data.list, meta.data = metadata) merged.object ``` An object of class Seurat 26143 features across 1498064 samples within 1 assay Active assay: RNA (26143 features, 0 variable features) 3 layers present: counts.ahern, counts.jin, counts.yoshida ``` sourceCode R saveRDS( object = merged.object, file = \"obj.Rds\" ) Parse Biosciences anchor Here, we show how to load a 1 million cell data set from Parse Biosciences and create a Seurat Object. The data is available for download here sourceCode R parse.data <- open_matrix_anndata_hdf5( \"/brahms/hartmana/vignette_data/h5ad_files/ParseBio_PBMC.h5ad\" ) sourceCode R write_matrix_dir(mat = parse.data, dir = \"/brahms/hartmana/vignette_data/bpcells/parse_1m_pbmc\") sourceCode R parse.mat <- open_matrix_dir(dir = \"/brahms/hartmana/vignette_data/bpcells/parse_1m_pbmc\") metadata <- readRDS(\"/brahms/hartmana/vignette_data/ParseBio_PBMC_meta.rds\") metadata$disease <- sapply(strsplit(x = metadata$sample, split = \"_\"), \"[\", 1)\\ parse.object <- CreateSeuratObject(counts = parse.mat, meta.data = metadata)\\ \\ \\ sourceCode R\\ saveRDS(\\ object = parse.object,\\ file = \"obj.Rds\"\\ )\\ \\ \\ Session Info \\ \\ sourceCode R\\ sessionInfo()\\ \\ \\ \\ ## R version 4.2.2 Patched (2022-11-10 r83330)\\ ## Platform: x86_64-pc-linux-gnu (64-bit)\\ ## Running under: Ubuntu 20.04.6 LTS\\ ##\\ ## Matrix products: default\\ ## BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0\\ ## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\\ ##\\ ## locale:\\ ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C\\ ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8\\ ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8\\ ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C\\ ## [9] LC_ADDRESS=C LC_TELEPHONE=C\\ ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C\\ ##\\ ## attached base packages:\\ ## [1] stats graphics grDevices utils datasets methods base\\ ##\\ ## other attached packages:\\ ## [1] dplyr_1.1.3 biomaRt_2.54.1 Azimuth_0.4.6.9004\\ ## [4] shinyBS_0.61.1 SeuratDisk_0.0.0.9020 Seurat_4.9.9.9085\\ ## [7] SeuratObject_4.9.9.9092 sp_2.1-1 BPCells_0.1.0\\ ##\\ ## loaded via a namespace (and not attached):\\ ## [1] rappdirs_0.3.3 rtracklayer_1.58.0\\ ## [3] scattermore_1.2 R.methodsS3_1.8.2\\ ## [5] ragg_1.2.5 tidyr_1.3.0\\ ## [7] JASPAR2020_0.99.10 ggplot2_3.4.4\\ ## [9] bit64_4.0.5 knitr_1.44\\ ## [11] irlba_2.3.5.1 DelayedArray_0.24.0\\ ## [13] R.utils_2.12.2 styler_1.10.2\\ ## [15] data.table_1.14.8 KEGGREST_1.38.0\\ ## [17] TFBSTools_1.36.0 RCurl_1.98-1.12\\ ## [19] AnnotationFilter_1.22.0 generics_0.1.3\\ ## [21] BiocGenerics_0.44.0 GenomicFeatures_1.50.4\\ ## [23] cowplot_1.1.1 RSQLite_2.3.1\\ ## [25] RANN_2.6.1 future_1.33.0\\ ## [27] bit_4.0.5 tzdb_0.4.0\\ ## [29] spatstat.data_3.0-1 xml2_1.3.5\\ ## [31] httpuv_1.6.11 SummarizedExperiment_1.28.0\\ ## [33] DirichletMultinomial_1.40.0 gargle_1.5.2\\ ## [35] xfun_0.40 hms_1.1.3\\ ## [37] jquerylib_0.1.4 evaluate_0.22\\ ## [39] promises_1.2.1 fansi_1.0.5\\ ## [41] restfulr_0.0.15 progress_1.2.2\\ ## [43] caTools_1.18.2 dbplyr_2.3.4\\ ## [45] igraph_1.5.1 DBI_1.1.3\\ ## [47] htmlwidgets_1.6.2 spatstat.geom_3.2-5\\ ## [49] googledrive_2.1.1 stats4_4.2.2\\ ## [51] purrr_1.0.2 ellipsis_0.3.2\\ ## [53] RSpectra_0.16-1 annotate_1.76.0\\ ## [55] deldir_1.0-9 MatrixGenerics_1.10.0\\ ## [57] vctrs_0.6.4 Biobase_2.58.0\\ ## [59] Cairo_1.6-0 ensembldb_2.22.0\\ ## [61] ROCR_1.0-11 abind_1.4-5\\ ## [63] cachem_1.0.8 withr_2.5.1\\ ## [65] BSgenome.Hsapiens.UCSC.hg38_1.4.5 BSgenome_1.66.3\\ ## [67] progressr_0.14.0 presto_1.0.0\\ ## [69] sctransform_0.4.1 GenomicAlignments_1.34.1\\ ## [71] prettyunits_1.1.1 goftest_1.2-3\\ ## [73] cluster_2.1.4 dotCall64_1.1-0\\ ## [75] lazyeval_0.2.2 seqLogo_1.64.0\\ ## [77] crayon_1.5.2 hdf5r_1.3.8\\ ## [79] spatstat.explore_3.2-3 labeling_0.4.3\\ ## [81] pkgconfig_2.0.3 GenomeInfoDb_1.34.9\\ ## [83] vipor_0.4.5 nlme_3.1-162\\ ## [85] ProtGenerics_1.30.0 rlang_1.1.1\\ ## [87] globals_0.16.2 lifecycle_1.0.3\\ ## [89] miniUI_0.1.1.1 filelock_1.0.2\\ ## [91] fastDummies_1.7.3 BiocFileCache_2.6.1\\ ## [93] SeuratData_0.2.2.9001 ggrastr_1.0.1\\ ## [95] cellranger_1.1.0 rprojroot_2.0.3\\ ## [97] polyclip_1.10-6 RcppHNSW_0.5.0\\ ## [99] matrixStats_1.0.0 lmtest_0.9-40\\ ## [101] Matrix_1.6-1.1 Rhdf5lib_1.20.0\\ ## [103] zoo_1.8-12 beeswarm_0.4.0\\ ## [105] googlesheets4_1.1.1 ggridges_0.5.4\\ ## [107] png_0.1-8 viridisLite_0.4.2\\ ## [109] rjson_0.2.21 shinydashboard_0.7.2\\ ## [111] bitops_1.0-7 R.oo_1.25.0\\ ## [113] rhdf5filters_1.10.1 KernSmooth_2.23-22\\ ## [115] spam_2.9-1 Biostrings_2.66.0\\ ## [117] blob_1.2.4 stringr_1.5.0\\ ## [119] parallelly_1.36.0 spatstat.random_3.1-6\\ ## [121] R.cache_0.16.0 readr_2.1.4\\ ## [123] S4Vectors_0.36.2 CNEr_1.34.0\\ ## [125] scales_1.2.1 memoise_2.0.1\\ ## [127] magrittr_2.0.3 plyr_1.8.9\\ ## [129] ica_1.0-3 zlibbioc_1.44.0\\ ## [131] compiler_4.2.2 BiocIO_1.8.0\\ ## [133] RColorBrewer_1.1-3 fitdistrplus_1.1-11\\ ## [135] Rsamtools_2.14.0 cli_3.6.1\\ ## [137] XVector_0.38.0 listenv_0.9.0\\ ## [139] patchwork_1.1.3 pbapply_1.7-2\\ ## [141] MASS_7.3-58.2 tidyselect_1.2.0\\ ## [143] stringi_1.7.12 textshaping_0.3.6\\ ## [145] yaml_2.3.7 ggrepel_0.9.4\\ ## [147] grid_4.2.2 sass_0.4.7\\ ## [149] fastmatch_1.1-4 EnsDb.Hsapiens.v86_2.99.0\\ ## [151] tools_4.2.2 future.apply_1.11.0\\ ## [153] parallel_4.2.2 rstudioapi_0.14\\ ## [155] TFMPvalue_0.0.9 gridExtra_2.3\\ ## [157] farver_2.1.1 Rtsne_0.16\\ ## [159] digest_0.6.33 pracma_2.4.2\\ ## [161] shiny_1.7.5.1 Rcpp_1.0.11\\ ## [163] GenomicRanges_1.50.2 later_1.3.1\\ ## [165] RcppAnnoy_0.0.21 httr_1.4.7\\ ## [167] AnnotationDbi_1.60.2 colorspace_2.1-0\\ ## [169] XML_3.99-0.14 fs_1.6.3\\ ## [171] tensor_1.5 reticulate_1.34.0\\ ## [173] IRanges_2.32.0 splines_4.2.2\\ ## [175] uwot_0.1.16 RcppRoll_0.3.0\\ ## [177] spatstat.utils_3.0-3 pkgdown_2.0.7\\ ## [179] plotly_4.10.2 systemfonts_1.0.4\\ ## [181] xtable_1.8-4 jsonlite_1.8.7\\ ## [183] poweRlaw_0.70.6 R6_2.5.1\\ ## [185] pillar_1.9.0 htmltools_0.5.6.1\\ ## [187] mime_0.12 glue_1.6.2\\ ## [189] fastmap_1.1.1 DT_0.30\\ ## [191] BiocParallel_1.32.6 codetools_0.2-19\\ ## [193] Signac_1.12.9000 utf8_1.2.3\\ ## [195] lattice_0.21-9 bslib_0.5.1\\ ## [197] spatstat.sparse_3.0-2 tibble_3.2.1\\ ## [199] ggbeeswarm_0.7.1 curl_5.1.0\\ ## [201] leiden_0.4.3 gtools_3.9.4\\ ## [203] shinyjs_2.1.0 GO.db_3.16.0\\ ## [205] survival_3.5-7 rmarkdown_2.25\\ ## [207] desc_1.4.2 munsell_0.5.0\\ ## [209] rhdf5_2.42.1 GenomeInfoDbData_1.2.9\\ ## [211] reshape2_1.4.4 gtable_0.3.4\\",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/seurat5_bpcells_interaction_vignette",
      "title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat • Seurat",
      "ogTitle": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "language": "en",
      "og:title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "scrapeId": "24c05062-5064-4c3b-81d5-b446929b25c3",
      "viewport": "width=device-width, initial-scale=1.0",
      "sourceURL": "https://satijalab.org/seurat/articles/seurat5_bpcells_interaction_vignette",
      "statusCode": 200,
      "ogDescription": "Seurat",
      "og:description": "Seurat"
    }
  },
  {
    "processed_text": "Seurat Command List Compiled: 2023-10-31 Source: vignettes/essential_commands.Rmd essential_commands.Rmd Standard Seurat workflow anchor sourceCode R pbmc <- NormalizeData(object = pbmc) pbmc <- FindVariableFeatures(object = pbmc) pbmc <- ScaleData(object = pbmc) pbmc <- RunPCA(object = pbmc) pbmc <- FindNeighbors(object = pbmc, dims = 1:30) pbmc <- FindClusters(object = pbmc) pbmc <- RunUMAP(object = pbmc, dims = 1:30) DimPlot(object = pbmc, reduction = \"umap\") SCtransform version anchor sourceCode R pbmc <- SCTransform(object = pbmc) pbmc <- RunPCA(object = pbmc) pbmc <- FindNeighbors(object = pbmc, dims = 1:30) pbmc <- FindClusters(object = pbmc) pbmc <- RunUMAP(object = pbmc, dims = 1:30) DimPlot(object = pbmc, reduction = \"umap\") ```sourceCode R note that you can chain multiple commands together with %>% pbmc <- SCTransform(pbmc) %>% RunPCA() %>% FindNeighbors(dims = 1:30) %>% FindClusters() %>% RunUMAP(dims = 1:30) ``` Seurat Object Data Access anchor Cell, feature, and layer names anchor ```sourceCode R Get cell and feature names, and total numbers We show multiple ways to get the same output cell names colnames(pbmc) Cells(pbmc) feature names Features(pbmc) rownames(pbmc) number of cells/features num_cells <- ncol(pbmc) num_features <- nrow(pbmc) List of object layers Layers(pbmc) working with multimodal objects list assays Assays(cbmc) Assay-specific features (genes/ADT) Features(cbmc[[\"RNA\"]]) Features(cbmc[[\"ADT\"]]) Variable feature names VariableFeatures(pbmc) ``` ```sourceCode R Set variable features VariableFeatures(cbmc) <- var.gene.names set for a specific assay VariableFeatures(cbmc[[\"ADT\"]]) <- var.gene.names ``` Identity class labels anchor ```sourceCode R Setting and retrieving cell identities Set identity classes to an existing column in meta data Idents(object = pbmc) <- \"seurat_annotations\" View cell identities, get summary table Idents(pbmc) table(Idents(pbmc)) Set identity to CD4 T cells for all cells Idents(pbmc) <- \"CD4 T cells\" Set for a selected group of cells pbmc.cells <- Cells(pbmc) Idents(object = pbmc, cells = pbmc.cells[1:10]) <- \"CD4 T cells\" Get cell identity classes Idents(object = pbmc) levels(x = pbmc) Stash cell identity classes in metadata pbmc[[\"old.ident\"]] <- Idents(object = pbmc) pbmc <- StashIdent(object = pbmc, save.name = \"old.ident\") Rename identity classes pbmc <- RenameIdents(object = pbmc, CD4 T cells = \"T Helper cells\") ``` Cell metadata anchor ```sourceCode R View metadata data frame, stored in object@meta.data pbmc[[]] Retrieve specific values from the metadata pbmc$nCount_RNA pbmc[[c(\"percent.mito\", \"nFeature_RNA\")]] Add metadata, see ?AddMetaData random_group_labels <- sample(x = c(\"g1\", \"g2\"), size = ncol(x = pbmc), replace = TRUE) pbmc$groups <- random_group_labels ``` Expression data (stored as layers in Seurat v5) anchor ```sourceCode R Retrieve data in an expression matrix RNA counts matrix pbmc[[\"RNA\"]]$counts Alternate accessor function with the same result LayerData(pbmc, assay = \"RNA\", layer = \"counts\") GetAssayData from Seurat v4 is still supported GetAssayData(object = pbmc, assay = \"RNA\", slot = \"counts\") ADT counts matrix (multimodal object) cbmc[[\"ADT\"]]$counts ``` ```sourceCode R Set expression data assume new.data is a new expression matrix pbmc[[\"RNA\"]]$counts <- new.data Alternate setter function with the same result LayerData(pbmc, assay = \"RNA\", layer = \"counts\") <- new.data SetAssayData from Seurat v4 is still supported pbmc <- SetAssayData(object = pbmc, slot = \"counts\", new.data = new.data) ``` Dimensional reductions anchor ```sourceCode R Get cell embeddings and feature loadings stored on pbmc[['pca']]@cell.embeddings Embeddings(pbmc, reduction = \"pca\") stored in pbmc[['pca]]@feature.loadings Loadings(pbmc, reduction = \"pca\") ``` ```sourceCode R Create custom dimensional reduction loadings matrix is optional new_reduction <- CreateDimReducObject(embeddings = new.embeddings, loadings = new.loadings, key = \"custom_pca\") pbmc[[\"custom_pca\"]] <- new_reduction ``` FetchData anchor ```sourceCode R FetchData can access anything from expression matrices, cell embeddings, or metadata Use the previously listed commands to access entire matrices Use FetchData to access individual/small groups of variables FetchData(object = pbmc, vars = c(\"PC_1\", \"nFeature_RNA\", \"MS4A1\"), layer = \"counts\") ``` Subsetting and merging anchor Subset Seurat objects anchor ```sourceCode R Subset Seurat object based on identity class, also see ?SubsetData subset(x = pbmc, idents = \"B\") subset(x = pbmc, idents = c(\"Naive CD4 T\", \"CD8 T\"), invert = TRUE) Subset on the expression level of a gene/feature subset(x = pbmc, subset = MS4A1 > 2.5) Subset on a combination of criteria subset(x = pbmc, subset = MS4A1 > 2.5 & PC_1 > 5) subset(x = pbmc, subset = MS4A1 > 2.5, idents = \"B\") Subset on a value in the object meta data subset(x = pbmc, subset = groups == \"g1\") Downsample the number of cells per identity class subset(x = pbmc, downsample = 100) ``` Split layers anchor ```sourceCode R In Seurat v5, users can now split in object directly into different layers keeps expression data in one object, but splits multiple samples into layers can proceed directly to integration workflow after splitting layers ifnb[[\"RNA\"]] <- split(ifnb[[\"RNA\"]], f = ifnb$stim) Layers(ifnb) If desired, for example after intergation, the layers can be joined together again ifnb <- JoinLayers(ifnb) ``` Split objects anchor ```sourceCode R In line with prior workflows, you can also into split your object into a list of multiple objects based on a metadata column creates a list of two objects ifnb_list <- SplitObject(ifnb, split.by = \"stim\") ifnb_list$CTRL ifnb_list$STIM ``` Merge objects (without integration) anchor In Seurat v5, merging creates a single object, but keeps the expression information split into different layers for integration. If not proceeding with integration, rejoin the layers after merging. ```sourceCode R Merge two Seurat objects merged_obj <- merge(x = ifnb_list$CTRL, y = ifnb_list$STIM) merged_obj[[\"RNA\"]] <- JoinLayers(merged_obj) Example to merge more than two Seurat objects merge(x = pbmc1, y = list(pbmc2, pbmc3)) ``` Merge objects (with integration) anchor See introduction to integration for more information. ```sourceCode R merged_obj <- merge(x = ifnb_list$CTRL, y = ifnb_list$STIM) merged_obj <- NormalizeData(merged_obj) merged_obj <- FindVariableFeatures(merged_obj) merged_obj <- ScaleData(merged_obj) merged_obj <- RunPCA(merged_obj) merged_obj <- IntegrateLayers(object = obj, method = RPCAIntegration, orig.reduction = \"pca\", new.reduction = \"integrated.rpca\", verbose = FALSE) now that integration is complete, rejoin layers merged_obj[[\"RNA\"]] <- JoinLayers(merged_obj) ``` Pseudobulk analysis anchor Group cells together, based on multiple categories anchor See DE vignette for information on how to add the donor_id column to meta data. ```sourceCode R pseudobulk cells only by cell type bulk <- AggregateExpression(ifnb, group.by = \"seurat_annotations\", return.seurat = TRUE) Cells(bulk) pseudobulk cells by stimulation condition AND cell type bulk <- AggregateExpression(ifnb, group.by = c(\"stim\", \"seurat_annotations\"), return.seurat = TRUE) Cells(bulk) pseudobulk cells by stimulation condition AND cell type AND donor bulk <- AggregateExpression(ifnb, group.by = c(\"stim\", \"seurat_annotations\", \"donor_id\"), return.seurat = TRUE) Cells(bulk) ``` Visualization in Seurat anchor Seurat has a vast, ggplot2-based plotting library. All plotting functions will return a ggplot2 plot by default, allowing easy customization with ggplot2. ```sourceCode R Dimensional reduction plot DimPlot(object = pbmc, reduction = \"pca\") Dimensional reduction plot, with cells colored by a quantitative feature Defaults to UMAP if available FeaturePlot(object = pbmc, features = \"MS4A1\") Scatter plot across single cells FeatureScatter(object = pbmc, feature1 = \"MS4A1\", feature2 = \"PC_1\") FeatureScatter(object = pbmc, feature1 = \"MS4A1\", feature2 = \"CD3D\") Scatter plot across individual features, repleaces CellPlot CellScatter(object = pbmc, cell1 = \"AGTCTACTAGGGTG\", cell2 = \"CACAGATGGTTTCT\") VariableFeaturePlot(object = pbmc) Violin and Ridge plots VlnPlot(object = pbmc, features = c(\"LYZ\", \"CCL5\", \"IL32\")) RidgePlot(object = pbmc, feature = c(\"LYZ\", \"CCL5\", \"IL32\")) ``` ```sourceCode R Heatmaps (visualize scale.data slot) DimHeatmap(object = pbmc, reduction = \"pca\", cells = 200) standard workflow pbmc <- ScaleData(pbmc, features = heatmap_markers) DoHeatmap(object = pbmc, features = heatmap_markers) sctransform workflow pbmc <- GetResidual(pbmc, features = heatmap_markers) DoHeatmap(object = pbmc, features = heatmap_markers) heatmap with maximum of 100 cells per group DoHeatmap(pbmc, heatmap_markers, cells = subset(pbmc, downsample = 100)) ``` ```sourceCode R New things to try! Note that plotting functions now return ggplot2 objects, so you can add themes, titles, and options onto them VlnPlot(object = pbmc, features = \"MS4A1\", split.by = \"groups\") DotPlot(object = pbmc, features = c(\"LYZ\", \"CCL5\", \"IL32\"), split.by = \"groups\") FeaturePlot(object = pbmc, features = c(\"MS4A1\", \"CD79A\"), blend = TRUE) DimPlot(object = pbmc) + DarkTheme() DimPlot(object = pbmc) + labs(title = \"2,700 PBMCs clustered using Seurat and viewed\\non a two-dimensional UMAP\") ``` Seurat provides many prebuilt themes that can be added to ggplot2 plots for quick customization | DarkTheme | Set a black background with white text | | FontSize | Set font sizes for various elements of a plot | | NoAxes | Remove axes and axis text | | NoLegend | Remove all legend elements | | RestoreLegend | Restores a legend after removal | | RotatedAxis | Rotates x-axis labels | ```sourceCode R Plotting helper functions work with ggplot2-based scatter plots, such as DimPlot, FeaturePlot, CellScatter, and FeatureScatter plot <- DimPlot(object = pbmc) + NoLegend() HoverLocator replaces the former do.hover argument It can also show extra data throught the information argument, designed to work smoothly with FetchData HoverLocator(plot = plot, information = FetchData(object = pbmc, vars = c(\"ident\", \"PC_1\", \"nFeature_RNA\"))) FeatureLocator replaces the former do.identify select.cells <- FeatureLocator(plot = plot) Label points on a ggplot object LabelPoints(plot = plot, points = TopCells(object = pbmc[[\"pca\"]]), repel = TRUE) ``` Multi-Assay Features anchor With Seurat, you can easily switch between different assays at the single cell level (such as ADT counts from CITE-seq, or integrated/batch-corrected data). Most functions now take an assay parameter, but you can set a Default Assay to avoid repetitive statements. ```sourceCode R cbmc <- CreateSeuratObject(counts = cbmc.rna) Add ADT data cbmc[[\"ADT\"]] <- CreateAssayObject(counts = cbmc.adt) Run analyses by specifying the assay to use NormalizeData(object = cbmc, assay = \"RNA\") NormalizeData(object = cbmc, assay = \"ADT\", method = \"CLR\") Retrieve and set the default assay DefaultAssay(object = cbmc) DefaultAssay(object = cbmc) <- \"ADT\" DefaultAssay(object = cbmc) Pull feature expression from both assays by using keys FetchData(object = cbmc, vars = c(\"rna_CD3E\", \"adt_CD3\")) Plot data from multiple assays using keys FeatureScatter(object = cbmc, feature1 = \"rna_CD3E\", feature2 = \"adt_CD3\") ``` Additional resources anchor Users who are particularly interested in some of the technical changes to data storage in Seurat v5 can explore the following resources: SeuratObject manual Seurat v5 and Assay5 introductory vignette Session Info sourceCode R sessionInfo()",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/essential_commands",
      "title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat • Seurat",
      "ogTitle": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "language": "en",
      "og:title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "scrapeId": "1d71dd99-6d4f-4641-9dfb-64709a1f2159",
      "viewport": "width=device-width, initial-scale=1.0",
      "sourceURL": "https://satijalab.org/seurat/articles/essential_commands",
      "statusCode": 200,
      "ogDescription": "Seurat",
      "og:description": "Seurat"
    }
  },
  {
    "processed_text": "",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/seurat5_sctransform_v2_vignette.html",
      "error": "Not Found",
      "scrapeId": "368716b6-3ca4-496c-a982-498ba254831d",
      "sourceURL": "https://satijalab.org/seurat/articles/seurat5_sctransform_v2_vignette.html",
      "statusCode": 404
    }
  },
  {
    "processed_text": "Mixscape Vignette Compiled: October 31, 2023 Source: vignettes/mixscape_vignette.Rmd mixscape_vignette.Rmd Overview anchor This tutorial demonstrates how to use mixscape for the analyses of single-cell pooled CRISPR screens. We introduce new Seurat functions for: Calculating the perturbation-specific signature of every cell. Identifying and removing cells that have ‘escaped’ CRISPR perturbation. Visualizing similarities/differences across different perturbations. Loading required packages anchor ```sourceCode R Load packages. library(Seurat) library(SeuratData) library(ggplot2) library(patchwork) library(scales) library(dplyr) library(reshape2) Download dataset using SeuratData. InstallData(ds = \"thp1.eccite\") Setup custom theme for plotting. custom_theme <- theme( plot.title = element_text(size=16, hjust = 0.5), legend.key.size = unit(0.7, \"cm\"), legend.text = element_text(size = 14)) ``` Loading Seurat object containing ECCITE-seq dataset anchor We use a 111 gRNA ECCITE-seq dataset generated from stimulated THP-1 cells that was recently published from our lab in bioRxiv Papalexi et al. 2020 . This dataset can be easily downloaded from the SeuratData package. ```sourceCode R Load object. eccite <- LoadData(ds = \"thp1.eccite\") Normalize protein. eccite <- NormalizeData( object = eccite, assay = \"ADT\", normalization.method = \"CLR\", margin = 2) ``` RNA-based clustering is driven by confounding sources of variation anchor Here, we follow the standard Seurat workflow to cluster cells based on their gene expression profiles. We expected to obtain perturbation-specific clusters however we saw that clustering is primarily driven by cell cycle phase and replicate ID. We only observed one perturbation-specific cluster containing cells expression IFNgamma pathway gRNAs. ```sourceCode R Prepare RNA assay for dimensionality reduction: Normalize data, find variable features and scale data. DefaultAssay(object = eccite) <- 'RNA' eccite <- NormalizeData(object = eccite) %>% FindVariableFeatures() %>% ScaleData() Run Principle Component Analysis (PCA) to reduce the dimensionality of the data. eccite <- RunPCA(object = eccite) Run Uniform Manifold Approximation and Projection (UMAP) to visualize clustering in 2-D. eccite <- RunUMAP(object = eccite, dims = 1:40) Generate plots to check if clustering is driven by biological replicate ID, cell cycle phase or target gene class. p1 <- DimPlot( object = eccite, group.by = 'replicate', label = F, pt.size = 0.2, reduction = \"umap\", cols = \"Dark2\", repel = T) + scale_color_brewer(palette = \"Dark2\") + ggtitle(\"Biological Replicate\") + xlab(\"UMAP 1\") + ylab(\"UMAP 2\") + custom_theme p2 <- DimPlot( object = eccite, group.by = 'Phase', label = F, pt.size = 0.2, reduction = \"umap\", repel = T) + ggtitle(\"Cell Cycle Phase\") + ylab(\"UMAP 2\") + xlab(\"UMAP 1\") + custom_theme p3 <- DimPlot( object = eccite, group.by = 'crispr', pt.size = 0.2, reduction = \"umap\", split.by = \"crispr\", ncol = 1, cols = c(\"grey39\",\"goldenrod3\")) + ggtitle(\"Perturbation Status\") + ylab(\"UMAP 2\") + xlab(\"UMAP 1\") + custom_theme Visualize plots. ((p1 / p2 + plot_layout(guides = 'auto')) | p3 ) ``` Calculating local perturbation signatures mitigates confounding effects anchor To calculate local perturbation signatures we set the number of non-targeting Nearest Neighbors (NNs) equal to k=20 and we recommend that the user picks a k from the following range: 20 < k < 30. Intuitively, the user does not want to set k to a very small or large number as this will most likely not remove the technical variation from the dataset. Using the PRTB signature to cluster cells removes all technical variation and reveals one additional perturbation-specific cluster. ```sourceCode R Calculate perturbation signature (PRTB). eccite<- CalcPerturbSig( object = eccite, assay = \"RNA\", slot = \"data\", gd.class =\"gene\", nt.cell.class = \"NT\", reduction = \"pca\", ndims = 40, num.neighbors = 20, split.by = \"replicate\", new.assay.name = \"PRTB\") Prepare PRTB assay for dimensionality reduction: Normalize data, find variable features and center data. DefaultAssay(object = eccite) <- 'PRTB' Use variable features from RNA assay. VariableFeatures(object = eccite) <- VariableFeatures(object = eccite[[\"RNA\"]]) eccite <- ScaleData(object = eccite, do.scale = F, do.center = T) Run PCA to reduce the dimensionality of the data. eccite <- RunPCA(object = eccite, reduction.key = 'prtbpca', reduction.name = 'prtbpca') Run UMAP to visualize clustering in 2-D. eccite <- RunUMAP( object = eccite, dims = 1:40, reduction = 'prtbpca', reduction.key = 'prtbumap', reduction.name = 'prtbumap') Generate plots to check if clustering is driven by biological replicate ID, cell cycle phase or target gene class. q1 <- DimPlot( object = eccite, group.by = 'replicate', reduction = 'prtbumap', pt.size = 0.2, cols = \"Dark2\", label = F, repel = T) + scale_color_brewer(palette = \"Dark2\") + ggtitle(\"Biological Replicate\") + ylab(\"UMAP 2\") + xlab(\"UMAP 1\") + custom_theme q2 <- DimPlot( object = eccite, group.by = 'Phase', reduction = 'prtbumap', pt.size = 0.2, label = F, repel = T) + ggtitle(\"Cell Cycle Phase\") + ylab(\"UMAP 2\") + xlab(\"UMAP 1\") + custom_theme q3 <- DimPlot( object = eccite, group.by = 'crispr', reduction = 'prtbumap', split.by = \"crispr\", ncol = 1, pt.size = 0.2, cols = c(\"grey39\",\"goldenrod3\")) + ggtitle(\"Perturbation Status\") + ylab(\"UMAP 2\") + xlab(\"UMAP 1\") + custom_theme Visualize plots. (q1 / q2 + plot_layout(guides = 'auto') | q3) ``` Mixscape identifies cells with no detectable perturbation anchor Here, we are assuming each target gene class is a mixture of two Gaussian distributions one representing the knockout (KO) and the other the non-perturbed (NP) cells. We further assume that the distribution of the NP cells is identical to that of cells expressing non-targeting gRNAs (NT) and we try to estimate the distribution of KO cells using the function normalmixEM() from the mixtools package. Next, we calculate the posterior probability that a cell belongs to the KO distribution and classify cells with a probability higher than 0.5 as KOs. Applying this method we identify KOs in 11 target gene classes and detect variation in gRNA targeting efficiency within each class. ```sourceCode R Run mixscape. eccite <- RunMixscape( object = eccite, assay = \"PRTB\", slot = \"scale.data\", labels = \"gene\", nt.class.name = \"NT\", min.de.genes = 5, iter.num = 10, de.assay = \"RNA\", verbose = F, prtb.type = \"KO\") Calculate percentage of KO cells for all target gene classes. df <- prop.table(table(eccite$mixscape_class.global, eccite$NT),2) df2 <- reshape2::melt(df) df2$Var2 <- as.character(df2$Var2) test <- df2[which(df2$Var1 == \"KO\"),] test <- test[order(test$value, decreasing = T),] new.levels <- test$Var2 df2$Var2 <- factor(df2$Var2, levels = new.levels ) df2$Var1 <- factor(df2$Var1, levels = c(\"NT\", \"NP\", \"KO\")) df2$gene <- sapply(as.character(df2$Var2), function(x) strsplit(x, split = \"g\")[[1]][1]) df2$guide_number <- sapply(as.character(df2$Var2), function(x) strsplit(x, split = \"g\")[[1]][2]) df3 <- df2[-c(which(df2$gene == \"NT\")),] p1 <- ggplot(df3, aes(x = guide_number, y = value*100, fill= Var1)) + geom_bar(stat= \"identity\") + theme_classic()+ scale_fill_manual(values = c(\"grey49\", \"grey79\",\"coral1\")) + ylab(\"% of cells\") + xlab(\"sgRNA\") p1 + theme(axis.text.x = element_text(size = 18, hjust = 1), axis.text.y = element_text(size = 18), axis.title = element_text(size = 16), strip.text = element_text(size=16, face = \"bold\")) + facet_wrap(vars(gene),ncol = 5, scales = \"free\") + labs(fill = \"mixscape class\") +theme(legend.title = element_text(size = 14), legend.text = element_text(size = 12)) ``` Inspecting mixscape results anchor To ensure mixscape is assigning the correct perturbation status to cells we can use the functions below to look at the perturbation score distributions and the posterior probabilities of cells within a target gene class (for example IFNGR2) and compare it to those of the NT cells. In addition, we can perform differential expression (DE) analyses and show that only IFNGR2 KO cells have reduced expression of the IFNG-pathway genes. Finally, as an independent check, we can look at the PD-L1 protein expression values in NP and KO cells for target genes known to be PD-L1 regulators. ```sourceCode R Explore the perturbation scores of cells. PlotPerturbScore(object = eccite, target.gene.ident = \"IFNGR2\", mixscape.class = \"mixscape_class\", col = \"coral2\") +labs(fill = \"mixscape class\") ``` ```sourceCode R Inspect the posterior probability values in NP and KO cells. VlnPlot(eccite, \"mixscape_class_p_ko\", idents = c(\"NT\", \"IFNGR2 KO\", \"IFNGR2 NP\")) + theme(axis.text.x = element_text(angle = 0, hjust = 0.5),axis.text = element_text(size = 16) ,plot.title = element_text(size = 20)) + NoLegend() + ggtitle(\"mixscape posterior probabilities\") ``` ```sourceCode R Run DE analysis and visualize results on a heatmap ordering cells by their posterior probability values. Idents(object = eccite) <- \"gene\" MixscapeHeatmap(object = eccite, ident.1 = \"NT\", ident.2 = \"IFNGR2\", balanced = F, assay = \"RNA\", max.genes = 20, angle = 0, group.by = \"mixscape_class\", max.cells.group = 300, size=6.5) + NoLegend() +theme(axis.text.y = element_text(size = 16)) ``` ```sourceCode R Show that only IFNG pathway KO cells have a reduction in PD-L1 protein expression. VlnPlot( object = eccite, features = \"adt_PDL1\", idents = c(\"NT\",\"JAK2\",\"STAT1\",\"IFNGR1\",\"IFNGR2\", \"IRF1\"), group.by = \"gene\", pt.size = 0.2, sort = T, split.by = \"mixscape_class.global\", cols = c(\"coral3\",\"grey79\",\"grey39\")) + ggtitle(\"PD-L1 protein\") + theme(axis.text.x = element_text(angle = 0, hjust = 0.5), plot.title = element_text(size = 20), axis.text = element_text(size = 16)) ``` sourceCode R p <- VlnPlot(object = eccite, features = \"adt_PDL1\", idents = c(\"NT\",\"JAK2\",\"STAT1\",\"IFNGR1\",\"IFNGR2\", \"IRF1\"), group.by = \"gene\", pt.size = 0.2, sort = T, split.by = \"mixscape_class.global\", cols = c(\"coral3\",\"grey79\",\"grey39\")) +ggtitle(\"PD-L1 protein\") +theme(axis.text.x = element_text(angle = 0, hjust = 0.5)) Visualizing perturbation responses with Linear Discriminant Analysis (LDA) anchor We use LDA as a dimensionality reduction method to visualize perturbation-specific clusters. LDA is trying to maximize the separability of known labels (mixscape classes) using both gene expression and the labels as input. ```sourceCode R Remove non-perturbed cells and run LDA to reduce the dimensionality of the data. Idents(eccite) <- \"mixscape_class.global\" sub <- subset(eccite, idents = c(\"KO\", \"NT\")) Run LDA. sub <- MixscapeLDA( object = sub, assay = \"RNA\", pc.assay = \"PRTB\", labels = \"gene\", nt.label = \"NT\", npcs = 10, logfc.threshold = 0.25, verbose = F) Use LDA results to run UMAP and visualize cells on 2-D. Here, we note that the number of the dimensions to be used is equal to the number of labels minus one (to account for NT cells). sub <- RunUMAP( object = sub, dims = 1:11, reduction = 'lda', reduction.key = 'ldaumap', reduction.name = 'ldaumap') Visualize UMAP clustering results. Idents(sub) <- \"mixscape_class\" sub$mixscape_class <- as.factor(sub$mixscape_class) Set colors for each perturbation. col = setNames(object = hue_pal()(12),nm = levels(sub$mixscape_class)) names(col) <- c(names(col)[1:7], \"NT\", names(col)[9:12]) col[8] <- \"grey39\" p <- DimPlot(object = sub, reduction = \"ldaumap\", repel = T, label.size = 5, label = T, cols = col) + NoLegend() p2 <- p+ scale_color_manual(values=col, drop=FALSE) + ylab(\"UMAP 2\") + xlab(\"UMAP 1\") + custom_theme p2 ``` Session Info sourceCode R sessionInfo() ``` R version 4.2.2 Patched (2022-11-10 r83330) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.6 LTS Matrix products: default BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats graphics grDevices utils datasets methods base other attached packages: [1] reshape2_1.4.4 dplyr_1.1.3 [3] scales_1.2.1 patchwork_1.1.3 [5] ggplot2_3.4.4 thp1.eccite.SeuratData_3.1.5 [7] stxBrain.SeuratData_0.1.1 ssHippo.SeuratData_3.1.4 [9] pbmcsca.SeuratData_3.0.0 pbmcref.SeuratData_1.0.0 [11] pbmcMultiome.SeuratData_0.1.4 pbmc3k.SeuratData_3.1.4 [13] panc8.SeuratData_3.0.2 ifnb.SeuratData_3.0.0 [15] hcabm40k.SeuratData_3.0.0 cbmc.SeuratData_3.1.4 [17] bmcite.SeuratData_0.3.0 SeuratData_0.2.2.9001 [19] Seurat_5.0.0 SeuratObject_5.0.0 [21] sp_2.1-1 loaded via a namespace (and not attached): [1] spam_2.10-0 systemfonts_1.0.4 plyr_1.8.9 [4] igraph_1.5.1 lazyeval_0.2.2 splines_4.2.2 [7] RcppHNSW_0.5.0 listenv_0.9.0 scattermore_1.2 [10] digest_0.6.33 htmltools_0.5.6.1 fansi_1.0.5 [13] magrittr_2.0.3 memoise_2.0.1 tensor_1.5 [16] cluster_2.1.4 mixtools_2.0.0 ROCR_1.0-11 [19] limma_3.54.1 globals_0.16.2 matrixStats_1.0.0 [22] pkgdown_2.0.7 spatstat.sparse_3.0-3 colorspace_2.1-0 [25] rappdirs_0.3.3 ggrepel_0.9.4 textshaping_0.3.6 [28] xfun_0.40 crayon_1.5.2 jsonlite_1.8.7 [31] progressr_0.14.0 spatstat.data_3.0-3 survival_3.5-7 [34] zoo_1.8-12 glue_1.6.2 polyclip_1.10-6 [37] gtable_0.3.4 leiden_0.4.3 kernlab_0.9-32 [40] future.apply_1.11.0 abind_1.4-5 spatstat.random_3.2-1 [43] miniUI_0.1.1.1 Rcpp_1.0.11 viridisLite_0.4.2 [46] xtable_1.8-4 reticulate_1.34.0 dotCall64_1.1-0 [49] htmlwidgets_1.6.2 httr_1.4.7 RColorBrewer_1.1-3 [52] ellipsis_0.3.2 ica_1.0-3 farver_2.1.1 [55] pkgconfig_2.0.3 sass_0.4.7 uwot_0.1.16 [58] deldir_1.0-9 utf8_1.2.4 labeling_0.4.3 [61] tidyselect_1.2.0 rlang_1.1.1 later_1.3.1 [64] munsell_0.5.0 tools_4.2.2 cachem_1.0.8 [67] cli_3.6.1 generics_0.1.3 ggridges_0.5.4 [70] evaluate_0.22 stringr_1.5.0 fastmap_1.1.1 [73] yaml_2.3.7 ragg_1.2.5 goftest_1.2-3 [76] knitr_1.45 fs_1.6.3 fitdistrplus_1.1-11 [79] purrr_1.0.2 RANN_2.6.1 pbapply_1.7-2 [82] future_1.33.0 nlme_3.1-162 mime_0.12 [85] ggrastr_1.0.1 compiler_4.2.2 beeswarm_0.4.0 [88] plotly_4.10.3 png_0.1-8 spatstat.utils_3.0-4 [91] tibble_3.2.1 bslib_0.5.1 stringi_1.7.12 [94] highr_0.10 desc_1.4.2 RSpectra_0.16-1 [97] lattice_0.21-9 Matrix_1.6-1.1 vctrs_0.6.4 [100] pillar_1.9.0 lifecycle_1.0.3 spatstat.geom_3.2-7 [103] lmtest_0.9-40 jquerylib_0.1.4 RcppAnnoy_0.0.21 [106] data.table_1.14.8 cowplot_1.1.1 irlba_2.3.5.1 [109] httpuv_1.6.12 R6_2.5.1 promises_1.2.1 [112] KernSmooth_2.23-22 gridExtra_2.3 vipor_0.4.5 [115] parallelly_1.36.0 codetools_0.2-19 fastDummies_1.7.3 [118] MASS_7.3-58.2 rprojroot_2.0.3 withr_2.5.2 [121] presto_1.0.0 sctransform_0.4.1 parallel_4.2.2 [124] grid_4.2.2 tidyr_1.3.0 rmarkdown_2.25 [127] segmented_1.6-4 Rtsne_0.16 spatstat.explore_3.2-5 [130] shiny_1.7.5.1 ggbeeswarm_0.7.1 ```",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/mixscape_vignette",
      "title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat • Seurat",
      "ogTitle": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "language": "en",
      "og:title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "scrapeId": "3977588a-8434-46a3-884a-971fc34616c6",
      "viewport": "width=device-width, initial-scale=1.0",
      "sourceURL": "https://satijalab.org/seurat/articles/mixscape_vignette",
      "statusCode": 200,
      "ogDescription": "Seurat",
      "og:description": "Seurat"
    }
  },
  {
    "processed_text": "",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/seurat5_v4_changes.html",
      "error": "Not Found",
      "scrapeId": "395cdbd6-7613-4208-bb50-be322595f162",
      "sourceURL": "https://satijalab.org/seurat/articles/seurat5_v4_changes.html",
      "statusCode": 404
    }
  },
  {
    "processed_text": "Seurat - Dimensional Reduction Vignette Compiled: September 14, 2023 Source: vignettes/dim_reduction_vignette.Rmd dim_reduction_vignette.Rmd Load in the data anchor This vignette demonstrates how to store and interact with dimensional reduction information (such as the output from RunPCA() ) in Seurat. For demonstration purposes, we will be using the 2,700 PBMC object that is available via the SeuratData package. sourceCode R library(Seurat) library(SeuratData) pbmc <- LoadData(\"pbmc3k\", type = \"pbmc3k.final\") Explore the new dimensional reduction structure anchor In Seurat v3.0, storing and interacting with dimensional reduction information has been generalized and formalized into the DimReduc object. Each dimensional reduction procedure is stored as a DimReduc object in the object@reductions slot as an element of a named list. Accessing these reductions can be done with the [[ operator, calling the name of the reduction desired. For example, after running a principle component analysis with RunPCA() , object[['pca']] will contain the results of the PCA. By adding new elements to the list, users can add additional, and custom, dimensional reductions. Each stored dimensional reduction contains the following slots:\\ \\ 1. cell.embeddings : stores the coordinates for each cell in low-dimensional space.\\ 2. feature.loadings : stores the weight for each feature along each dimension of the embedding\\ 3. feature.loadings.projected : Seurat typically calculate the dimensional reduction on a subset of genes (for example, high-variance genes), and then project that structure onto the entire dataset (all genes). The results of that projection (calculated with ProjectDim() ) are stored in this slot. Note that the cell loadings will remain unchanged after projection but there are now feature loadings for all feature\\ 4. stdev : The standard deviations of each dimension. Most often used with PCA (storing the square roots of the eigenvalues of the covariance matrix) and can be useful when looking at the drop off in the amount of variance that is explained by each successive dimension.\\ 5. key : Sets the column names for the cell.embeddings and feature.loadings matrices. For example, for PCA, the column names are PC1, PC2, etc., so the key is “PC”.\\ 6. jackstraw : Stores the results of the jackstraw procedure run using this dimensional reduction technique. Currently supported only for PCA.\\ 7. misc : Bonus slot to store any other information you might want\\ \\ To access these slots, we provide the Embeddings() , Loadings() , and Stdev() functions\\ \\ sourceCode R\\ pbmc[[\"pca\"]]\\ \\ \\ \\ ## A dimensional reduction object with key PC_\\ ## Number of dimensions: 50\\ ## Number of cells: 2638\\ ## Projected dimensional reduction calculated: FALSE\\ ## Jackstraw run: TRUE\\ ## Computed using assay: RNA\\ \\ \\ sourceCode R\\ head(Embeddings(pbmc, reduction = \"pca\")[, 1:5])\\ \\ \\ \\ ## PC_1 PC_2 PC_3 PC_4 PC_5\\ ## AAACATACAACCAC -4.7296855 -0.5184265 -0.7623220 -2.3156790 -0.07160006\\ ## AAACATTGAGCTAC -0.5174029 4.5918957 5.9091921 6.9118856 -1.96243034\\ ## AAACATTGATCAGC -3.1891063 -3.4695154 -0.8313710 -2.0019985 -5.10442765\\ ## AAACCGTGCTTCCG 12.7933021 0.1007166 0.6310221 -0.3687338 0.21838204\\ ## AAACCGTGTATGCG -3.1288078 -6.3481412 1.2507776 3.0191026 7.84739502\\ ## AAACGCACTGGTAC -3.1088963 0.9262125 -0.6482331 -2.3244378 -2.00526763\\ \\ \\ sourceCode R\\ head(Loadings(pbmc, reduction = \"pca\")[, 1:5])\\ \\ \\ \\ ## PC_1 PC_2 PC_3 PC_4 PC_5\\ ## PPBP 0.010990202 0.01148426 -0.15176092 0.10403737 0.003299077\\ ## LYZ 0.116231706 0.01472515 -0.01280613 -0.04414540 0.049906881\\ ## S100A9 0.115414362 0.01895146 -0.02368853 -0.05787777 0.085382309\\ ## IGLL5 -0.007987473 0.05454239 0.04901533 0.06694722 0.004603231\\ ## GNLY -0.015238762 -0.13375626 0.04101340 0.06912322 0.104558611\\ ## FTL 0.118292572 0.01871142 -0.00984755 -0.01555269 0.038743505\\ \\ \\ sourceCode R\\ head(Stdev(pbmc, reduction = \"pca\"))\\ \\ \\ \\ ## [1] 7.098420 4.495493 3.872592 3.748859 3.171755 2.545292\\ \\ \\ Seurat provides RunPCA() (pca), and RunTSNE() (tsne), and representing dimensional reduction techniques commonly applied to scRNA-seq data. When using these functions, all slots are filled automatically.\\ \\ We also allow users to add the results of a custom dimensional reduction technique (for example, multi-dimensional scaling (MDS), or zero-inflated factor analysis ), that is computed separately. All you need is a matrix with each cell’s coordinates in low-dimensional space, as shown below.\\ \\ ## Storing a custom dimensional reduction calculation anchor \\ \\ Though not incorporated as part of the Seurat package, its easy to run multidimensional scaling (MDS) in R. If you were interested in running MDS and storing the output in your Seurat object:\\ \\ sourceCode R\\ # Before running MDS, we first calculate a distance matrix between all pairs of cells. Here\\ # we use a simple euclidean distance metric on all genes, using scale.data as input\\ d <- dist(t(GetAssayData(pbmc, slot = \"scale.data\")))\\ # Run the MDS procedure, k determines the number of dimensions\\ mds <- cmdscale(d = d, k = 2)\\ # cmdscale returns the cell embeddings, we first label the columns to ensure downstream\\ # consistency\\ colnames(mds) <- paste0(\"MDS_\", 1:2)\\ # We will now store this as a custom dimensional reduction called 'mds'\\ pbmc[[\"mds\"]] <- CreateDimReducObject(embeddings = mds, key = \"MDS_\", assay = DefaultAssay(pbmc))\\ \\ # We can now use this as you would any other dimensional reduction in all downstream functions\\ DimPlot(pbmc, reduction = \"mds\", pt.size = 0.5)\\ \\ \\ \\ \\ sourceCode R\\ # If you wold like to observe genes that are strongly correlated with the first MDS coordinate\\ pbmc <- ProjectDim(pbmc, reduction = \"mds\")\\ \\ \\ \\ ## MDS_ 1\\ ## Positive: MALAT1, RPS27A, RPS27, RPL3, RPL23A, RPL21, RPL13A, RPS6, RPS3A, RPS3\\ ## RPL9, LTB, RPSA, CD3D, RPS25, RPS18, PTPRCAP, RPS12, RPL30, RPL31\\ ## Negative: CST3, TYROBP, FCER1G, LST1, FTL, AIF1, FTH1, TYMP, FCN1, LYZ\\ ## LGALS1, S100A9, CFD, CD68, SERPINA1, CTSS, IFITM3, SPI1, S100A8, LGALS2\\ ## MDS_ 2\\ ## Positive: NKG7, PRF1, CST7, GZMA, GZMB, B2M, FGFBP2, CTSW, GNLY, HLA-C\\ ## GZMH, SPON2, CD247, FCGR3A, CCL5, HLA-A, CCL4, GZMM, KLRD1, CLIC3\\ ## Negative: RPL32, RPL18A, HLA-DRA, CD79A, RPL13, MS4A1, RPL11, TCL1A, RPS9, RPL12\\ ## LINC00926, HLA-DQB1, HLA-DQA1, HLA-DRB1, RPL28, RPS2, S100A8, HLA-DMA, RPL8, RPLP1\\ \\ \\ sourceCode R\\ # Display the results as a heatmap\\ DimHeatmap(pbmc, reduction = \"mds\", dims = 1, cells = 500, projected = TRUE, balanced = TRUE)\\ \\ \\ \\ \\ sourceCode R\\ # Explore how the first MDS dimension is distributed across clusters\\ VlnPlot(pbmc, features = \"MDS_1\")\\ \\ \\ \\ \\ sourceCode R\\ # See how the first MDS dimension is correlated with the first PC dimension\\ FeatureScatter(pbmc, feature1 = \"MDS_1\", feature2 = \"PC_1\")\\ \\ \\ \\ \\ sourceCode R\\ library(ggplot2)\\ plot <- DimPlot(pbmc, reduction = \"mds\", pt.size = 0.5)\\ ggsave(filename = \"../output/images/pbmc_mds.jpg\", height = 7, width = 12, plot = plot, quality = 50)\\ \\ \\ Session Info \\ \\ sourceCode R\\ sessionInfo()\\ \\ \\ \\ ## R version 4.2.2 Patched (2022-11-10 r83330)\\ ## Platform: x86_64-pc-linux-gnu (64-bit)\\ ## Running under: Ubuntu 20.04.6 LTS\\ ##\\ ## Matrix products: default\\ ## BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0\\ ## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\\ ##\\ ## locale:\\ ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C\\ ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8\\ ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8\\ ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C\\ ## [9] LC_ADDRESS=C LC_TELEPHONE=C\\ ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C\\ ##\\ ## attached base packages:\\ ## [1] stats graphics grDevices utils datasets methods base\\ ##\\ ## other attached packages:\\ ## [1] ggplot2_3.4.3 thp1.eccite.SeuratData_3.1.5\\ ## [3] pbmcsca.SeuratData_3.0.0 pbmcref.SeuratData_1.0.0\\ ## [5] pbmcMultiome.SeuratData_0.1.4 pbmc3k.SeuratData_3.1.4\\ ## [7] panc8.SeuratData_3.0.2 ifnb.SeuratData_3.1.0\\ ## [9] hcabm40k.SeuratData_3.0.0 bmcite.SeuratData_0.3.0\\ ## [11] SeuratData_0.2.2.9001 Seurat_4.9.9.9059\\ ## [13] SeuratObject_4.9.9.9091 sp_2.0-0\\ ##\\ ## loaded via a namespace (and not attached):\\ ## [1] spam_2.9-1 systemfonts_1.0.4 plyr_1.8.8\\ ## [4] igraph_1.5.1 lazyeval_0.2.2 splines_4.2.2\\ ## [7] RcppHNSW_0.4.1 listenv_0.9.0 scattermore_1.2\\ ## [10] digest_0.6.33 htmltools_0.5.6 fansi_1.0.4\\ ## [13] magrittr_2.0.3 memoise_2.0.1 tensor_1.5\\ ## [16] cluster_2.1.4 ROCR_1.0-11 globals_0.16.2\\ ## [19] matrixStats_1.0.0 pkgdown_2.0.7 spatstat.sparse_3.0-2\\ ## [22] colorspace_2.1-0 rappdirs_0.3.3 ggrepel_0.9.3\\ ## [25] textshaping_0.3.6 xfun_0.40 dplyr_1.1.3\\ ## [28] crayon_1.5.2 jsonlite_1.8.7 progressr_0.14.0\\ ## [31] spatstat.data_3.0-1 survival_3.5-5 zoo_1.8-12\\ ## [34] glue_1.6.2 polyclip_1.10-4 gtable_0.3.4\\ ## [37] leiden_0.4.3 future.apply_1.11.0 abind_1.4-5\\ ## [40] scales_1.2.1 spatstat.random_3.1-5 miniUI_0.1.1.1\\ ## [43] Rcpp_1.0.11 viridisLite_0.4.2 xtable_1.8-4\\ ## [46] reticulate_1.31 dotCall64_1.0-2 htmlwidgets_1.6.2\\ ## [49] httr_1.4.7 RColorBrewer_1.1-3 ellipsis_0.3.2\\ ## [52] ica_1.0-3 farver_2.1.1 pkgconfig_2.0.3\\ ## [55] sass_0.4.7 uwot_0.1.16 deldir_1.0-9\\ ## [58] utf8_1.2.3 labeling_0.4.3 tidyselect_1.2.0\\ ## [61] rlang_1.1.1 reshape2_1.4.4 later_1.3.1\\ ## [64] munsell_0.5.0 tools_4.2.2 cachem_1.0.8\\ ## [67] cli_3.6.1 generics_0.1.3 ggridges_0.5.4\\ ## [70] evaluate_0.21 stringr_1.5.0 fastmap_1.1.1\\ ## [73] yaml_2.3.7 ragg_1.2.5 goftest_1.2-3\\ ## [76] knitr_1.43 fs_1.6.3 fitdistrplus_1.1-11\\ ## [79] purrr_1.0.2 RANN_2.6.1 pbapply_1.7-2\\ ## [82] future_1.33.0 nlme_3.1-162 mime_0.12\\ ## [85] formatR_1.14 ggrastr_1.0.1 compiler_4.2.2\\ ## [88] beeswarm_0.4.0 plotly_4.10.2 png_0.1-8\\ ## [91] spatstat.utils_3.0-3 tibble_3.2.1 bslib_0.5.1\\ ## [94] stringi_1.7.12 highr_0.10 desc_1.4.2\\ ## [97] RSpectra_0.16-1 lattice_0.21-8 Matrix_1.5-3\\ ## [100] vctrs_0.6.3 pillar_1.9.0 lifecycle_1.0.3\\ ## [103] spatstat.geom_3.2-5 lmtest_0.9-40 jquerylib_0.1.4\\ ## [106] RcppAnnoy_0.0.21 data.table_1.14.8 cowplot_1.1.1\\ ## [109] irlba_2.3.5.1 httpuv_1.6.11 patchwork_1.1.3\\ ## [112] R6_2.5.1 promises_1.2.1 KernSmooth_2.23-22\\ ## [115] gridExtra_2.3 vipor_0.4.5 parallelly_1.36.0\\ ## [118] codetools_0.2-19 fastDummies_1.7.3 MASS_7.3-58.2\\ ## [121] rprojroot_2.0.3 withr_2.5.0 sctransform_0.3.5\\ ## [124] parallel_4.2.2 grid_4.2.2 tidyr_1.3.0\\ ## [127] rmarkdown_2.24 Rtsne_0.16 spatstat.explore_3.2-1\\ ## [130] shiny_1.7.5 ggbeeswarm_0.7.1\\",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/dim_reduction_vignette",
      "title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat • Seurat",
      "ogTitle": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "language": "en",
      "og:title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "scrapeId": "3ed9c717-71c8-4060-9bc8-1fcfabc53840",
      "viewport": "width=device-width, initial-scale=1.0",
      "sourceURL": "https://satijalab.org/seurat/articles/dim_reduction_vignette",
      "statusCode": 200,
      "ogDescription": "Seurat",
      "og:description": "Seurat"
    }
  },
  {
    "processed_text": "Sketch-based analysis in Seurat v5 Compiled: 2023-10-31 Source: vignettes/seurat5_sketch_analysis.Rmd seurat5_sketch_analysis.Rmd Intro: Sketch-based analysis in Seurat v5 anchor As single-cell sequencing technologies continue to improve in scalability in throughput, the generation of datasets spanning a million or more cells is becoming increasingly routine. In Seurat v5, we introduce new infrastructure and methods to analyze, interpret, and explore these exciting datasets. In this vignette, we introduce a sketch-based analysis workflow to analyze a 1.3 million cell dataset of the developing mouse brain, freely available from 10x Genomics. Analyzing datasets of this size with standard workflows can be challenging, slow, and memory-intensive. Here we introduce an alternative workflow that is highly scalable, even to datasets ranging beyond 10 million cells in size. Our ‘sketch-based’ workflow involves three new features in Seurat v5: Infrastructure for on-disk storage of large single-cell datasets Storing expression matrices in memory can be challenging for extremely large scRNA-seq datasets. In Seurat v5, we introduce support for multiple on-disk storage formats. ‘Sketching’ methods to subsample cells from large datasets while preserving rare populations As introduced in Hie et al, 2019 , cell sketching methods aim to compactly summarize large single-cell datasets in a small number of cells, while preserving the presence of both abundant and rare cell types. In Seurat v5, we leverage this idea to select subsamples (‘sketches’) of cells from large datasets that are stored on-disk. However, after sketching, the subsampled cells can be stored in-memory, allowing for interactive and rapid visualization and exploration. We store sketched cells (in-memory) and the full dataset (on-disk) as two assays in the same Seurat object. Users can then easily switch between the two versions, providing the flexibility to perform quick analyses on a subset of cells in-memory, while retaining access to the full dataset on-disk. Support for ‘bit-packing’ compression and infrastructure We demonstrate the on-disk capabilities in Seurat v5 using the BPCells package developed by Ben Parks in the Greenleaf Lab. This package utilizes bit-packing compression and optimized, streaming-compatible C++ code to substantially improve I/O and computational performance when working with on-disk data. To run this vignette please install Seurat v5, using the installation instructions found here . Additionally, you will need to install the BPcells package, using the installation instructions found here . ```sourceCode R library(Seurat) library(BPCells) library(ggplot2) needs to be set for large dataset analysis options(future.globals.maxSize = 1e9) ``` Create a Seurat object with a v5 assay for on-disk storage anchor We start by loading the 1.3M dataset from 10x Genomics using the open_matrix_dir function from BPCells . Note that in our Introduction to on-disk storage vignette , we demonstrate how to create this on-disk representation. This function does not load the dataset into memory, but instead, creates a connection to the data stored on-disk. We then store this on-disk representation in the Seurat object, which is loaded using readRDS as per usual. ```sourceCode R Read the Seurat object, which contains 1.3M cells stored on-disk as part of the 'RNA' assay obj <- readRDS(\"/brahms/hartmana/vignette_data/1p3_million_mouse_brain.rds\") obj ``` ``` An object of class Seurat 27282 features across 1306127 samples within 1 assay Active assay: RNA (27282 features, 0 variable features) 1 layer present: counts ``` ```sourceCode R Note that since the data is stored on-disk, the object size easily fits in-memory (<1GB) format(object.size(obj), units = \"Mb\") ``` ``` [1] \"596.2 Mb\" ``` ‘Sketch’ a subset of cells, and load these into memory anchor We select a subset (‘sketch’) of 50,000 cells (out of 1.3M). Rather than sampling all cells with uniform probability, we compute and sample based off a ‘leverage score’ for each cell, which reflects the magnitude of its contribution to the gene-covariance matrix, and its importance to the overall dataset. In Hao et al, 2022 , we demonstrate that the leverage score is highest for rare populations in a dataset. Therefore, our sketched set of 50,000 cells will oversample rare populations, retaining the biological complexity of the sample while drastically compressing the dataset. The function SketchData takes a normalized single-cell dataset (stored either on-disk or in-memory), and a set of variable features. It returns a Seurat object with a new assay ( sketch ), consisting of 50,000 cells, but these cells are now stored in-memory. Users can now easily switch between the in-memory and on-disk representation just by changing the default assay. sourceCode R obj <- NormalizeData(obj) obj <- FindVariableFeatures(obj) obj <- SketchData( object = obj, ncells = 50000, method = \"LeverageScore\", sketched.assay = \"sketch\" ) obj ``` An object of class Seurat 54564 features across 1306127 samples within 2 assays Active assay: sketch (27282 features, 2000 variable features) 2 layers present: counts, data 1 other assay present: RNA ``` ```sourceCode R switch to analyzing the full dataset (on-disk) DefaultAssay(obj) <- \"RNA\" switch to analyzing the sketched dataset (in-memory) DefaultAssay(obj) <- \"sketch\" ``` Perform clustering on the sketched dataset anchor Now that we have compressed the dataset, we can perform standard clustering and visualization of a 50,000 cell dataset. After clustering, we can see groups of cells that clearly correspond to precursors of distinct lineages, including endothelial cells (Igfbp7), Excitatory (Neurod6) and Inhibitory (Dlx2) neurons, Intermediate Progenitors (Eomes), Radial Glia (Vim), Cajal-Retzius cells (Reln), Oligodendroytes (Olig1), and extremely rare populations of macrophages (C1qa) that were oversampled in our sketched data. sourceCode R DefaultAssay(obj) <- \"sketch\" obj <- FindVariableFeatures(obj) obj <- ScaleData(obj) obj <- RunPCA(obj) obj <- FindNeighbors(obj, dims = 1:50) obj <- FindClusters(obj, resolution = 2) ``` Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck Number of nodes: 50000 Number of edges: 1992657 Running Louvain algorithm... Maximum modularity in 10 random starts: 0.8766 Number of communities: 51 Elapsed time: 19 seconds ``` sourceCode R obj <- RunUMAP(obj, dims = 1:50, return.model = T) DimPlot(obj, label = T, label.size = 3, reduction = \"umap\") + NoLegend() sourceCode R FeaturePlot( object = obj, features = c( \"Igfbp7\", \"Neurod6\", \"Dlx2\", \"Gad2\", \"Eomes\", \"Vim\", \"Reln\", \"Olig1\", \"C1qa\" ), ncol = 3 ) Extend results to the full datasets anchor We can now extend the cluster labels and dimensional reductions learned on the sketched cells to the full dataset. The ProjectData function projects the on-disk data, onto the sketch assay. It returns a Seurat object that includes a Dimensional reduction (PCA): The pca.full dimensional reduction extends the pca reduction on the sketched cells to all cells in the dataset Dimensional reduction (UMAP): The full.umap dimensional reduction extends the umap reduction on the sketched cells to all cells in the dataset Cluster labels: The cluster_full column in the object metadata now labels all cells in the dataset with one of the cluster labels derived from the sketched cells ```sourceCode R obj <- ProjectData( object = obj, assay = \"RNA\", full.reduction = \"pca.full\", sketched.assay = \"sketch\", sketched.reduction = \"pca\", umap.model = \"umap\", dims = 1:50, refdata = list(cluster_full = \"seurat_clusters\") ) now that we have projected the full dataset, switch back to analyzing all cells DefaultAssay(obj) <- \"RNA\" ``` sourceCode R DimPlot(obj, label = T, label.size = 3, reduction = \"full.umap\", group.by = \"cluster_full\", alpha = 0.1) + NoLegend() ```sourceCode R visualize gene expression on the sketched cells (fast) and the full dataset (slower) DefaultAssay(obj) <- \"sketch\" x1 <- FeaturePlot(obj, \"C1qa\") DefaultAssay(obj) <- \"RNA\" x2 <- FeaturePlot(obj, \"C1qa\") x1 | x2 ``` Perform iterative sub-clustering anchor Now that we have performed an initial analysis of the dataset, we can iteratively ‘zoom-in’ on a cell subtype of interest, extract all cells of this type, and perform iterative sub-clustering. For example, we can see that Dlx2+ interneuron precursors are defined by clusters 2, 15, 18, 28 and 40. sourceCode R DefaultAssay(obj) <- \"sketch\" VlnPlot(obj, \"Dlx2\") We therefore extract all cells from the full on-disk dataset that are present in these clusters. There are 200,892 of them. Since this is a manageable number, we can convert these data from on-disk storage into in-memory storage. We can then proceed with standard clustering. ```sourceCode R subset cells in these clusters. Note that the data remains on-disk after subsetting obj.sub <- subset(obj, subset = cluster_full %in% c(2, 15, 18, 28, 40)) DefaultAssay(obj.sub) <- \"RNA\" now convert the RNA assay (previously on-disk) into an in-memory representation (sparse Matrix) we only convert the data layer, and keep the counts on-disk obj.sub[[\"RNA\"]]$data <- as(obj.sub[[\"RNA\"]]$data, Class = \"dgCMatrix\") recluster the cells obj.sub <- FindVariableFeatures(obj.sub) obj.sub <- ScaleData(obj.sub) obj.sub <- RunPCA(obj.sub) obj.sub <- RunUMAP(obj.sub, dims = 1:30) obj.sub <- FindNeighbors(obj.sub, dims = 1:30) obj.sub <- FindClusters(obj.sub) ``` ``` Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck Number of nodes: 236276 Number of edges: 5470656 Running Louvain algorithm... Maximum modularity in 10 random starts: 0.8577 Number of communities: 28 Elapsed time: 191 seconds ``` sourceCode R DimPlot(obj.sub, label = T, label.size = 3) + NoLegend() Note that we can start to see distinct interneuron lineages emerging in this dataset. We can see a clear separation of interneuron precursors that originated from the medial ganglionic eminence (Lhx6) or caudal ganglionic eminence (Nr2f2). We can further see the emergence of Sst (Sst) and Pvalb (Mef2c)-committed interneurons, and a CGE-derived Meis2-expressing progenitor population. These results closely mirror our findings from Mayer , Hafemeister , Bandler* et al, Nature 2018 , where we enriched for interneuron precursors using a Dlx6a-cre fate-mapping strategy. Here, we obtain similar results using only computational enrichment, enabled by the large size of the original dataset. sourceCode R FeaturePlot( object = obj.sub, features = c( \"Dlx2\", \"Gad2\", \"Lhx6\", \"Nr2f2\", \"Sst\", \"Mef2c\", \"Meis2\", \"Id2\", \"Dlx6os1\" ), ncol = 3 ) Session Info sourceCode R sessionInfo() ``` R version 4.2.2 Patched (2022-11-10 r83330) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.6 LTS Matrix products: default BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats graphics grDevices utils datasets methods base other attached packages: [1] ggplot2_3.4.4 BPCells_0.1.0 Seurat_5.0.0 SeuratObject_5.0.0 [5] sp_2.1-1 loaded via a namespace (and not attached): [1] spam_2.10-0 systemfonts_1.0.4 plyr_1.8.9 [4] igraph_1.5.1 lazyeval_0.2.2 splines_4.2.2 [7] RcppHNSW_0.5.0 listenv_0.9.0 scattermore_1.2 [10] GenomeInfoDb_1.34.9 digest_0.6.33 htmltools_0.5.6.1 [13] fansi_1.0.5 magrittr_2.0.3 memoise_2.0.1 [16] tensor_1.5 cluster_2.1.4 ROCR_1.0-11 [19] globals_0.16.2 matrixStats_1.0.0 R.utils_2.12.2 [22] pkgdown_2.0.7 spatstat.sparse_3.0-3 colorspace_2.1-0 [25] ggrepel_0.9.4 textshaping_0.3.6 xfun_0.40 [28] dplyr_1.1.3 RCurl_1.98-1.12 jsonlite_1.8.7 [31] progressr_0.14.0 spatstat.data_3.0-3 survival_3.5-7 [34] zoo_1.8-12 glue_1.6.2 polyclip_1.10-6 [37] gtable_0.3.4 zlibbioc_1.44.0 XVector_0.38.0 [40] leiden_0.4.3 R.cache_0.16.0 future.apply_1.11.0 [43] BiocGenerics_0.44.0 abind_1.4-5 scales_1.2.1 [46] spatstat.random_3.2-1 miniUI_0.1.1.1 Rcpp_1.0.11 [49] viridisLite_0.4.2 xtable_1.8-4 reticulate_1.34.0 [52] dotCall64_1.1-0 stats4_4.2.2 htmlwidgets_1.6.2 [55] httr_1.4.7 RColorBrewer_1.1-3 ellipsis_0.3.2 [58] ica_1.0-3 farver_2.1.1 pkgconfig_2.0.3 [61] R.methodsS3_1.8.2 sass_0.4.7 uwot_0.1.16 [64] deldir_1.0-9 utf8_1.2.4 labeling_0.4.3 [67] tidyselect_1.2.0 rlang_1.1.1 reshape2_1.4.4 [70] later_1.3.1 munsell_0.5.0 tools_4.2.2 [73] cachem_1.0.8 cli_3.6.1 generics_0.1.3 [76] ggridges_0.5.4 evaluate_0.22 stringr_1.5.0 [79] fastmap_1.1.1 yaml_2.3.7 ragg_1.2.5 [82] goftest_1.2-3 knitr_1.45 fs_1.6.3 [85] fitdistrplus_1.1-11 purrr_1.0.2 RANN_2.6.1 [88] pbapply_1.7-2 future_1.33.0 nlme_3.1-162 [91] mime_0.12 ggrastr_1.0.1 R.oo_1.25.0 [94] compiler_4.2.2 beeswarm_0.4.0 plotly_4.10.3 [97] png_0.1-8 spatstat.utils_3.0-4 tibble_3.2.1 [100] bslib_0.5.1 stringi_1.7.12 highr_0.10 [103] desc_1.4.2 RSpectra_0.16-1 lattice_0.21-9 [106] Matrix_1.6-1.1 styler_1.10.2 vctrs_0.6.4 [109] pillar_1.9.0 lifecycle_1.0.3 spatstat.geom_3.2-7 [112] lmtest_0.9-40 jquerylib_0.1.4 RcppAnnoy_0.0.21 [115] bitops_1.0-7 data.table_1.14.8 cowplot_1.1.1 [118] irlba_2.3.5.1 httpuv_1.6.12 patchwork_1.1.3 [121] GenomicRanges_1.50.2 R6_2.5.1 promises_1.2.1 [124] KernSmooth_2.23-22 gridExtra_2.3 vipor_0.4.5 [127] IRanges_2.32.0 parallelly_1.36.0 codetools_0.2-19 [130] fastDummies_1.7.3 MASS_7.3-58.2 rprojroot_2.0.3 [133] withr_2.5.2 sctransform_0.4.1 GenomeInfoDbData_1.2.9 [136] S4Vectors_0.36.2 parallel_4.2.2 grid_4.2.2 [139] tidyr_1.3.0 rmarkdown_2.25 Rtsne_0.16 [142] spatstat.explore_3.2-5 shiny_1.7.5.1 ggbeeswarm_0.7.1 ```",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/seurat5_sketch_analysis",
      "title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat • Seurat",
      "ogTitle": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "language": "en",
      "og:title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "scrapeId": "4df88681-bd38-43b2-b2c6-3ce3d88e3d54",
      "viewport": "width=device-width, initial-scale=1.0",
      "sourceURL": "https://satijalab.org/seurat/articles/seurat5_sketch_analysis",
      "statusCode": 200,
      "ogDescription": "Seurat",
      "og:description": "Seurat"
    }
  },
  {
    "processed_text": "Weighted Nearest Neighbor Analysis Compiled: October 31, 2023 Source: vignettes/weighted_nearest_neighbor_analysis.Rmd weighted_nearest_neighbor_analysis.Rmd The simultaneous measurement of multiple modalities, known as multimodal analysis, represents an exciting frontier for single-cell genomics and necessitates new computational methods that can define cellular states based on multiple data types. The varying information content of each modality, even across cells in the same dataset, represents a pressing challenge for the analysis and integration of multimodal datasets. In ( Hao*, Hao* et al, Cell 2021 ), we introduce ‘weighted-nearest neighbor’ (WNN) analysis, an unsupervised framework to learn the relative utility of each data type in each cell, enabling an integrative analysis of multiple modalities. This vignette introduces the WNN workflow for the analysis of multimodal single-cell datasets. The workflow consists of three steps Independent preprocessing and dimensional reduction of each modality individually Learning cell-specific modality ‘weights’, and constructing a WNN graph that integrates the modalities Downstream analysis (i.e. visualization, clustering, etc.) of the WNN graph We demonstrate the use of WNN analysis to two single-cell multimodal technologies: CITE-seq and 10x multiome. We define the cellular states based on both modalities, instead of either individual modality. WNN analysis of CITE-seq, RNA + ADT anchor We use the CITE-seq dataset from ( Stuart*, Butler* et al, Cell 2019 ), which consists of 30,672 scRNA-seq profiles measured alongside a panel of 25 antibodies from bone marrow. The object contains two assays, RNA and antibody-derived tags (ADT). To run this vignette please install SeuratData, available on GitHub . sourceCode R library(Seurat) library(SeuratData) library(cowplot) library(dplyr) sourceCode R InstallData(\"bmcite\") bm <- LoadData(ds = \"bmcite\") We first perform pre-processing and dimensional reduction on both assays independently. We use standard normalization, but you can also use SCTransform or any alternative method. ```sourceCode R DefaultAssay(bm) <- 'RNA' bm <- NormalizeData(bm) %>% FindVariableFeatures() %>% ScaleData() %>% RunPCA() DefaultAssay(bm) <- 'ADT' we will use all ADT features for dimensional reduction we set a dimensional reduction name to avoid overwriting the VariableFeatures(bm) <- rownames(bm[[\"ADT\"]]) bm <- NormalizeData(bm, normalization.method = 'CLR', margin = 2) %>% ScaleData() %>% RunPCA(reduction.name = 'apca') ``` For each cell, we calculate its closest neighbors in the dataset based on a weighted combination of RNA and protein similarities. The cell-specific modality weights and multimodal neighbors are calculated in a single function, which takes ~2 minutes to run on this dataset. We specify the dimensionality of each modality (similar to specifying the number of PCs to include in scRNA-seq clustering), but you can vary these settings to see that small changes have minimal effect on the overall results. ```sourceCode R Identify multimodal neighbors. These will be stored in the neighbors slot, and can be accessed using bm[['weighted.nn']] The WNN graph can be accessed at bm[[\"wknn\"]], and the SNN graph used for clustering at bm[[\"wsnn\"]] Cell-specific modality weights can be accessed at bm$RNA.weight bm <- FindMultiModalNeighbors( bm, reduction.list = list(\"pca\", \"apca\"), dims.list = list(1:30, 1:18), modality.weight.name = \"RNA.weight\" ) ``` We can now use these results for downstream analysis, such as visualization and clustering. For example, we can create a UMAP visualization of the data based on a weighted combination of RNA and protein data We can also perform graph-based clustering and visualize these results on the UMAP, alongside a set of cell annotations. sourceCode R bm <- RunUMAP(bm, nn.name = \"weighted.nn\", reduction.name = \"wnn.umap\", reduction.key = \"wnnUMAP_\") bm <- FindClusters(bm, graph.name = \"wsnn\", algorithm = 3, resolution = 2, verbose = FALSE) sourceCode R p1 <- DimPlot(bm, reduction = 'wnn.umap', label = TRUE, repel = TRUE, label.size = 2.5) + NoLegend() p2 <- DimPlot(bm, reduction = 'wnn.umap', group.by = 'celltype.l2', label = TRUE, repel = TRUE, label.size = 2.5) + NoLegend() p1 + p2 We can also compute UMAP visualization based on only the RNA and protein data and compare. We find that the RNA analysis is more informative than the ADT analysis in identifying progenitor states (the ADT panel contains markers for differentiated cells), while the converse is true of T cell states (where the ADT analysis outperforms RNA). sourceCode R bm <- RunUMAP(bm, reduction = 'pca', dims = 1:30, assay = 'RNA', reduction.name = 'rna.umap', reduction.key = 'rnaUMAP_') bm <- RunUMAP(bm, reduction = 'apca', dims = 1:18, assay = 'ADT', reduction.name = 'adt.umap', reduction.key = 'adtUMAP_') sourceCode R p3 <- DimPlot(bm, reduction = 'rna.umap', group.by = 'celltype.l2', label = TRUE, repel = TRUE, label.size = 2.5) + NoLegend() p4 <- DimPlot(bm, reduction = 'adt.umap', group.by = 'celltype.l2', label = TRUE, repel = TRUE, label.size = 2.5) + NoLegend() p3 + p4 We can visualize the expression of canonical marker genes and proteins on the multimodal UMAP, which can assist in verifying the provided annotations: sourceCode R p5 <- FeaturePlot(bm, features = c(\"adt_CD45RA\",\"adt_CD16\",\"adt_CD161\"), reduction = 'wnn.umap', max.cutoff = 2, cols = c(\"lightgrey\",\"darkgreen\"), ncol = 3) p6 <- FeaturePlot(bm, features = c(\"rna_TRDC\",\"rna_MPO\",\"rna_AVP\"), reduction = 'wnn.umap', max.cutoff = 3, ncol = 3) p5 / p6 Finally, we can visualize the modality weights that were learned for each cell. Each of the populations with the highest RNA weights represent progenitor cells, while the populations with the highest protein weights represent T cells. This is in line with our biological expectations, as the antibody panel does not contain markers that can distinguish between different progenitor populations. sourceCode R VlnPlot(bm, features = \"RNA.weight\", group.by = 'celltype.l2', sort = TRUE, pt.size = 0.1) + NoLegend() WNN analysis of 10x Multiome, RNA + ATAC anchor Here, we demonstrate the use of WNN analysis to a second multimodal technology, the 10x multiome RNA+ATAC kit. We use a dataset that is publicly available on the 10x website, where paired transcriptomes and ATAC-seq profiles are measured in 10,412 PBMCs. We use the same WNN methods as we use in the previous tab, where we apply integrated multimodal analysis to a CITE-seq dataset. In this example we will demonstrate how to: Create a multimodal Seurat object with paired transcriptome and ATAC-seq profiles Perform weighted neighbor clustering on RNA+ATAC data in single cells Leverage both modalities to identify putative regulators of different cell types and states You can download the dataset from the 10x Genomics website here . Please make sure to download the following files: Filtered feature barcode matrix (HDF5) ATAC Per fragment information file (TSV.GZ) ATAC Per fragment information index (TSV.GZ index) Finally, in order to run the vignette, make sure the following packages are installed: Seurat Signac for the analysis of single-cell chromatin datasets EnsDb.Hsapiens.v86 for a set of annotations for hg38 dplyr to help manipulate data tables sourceCode R library(Seurat) library(Signac) library(EnsDb.Hsapiens.v86) library(dplyr) library(ggplot2) We’ll create a Seurat object based on the gene expression data, and then add in the ATAC-seq data as a second assay. You can explore the Signac getting started vignette for more information on the creation and processing of a ChromatinAssay object. ```sourceCode R the 10x hdf5 file contains both data types. inputdata.10x <- Read10X_h5(\"../data/pbmc_granulocyte_sorted_10k_filtered_feature_bc_matrix.h5\") extract RNA and ATAC data rna_counts <- inputdata.10x$ Gene Expression atac_counts <- inputdata.10x$Peaks Create Seurat object pbmc <- CreateSeuratObject(counts = rna_counts) pbmc[[\"percent.mt\"]] <- PercentageFeatureSet(pbmc, pattern = \"^MT-\") Now add in the ATAC-seq data we'll only use peaks in standard chromosomes grange.counts <- StringToGRanges(rownames(atac_counts), sep = c(\":\", \"-\")) grange.use <- seqnames(grange.counts) %in% standardChromosomes(grange.counts) atac_counts <- atac_counts[as.vector(grange.use), ] annotations <- GetGRangesFromEnsDb(ensdb = EnsDb.Hsapiens.v86) seqlevelsStyle(annotations) <- 'UCSC' genome(annotations) <- \"hg38\" frag.file <- \"../data/pbmc_granulocyte_sorted_10k_atac_fragments.tsv.gz\" chrom_assay <- CreateChromatinAssay( counts = atac_counts, sep = c(\":\", \"-\"), genome = 'hg38', fragments = frag.file, min.cells = 10, annotation = annotations ) pbmc[[\"ATAC\"]] <- chrom_assay ``` We perform basic QC based on the number of detected molecules for each modality as well as mitochondrial percentage. sourceCode R VlnPlot(pbmc, features = c(\"nCount_ATAC\", \"nCount_RNA\", \"percent.mt\"), ncol = 3, log = TRUE, pt.size = 0) + NoLegend() sourceCode R pbmc <- subset( x = pbmc, subset = nCount_ATAC < 7e4 & nCount_ATAC > 5e3 & nCount_RNA < 25000 & nCount_RNA > 1000 & percent.mt < 20 ) We next perform pre-processing and dimensional reduction on both assays independently, using standard approaches for RNA and ATAC-seq data. ```sourceCode R RNA analysis DefaultAssay(pbmc) <- \"RNA\" pbmc <- SCTransform(pbmc, verbose = FALSE) %>% RunPCA() %>% RunUMAP(dims = 1:50, reduction.name = 'umap.rna', reduction.key = 'rnaUMAP_') ATAC analysis We exclude the first dimension as this is typically correlated with sequencing depth DefaultAssay(pbmc) <- \"ATAC\" pbmc <- RunTFIDF(pbmc) pbmc <- FindTopFeatures(pbmc, min.cutoff = 'q0') pbmc <- RunSVD(pbmc) pbmc <- RunUMAP(pbmc, reduction = 'lsi', dims = 2:50, reduction.name = \"umap.atac\", reduction.key = \"atacUMAP_\") ``` We calculate a WNN graph, representing a weighted combination of RNA and ATAC-seq modalities. We use this graph for UMAP visualization and clustering sourceCode R pbmc <- FindMultiModalNeighbors(pbmc, reduction.list = list(\"pca\", \"lsi\"), dims.list = list(1:50, 2:50)) pbmc <- RunUMAP(pbmc, nn.name = \"weighted.nn\", reduction.name = \"wnn.umap\", reduction.key = \"wnnUMAP_\") pbmc <- FindClusters(pbmc, graph.name = \"wsnn\", algorithm = 3, verbose = FALSE) We annotate the clusters below. Note that you could also annotate the dataset using our supervised mapping pipelines, using either our vignette , or automated web tool, Azimuth . ```sourceCode R perform sub-clustering on cluster 6 to find additional structure pbmc <- FindSubCluster(pbmc, cluster = 6, graph.name = \"wsnn\", algorithm = 3) Idents(pbmc) <- \"sub.cluster\" ``` ```sourceCode R add annotations pbmc <- RenameIdents(pbmc, '19' = 'pDC','20' = 'HSPC','15' = 'cDC') pbmc <- RenameIdents(pbmc, '0' = 'CD14 Mono', '9' ='CD14 Mono', '5' = 'CD16 Mono') pbmc <- RenameIdents(pbmc, '10' = 'Naive B', '11' = 'Intermediate B', '17' = 'Memory B', '21' = 'Plasma') pbmc <- RenameIdents(pbmc, '7' = 'NK') pbmc <- RenameIdents(pbmc, '4' = 'CD4 TCM', '13'= \"CD4 TEM\", '3' = \"CD4 TCM\", '16' =\"Treg\", '1' =\"CD4 Naive\", '14' = \"CD4 Naive\") pbmc <- RenameIdents(pbmc, '2' = 'CD8 Naive', '8'= \"CD8 Naive\", '12' = 'CD8 TEM_1', '6_0' = 'CD8 TEM_2', '6_1' ='CD8 TEM_2', '6_4' ='CD8 TEM_2') pbmc <- RenameIdents(pbmc, '18' = 'MAIT') pbmc <- RenameIdents(pbmc, '6_2' ='gdT', '6_3' = 'gdT') pbmc$celltype <- Idents(pbmc) ``` We can visualize clustering based on gene expression, ATAC-seq, or WNN analysis. The differences are more subtle than in the previous analysis (you can explore the weights, which are more evenly split than in our CITE-seq example), but we find that WNN provides the clearest separation of cell states. sourceCode R p1 <- DimPlot(pbmc, reduction = \"umap.rna\", group.by = \"celltype\", label = TRUE, label.size = 2.5, repel = TRUE) + ggtitle(\"RNA\") p2 <- DimPlot(pbmc, reduction = \"umap.atac\", group.by = \"celltype\", label = TRUE, label.size = 2.5, repel = TRUE) + ggtitle(\"ATAC\") p3 <- DimPlot(pbmc, reduction = \"wnn.umap\", group.by = \"celltype\", label = TRUE, label.size = 2.5, repel = TRUE) + ggtitle(\"WNN\") p1 + p2 + p3 & NoLegend() & theme(plot.title = element_text(hjust = 0.5)) For example, the ATAC-seq data assists in the separation of CD4 and CD8 T cell states. This is due to the presence of multiple loci that exhibit differential accessibility between different T cell subtypes. For example, we can visualize ‘pseudobulk’ tracks of the CD8A locus alongside violin plots of gene expression levels, using tools in the Signac visualization vignette . ```sourceCode R to make the visualization easier, subset T cell clusters celltype.names <- levels(pbmc) tcell.names <- grep(\"CD4|CD8|Treg\", celltype.names,value = TRUE) tcells <- subset(pbmc, idents = tcell.names) CoveragePlot(tcells, region = 'CD8A', features = 'CD8A', assay = 'ATAC', expression.assay = 'SCT', peaks = FALSE) ``` Next, we will examine the accessible regions of each cell to determine enriched motifs. As described in the Signac motifs vignette , there are a few ways to do this, but we will use the chromVAR package from the Greenleaf lab. This calculates a per-cell accessibility score for known motifs, and adds these scores as a third assay ( chromvar ) in the Seurat object. To continue, please make sure you have the following packages installed. chromVAR for the analysis of motif accessibility in scATAC-seq presto for fast differential expression analyses. TFBSTools for TFBS analysis JASPAR2020 for JASPAR motif models motifmatchr for motif matching BSgenome.Hsapiens.UCSC.hg38 for chromVAR Install command for all dependencies sourceCode R remotes::install_github(\"immunogenomics/presto\") BiocManager::install(c(\"chromVAR\", \"TFBSTools\", \"JASPAR2020\", \"motifmatchr\", \"BSgenome.Hsapiens.UCSC.hg38\")) ```sourceCode R library(chromVAR) library(JASPAR2020) library(TFBSTools) library(motifmatchr) library(BSgenome.Hsapiens.UCSC.hg38) Scan the DNA sequence of each peak for the presence of each motif, and create a Motif object DefaultAssay(pbmc) <- \"ATAC\" pwm_set <- getMatrixSet(x = JASPAR2020, opts = list(species = 9606, all_versions = FALSE)) motif.matrix <- CreateMotifMatrix(features = granges(pbmc), pwm = pwm_set, genome = 'hg38', use.counts = FALSE) motif.object <- CreateMotifObject(data = motif.matrix, pwm = pwm_set) pbmc <- SetAssayData(pbmc, assay = 'ATAC', slot = 'motifs', new.data = motif.object) Note that this step can take 30-60 minutes pbmc <- RunChromVAR( object = pbmc, genome = BSgenome.Hsapiens.UCSC.hg38 ) ``` Finally, we explore the multimodal dataset to identify key regulators of each cell state. Paired data provides a unique opportunity to identify transcription factors (TFs) that satisfy multiple criteria, helping to narrow down the list of putative regulators to the most likely candidates. We aim to identify TFs whose expression is enriched in multiple cell types in the RNA measurements, but also have enriched accessibility for their motifs in the ATAC measurements. As an example and positive control, the CCAAT Enhancer Binding Protein (CEBP) family of proteins, including the TF CEBPB, have been repeatedly shown to play important roles in the differentiation and function of myeloid cells including monocytes and dendritic cells. We can see that both the expression of the CEBPB, and the accessibility of the MA0466.2.4 motif (which encodes the binding site for CEBPB), are both enriched in monocytes. ```sourceCode R returns MA0466.2 motif.name <- ConvertMotifID(pbmc, name = 'CEBPB') gene_plot <- FeaturePlot(pbmc, features = \"sct_CEBPB\", reduction = 'wnn.umap') motif_plot <- FeaturePlot(pbmc, features = motif.name, min.cutoff = 0, cols = c(\"lightgrey\", \"darkred\"), reduction = 'wnn.umap') gene_plot | motif_plot ``` We’d like to quantify this relationship, and search across all cell types to find similar examples. To do so, we will use the presto package to perform fast differential expression. We run two tests: one using gene expression data, and the other using chromVAR motif accessibilities. presto calculates a p-value based on the Wilcox rank sum test, which is also the default test in Seurat, and we restrict our search to TFs that return significant results in both tests. presto also calculates an “AUC” statistic, which reflects the power of each gene (or motif) to serve as a marker of cell type. A maximum AUC value of 1 indicates a perfect marker. Since the AUC statistic is on the same scale for both genes and motifs, we take the average of the AUC values from the two tests, and use this to rank TFs for each cell type: sourceCode R markers_rna <- presto:::wilcoxauc.Seurat(X = pbmc, group_by = 'celltype', assay = 'data', seurat_assay = 'SCT') markers_motifs <- presto:::wilcoxauc.Seurat(X = pbmc, group_by = 'celltype', assay = 'data', seurat_assay = 'chromvar') motif.names <- markers_motifs$feature colnames(markers_rna) <- paste0(\"RNA.\", colnames(markers_rna)) colnames(markers_motifs) <- paste0(\"motif.\", colnames(markers_motifs)) markers_rna$gene <- markers_rna$RNA.feature markers_motifs$gene <- ConvertMotifID(pbmc, id = motif.names) ```sourceCode R a simple function to implement the procedure above topTFs <- function(celltype, padj.cutoff = 1e-2) { ctmarkers_rna <- dplyr::filter( markers_rna, RNA.group == celltype, RNA.padj < padj.cutoff, RNA.logFC > 0) %>% arrange(-RNA.auc) ctmarkers_motif <- dplyr::filter( markers_motifs, motif.group == celltype, motif.padj < padj.cutoff, motif.logFC > 0) %>% arrange(-motif.auc) top_tfs <- inner_join( x = ctmarkers_rna[, c(2, 11, 6, 7)], y = ctmarkers_motif[, c(2, 1, 11, 6, 7)], by = \"gene\" ) top_tfs$avg_auc <- (top_tfs$RNA.auc + top_tfs$motif.auc) / 2 top_tfs <- arrange(top_tfs, -avg_auc) return(top_tfs) } ``` We can now compute, and visualize, putative regulators for any cell type. We recover well-established regulators, including TBX21 for NK cells , IRF4 for plasma cells , SOX4 for hematopoietic progenitors , EBF1 and PAX5 for B cells , IRF8 and TCF4 for pDC . We believe that similar strategies can be used to help focus on a set of putative regulators in diverse systems. ```sourceCode R identify top markers in NK and visualize head(topTFs(\"NK\"), 3) ``` ``` RNA.group gene RNA.auc RNA.pval motif.group motif.feature motif.auc 1 NK TBX21 0.7254543 0.000000e+00 NK MA0690.1 0.9161365 2 NK EOMES 0.5889408 5.394245e-99 NK MA0800.1 0.9239066 3 NK RUNX3 0.7705554 1.256004e-119 NK MA0684.2 0.6813549 motif.pval avg_auc 1 2.177841e-204 0.8207954 2 5.165634e-212 0.7564237 3 2.486287e-40 0.7259552 ``` sourceCode R motif.name <- ConvertMotifID(pbmc, name = 'TBX21') gene_plot <- FeaturePlot(pbmc, features = \"sct_TBX21\", reduction = 'wnn.umap') motif_plot <- FeaturePlot(pbmc, features = motif.name, min.cutoff = 0, cols = c(\"lightgrey\", \"darkred\"), reduction = 'wnn.umap') gene_plot | motif_plot ```sourceCode R identify top markers in pDC and visualize head(topTFs(\"pDC\"), 3) ``` ``` RNA.group gene RNA.auc RNA.pval motif.group motif.feature motif.auc 1 pDC TCF4 0.9998773 1.881543e-162 pDC MA0830.2 0.9965481 2 pDC IRF8 0.9907541 1.197641e-123 pDC MA0652.1 0.8833112 3 pDC SPIB 0.9113825 0.000000e+00 pDC MA0081.2 0.9068540 motif.pval avg_auc 1 1.785897e-69 0.9982127 2 3.982413e-42 0.9370327 3 3.083509e-47 0.9091182 ``` sourceCode R motif.name <- ConvertMotifID(pbmc, name = 'TCF4') gene_plot <- FeaturePlot(pbmc, features = \"sct_TCF4\", reduction = 'wnn.umap') motif_plot <- FeaturePlot(pbmc, features = motif.name, min.cutoff = 0, cols = c(\"lightgrey\", \"darkred\"), reduction = 'wnn.umap') gene_plot | motif_plot ```sourceCode R identify top markers in HSPC and visualize head(topTFs(\"CD16 Mono\"),3) ``` ``` RNA.group gene RNA.auc RNA.pval motif.group motif.feature motif.auc 1 CD16 Mono TCF7 0.6229004 5.572097e-27 CD16 Mono MA0769.2 0.6956458 2 CD16 Mono LEF1 0.6244160 1.959810e-27 CD16 Mono MA0768.1 0.6427922 3 CD16 Mono GATA3 0.6853318 1.575081e-132 CD16 Mono MA0037.3 0.5622475 motif.pval avg_auc 1 8.605682e-54 0.6592731 2 1.845888e-29 0.6336041 3 8.972511e-07 0.6237897 ``` sourceCode R motif.name <- ConvertMotifID(pbmc, name = 'SPI1') gene_plot <- FeaturePlot(pbmc, features = \"sct_SPI1\", reduction = 'wnn.umap') motif_plot <- FeaturePlot(pbmc, features = motif.name, min.cutoff = 0, cols = c(\"lightgrey\", \"darkred\"), reduction = 'wnn.umap') gene_plot | motif_plot ```sourceCode R identify top markers in other cell types head(topTFs(\"Naive B\"), 3) ``` ``` RNA.group gene RNA.auc RNA.pval motif.group motif.feature motif.auc 1 Naive B TCF4 0.8350167 8.961289e-239 Naive B MA0830.2 0.9066328 2 Naive B POU2F2 0.6969289 9.622025e-43 Naive B MA0507.1 0.9740857 3 Naive B EBF1 0.9114260 0.000000e+00 Naive B MA0154.4 0.7565424 motif.pval avg_auc 1 8.987390e-151 0.8708247 2 3.336610e-204 0.8355073 3 3.662535e-61 0.8339842 ``` sourceCode R head(topTFs(\"HSPC\"), 3) ``` RNA.group gene RNA.auc RNA.pval motif.group motif.feature motif.auc 1 HSPC SOX4 0.9864425 2.831723e-71 HSPC MA0867.2 0.6830497 2 HSPC GATA2 0.7115385 0.000000e+00 HSPC MA0036.3 0.8275008 3 HSPC MEIS1 0.8254177 0.000000e+00 HSPC MA0498.2 0.6924225 motif.pval avg_auc 1 1.241915e-03 0.8347461 2 7.591798e-09 0.7695196 3 6.877492e-04 0.7589201 ``` sourceCode R head(topTFs(\"Plasma\"), 3) ``` RNA.group gene RNA.auc RNA.pval motif.group motif.feature motif.auc 1 Plasma IRF4 0.8189420 5.329976e-35 Plasma MA1419.1 0.9776046 2 Plasma MEF2C 0.9108487 3.135227e-12 Plasma MA0497.1 0.7596637 3 Plasma TCF4 0.8306796 1.041100e-13 Plasma MA0830.2 0.7840848 motif.pval avg_auc 1 2.334627e-12 0.8982733 2 1.374353e-04 0.8352562 3 3.028306e-05 0.8073822 ``` Session Info sourceCode R sessionInfo() ``` R version 4.2.2 Patched (2022-11-10 r83330) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.6 LTS Matrix products: default BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats4 stats graphics grDevices utils datasets methods [8] base other attached packages: [1] BSgenome.Hsapiens.UCSC.hg38_1.4.5 BSgenome_1.66.3 [3] rtracklayer_1.58.0 Biostrings_2.66.0 [5] XVector_0.38.0 motifmatchr_1.20.0 [7] TFBSTools_1.36.0 JASPAR2020_0.99.10 [9] chromVAR_1.20.2 EnsDb.Hsapiens.v86_2.99.0 [11] ensembldb_2.22.0 AnnotationFilter_1.22.0 [13] GenomicFeatures_1.50.4 AnnotationDbi_1.60.2 [15] Biobase_2.58.0 GenomicRanges_1.50.2 [17] GenomeInfoDb_1.34.9 IRanges_2.32.0 [19] S4Vectors_0.36.2 BiocGenerics_0.44.0 [21] Signac_1.12.9000 ggplot2_3.4.4 [23] dplyr_1.1.3 cowplot_1.1.1 [25] thp1.eccite.SeuratData_3.1.5 stxBrain.SeuratData_0.1.1 [27] ssHippo.SeuratData_3.1.4 pbmcsca.SeuratData_3.0.0 [29] pbmcref.SeuratData_1.0.0 pbmcMultiome.SeuratData_0.1.4 [31] pbmc3k.SeuratData_3.1.4 panc8.SeuratData_3.0.2 [33] ifnb.SeuratData_3.0.0 hcabm40k.SeuratData_3.0.0 [35] cbmc.SeuratData_3.1.4 bmcite.SeuratData_0.3.0 [37] SeuratData_0.2.2.9001 Seurat_5.0.0 [39] SeuratObject_5.0.0 sp_2.1-1 loaded via a namespace (and not attached): [1] rappdirs_0.3.3 scattermore_1.2 [3] R.methodsS3_1.8.2 ragg_1.2.5 [5] nabor_0.5.0 tidyr_1.3.0 [7] bit64_4.0.5 knitr_1.45 [9] R.utils_2.12.2 irlba_2.3.5.1 [11] DelayedArray_0.24.0 rpart_4.1.19 [13] data.table_1.14.8 KEGGREST_1.38.0 [15] RCurl_1.98-1.12 generics_0.1.3 [17] RSQLite_2.3.1 RANN_2.6.1 [19] future_1.33.0 tzdb_0.4.0 [21] bit_4.0.5 spatstat.data_3.0-3 [23] xml2_1.3.5 httpuv_1.6.12 [25] SummarizedExperiment_1.28.0 DirichletMultinomial_1.40.0 [27] xfun_0.40 hms_1.1.3 [29] jquerylib_0.1.4 evaluate_0.22 [31] promises_1.2.1 fansi_1.0.5 [33] restfulr_0.0.15 progress_1.2.2 [35] caTools_1.18.2 dbplyr_2.3.4 [37] igraph_1.5.1 DBI_1.1.3 [39] htmlwidgets_1.6.2 spatstat.geom_3.2-7 [41] purrr_1.0.2 ellipsis_0.3.2 [43] RSpectra_0.16-1 backports_1.4.1 [45] annotate_1.76.0 sparseMatrixStats_1.10.0 [47] biomaRt_2.54.1 deldir_1.0-9 [49] MatrixGenerics_1.10.0 vctrs_0.6.4 [51] ROCR_1.0-11 abind_1.4-5 [53] cachem_1.0.8 withr_2.5.2 [55] progressr_0.14.0 presto_1.0.0 [57] checkmate_2.2.0 sctransform_0.4.1 [59] GenomicAlignments_1.34.1 prettyunits_1.1.1 [61] goftest_1.2-3 cluster_2.1.4 [63] seqLogo_1.64.0 dotCall64_1.1-0 [65] lazyeval_0.2.2 crayon_1.5.2 [67] hdf5r_1.3.8 spatstat.explore_3.2-5 [69] pkgconfig_2.0.3 labeling_0.4.3 [71] nlme_3.1-162 vipor_0.4.5 [73] ProtGenerics_1.30.0 nnet_7.3-18 [75] rlang_1.1.1 globals_0.16.2 [77] lifecycle_1.0.3 miniUI_0.1.1.1 [79] filelock_1.0.2 fastDummies_1.7.3 [81] BiocFileCache_2.6.1 dichromat_2.0-0.1 [83] ggrastr_1.0.1 rprojroot_2.0.3 [85] polyclip_1.10-6 RcppHNSW_0.5.0 [87] matrixStats_1.0.0 lmtest_0.9-40 [89] Matrix_1.6-1.1 zoo_1.8-12 [91] base64enc_0.1-3 beeswarm_0.4.0 [93] ggridges_0.5.4 png_0.1-8 [95] viridisLite_0.4.2 rjson_0.2.21 [97] bitops_1.0-7 R.oo_1.25.0 [99] KernSmooth_2.23-22 spam_2.10-0 [101] DelayedMatrixStats_1.20.0 blob_1.2.4 [103] stringr_1.5.0 parallelly_1.36.0 [105] spatstat.random_3.2-1 readr_2.1.4 [107] CNEr_1.34.0 scales_1.2.1 [109] memoise_2.0.1 magrittr_2.0.3 [111] plyr_1.8.9 ica_1.0-3 [113] zlibbioc_1.44.0 compiler_4.2.2 [115] BiocIO_1.8.0 RColorBrewer_1.1-3 [117] fitdistrplus_1.1-11 Rsamtools_2.14.0 [119] cli_3.6.1 listenv_0.9.0 [121] patchwork_1.1.3 pbapply_1.7-2 [123] htmlTable_2.4.1 Formula_1.2-5 [125] MASS_7.3-58.2 tidyselect_1.2.0 [127] stringi_1.7.12 glmGamPoi_1.10.2 [129] textshaping_0.3.6 highr_0.10 [131] yaml_2.3.7 ggrepel_0.9.4 [133] grid_4.2.2 VariantAnnotation_1.44.1 [135] sass_0.4.7 fastmatch_1.1-4 [137] tools_4.2.2 future.apply_1.11.0 [139] parallel_4.2.2 rstudioapi_0.14 [141] TFMPvalue_0.0.9 foreign_0.8-84 [143] gridExtra_2.3 farver_2.1.1 [145] Rtsne_0.16 digest_0.6.33 [147] pracma_2.4.2 shiny_1.7.5.1 [149] Rcpp_1.0.11 later_1.3.1 [151] RcppAnnoy_0.0.21 httr_1.4.7 [153] biovizBase_1.46.0 colorspace_2.1-0 [155] XML_3.99-0.14 fs_1.6.3 [157] tensor_1.5 reticulate_1.34.0 [159] splines_4.2.2 uwot_0.1.16 [161] RcppRoll_0.3.0 spatstat.utils_3.0-4 [163] pkgdown_2.0.7 plotly_4.10.3 [165] systemfonts_1.0.4 xtable_1.8-4 [167] poweRlaw_0.70.6 jsonlite_1.8.7 [169] R6_2.5.1 Hmisc_5.1-1 [171] pillar_1.9.0 htmltools_0.5.6.1 [173] mime_0.12 DT_0.30 [175] glue_1.6.2 fastmap_1.1.1 [177] BiocParallel_1.32.6 codetools_0.2-19 [179] utf8_1.2.4 lattice_0.21-9 [181] bslib_0.5.1 spatstat.sparse_3.0-3 [183] tibble_3.2.1 curl_5.1.0 [185] ggbeeswarm_0.7.1 leiden_0.4.3 [187] gtools_3.9.4 GO.db_3.16.0 [189] survival_3.5-7 rmarkdown_2.25 [191] desc_1.4.2 munsell_0.5.0 [193] GenomeInfoDbData_1.2.9 reshape2_1.4.4 [195] gtable_0.3.4 ```",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/weighted_nearest_neighbor_analysis",
      "title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat • Seurat",
      "ogTitle": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "language": "en",
      "og:title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "scrapeId": "3c3ee838-403a-40a3-8be4-a48fbc7430d8",
      "viewport": "width=device-width, initial-scale=1.0",
      "sourceURL": "https://satijalab.org/seurat/articles/weighted_nearest_neighbor_analysis",
      "statusCode": 200,
      "ogDescription": "Seurat",
      "og:description": "Seurat"
    }
  },
  {
    "processed_text": "",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/seurat5_visualization_vignette.html",
      "error": "Not Found",
      "scrapeId": "4fd9b5cf-bc9b-468f-93e2-76170896a03b",
      "sourceURL": "https://satijalab.org/seurat/articles/seurat5_visualization_vignette.html",
      "statusCode": 404
    }
  },
  {
    "processed_text": "",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/spatial_vignette_2.html",
      "error": "Not Found",
      "scrapeId": "537101f0-7425-494b-9e71-0901682525bc",
      "sourceURL": "https://satijalab.org/seurat/articles/spatial_vignette_2.html",
      "statusCode": 404
    }
  },
  {
    "processed_text": "",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/seurat5_weighted_nearest_neighbor_analysis.html",
      "error": "Not Found",
      "scrapeId": "5c024bd3-805e-4413-a38f-c33dd7e81e27",
      "sourceURL": "https://satijalab.org/seurat/articles/seurat5_weighted_nearest_neighbor_analysis.html",
      "statusCode": 404
    }
  },
  {
    "processed_text": "Dictionary Learning for cross-modality integration Compiled: October 31, 2023 Source: vignettes/seurat5_integration_bridge.Rmd seurat5_integration_bridge.Rmd In the same way that read mapping tools have transformed genome sequence analysis, the ability to map new datasets to established references represents an exciting opportunity for the field of single-cell genomics. Along with others in the community, we have developed tools to map and interpret query datasets , and have also constructed a set of scRNA-seq datasets for diverse mammalian tissues . A key challenge is to extend this reference mapping framework to technologies that do not measure gene expression, even if the underlying reference is based on scRNA-seq. In Hao et al, Nat Biotechnol 2023 , we introduce ‘bridge integration’, which enables the mapping of complementary technologies (like scATAC-seq, scDNAme, CyTOF), onto scRNA-seq references, using a ‘multi-omic’ dataset as a molecular bridge. In this vignette, we demonstrate how to map an scATAC-seq dataset of human PBMC, onto our previously constructed PBMC reference . We use a publicly available 10x multiome dataset, which simultaneously measures gene expression and chromatin accessibility in the same cell, as a bridge dataset. In this vignette we demonstrate: Loading in and pre-processing the scATAC-seq, multiome, and scRNA-seq reference datasets Mapping the scATAC-seq dataset via bridge integration Exploring and assessing the resulting annotations Azimuth ATAC for Bridge Integration anchor Users can now automatically run bridge integration for PBMC and Bone Marrow scATAC-seq queries with the newly released Azimuth ATAC workflow on the Azimuth website or in R. For more details on running locally in R, see the section on ATAC data in this vignette . sourceCode R library(Seurat) library(Signac) library(EnsDb.Hsapiens.v86) library(dplyr) library(ggplot2) Load the bridge, query, and reference datasets anchor We start by loading a 10x multiome dataset, consisting of ~12,000 PBMC from a healthy donor. The dataset measures RNA-seq and ATAC-seq in the same cell, and is available for download from 10x Genomics here . We follow the loading instructions from the Signac package vignettes . Note that when using Signac, please make sure you are using the latest version of Bioconductor , as users have reported errors when using older BioC versions. Load and setup the 10x multiome object ```sourceCode R the 10x hdf5 file contains both data types. inputdata.10x <- Read10X_h5(\"/brahms/hartmana/vignette_data/pbmc_cellranger_arc_2/pbmc_granulocyte_sorted_10k_filtered_feature_bc_matrix.h5\") extract RNA and ATAC data rna_counts <- inputdata.10x$ Gene Expression atac_counts <- inputdata.10x$Peaks Create Seurat object obj.multi <- CreateSeuratObject(counts = rna_counts) Get % of mitochondrial genes obj.multi[[\"percent.mt\"]] <- PercentageFeatureSet(obj.multi, pattern = \"^MT-\") add the ATAC-seq assay grange.counts <- StringToGRanges(rownames(atac_counts), sep = c(\":\", \"-\")) grange.use <- seqnames(grange.counts) %in% standardChromosomes(grange.counts) atac_counts <- atac_counts[as.vector(grange.use), ] Get gene annotations annotations <- GetGRangesFromEnsDb(ensdb = EnsDb.Hsapiens.v86) Change style to UCSC seqlevelsStyle(annotations) <- 'UCSC' genome(annotations) <- \"hg38\" File with ATAC per fragment information file frag.file <- \"/brahms/hartmana/vignette_data/pbmc_cellranger_arc_2/pbmc_granulocyte_sorted_10k_atac_fragments.tsv.gz\" Add in ATAC-seq data as ChromatinAssay object chrom_assay <- CreateChromatinAssay( counts = atac_counts, sep = c(\":\", \"-\"), genome = 'hg38', fragments = frag.file, min.cells = 10, annotation = annotations ) Add the ATAC assay to the multiome object obj.multi[[\"ATAC\"]] <- chrom_assay Filter ATAC data based on QC metrics obj.multi <- subset( x = obj.multi, subset = nCount_ATAC < 7e4 & nCount_ATAC > 5e3 & nCount_RNA < 25000 & nCount_RNA > 1000 & percent.mt < 20 ) ``` The scATAC-seq query dataset represents ~10,000 PBMC from a healthy donor, and is available for download here . We load in the peak/cell matrix, store the path to the fragments file, and add gene annotations to the object, following the steps as with the ATAC data in the multiome experiment. We note that it is important to quantify the same set of genomic features in the query dataset as are quantified in the multi-omic bridge. We therefore requantify the set of scATAC-seq peaks using the FeatureMatrix command. This is also described in the Signac vignettes and shown below. Load and setup the 10x scATAC-seq query ```sourceCode R Load ATAC dataset atac_pbmc_data <- Read10X_h5(filename = \"/brahms/hartmana/vignette_data/10k_PBMC_ATAC_nextgem_Chromium_X_filtered_peak_bc_matrix.h5\") fragpath <- \"/brahms/hartmana/vignette_data/10k_PBMC_ATAC_nextgem_Chromium_X_fragments.tsv.gz\" Get gene annotations annotation <- GetGRangesFromEnsDb(ensdb = EnsDb.Hsapiens.v86) Change to UCSC style seqlevelsStyle(annotation) <- 'UCSC' Create ChromatinAssay for ATAC data atac_pbmc_assay <- CreateChromatinAssay( counts = atac_pbmc_data, sep = c(\":\", \"-\"), fragments = fragpath, annotation = annotation ) Requantify query ATAC to have same features as multiome ATAC dataset requant_multiome_ATAC <- FeatureMatrix( fragments = Fragments(atac_pbmc_assay), features = granges(obj.multi[['ATAC']]), cells = Cells(atac_pbmc_assay) ) Create assay with requantified ATAC data ATAC_assay <- CreateChromatinAssay( counts = requant_multiome_ATAC, fragments = fragpath, annotation = annotation ) Create Seurat sbject obj.atac <- CreateSeuratObject(counts = ATAC_assay,assay = 'ATAC') obj.atac[['peak.orig']] <- atac_pbmc_assay obj.atac <- subset(obj.atac, subset = nCount_ATAC < 7e4 & nCount_ATAC > 2000) ``` We load the reference (download here ) from our recent paper . This reference is stored as an h5Seurat file, a format that enables on-disk storage of multimodal Seurat objects (more details on h5Seurat and SeuratDisk can be found here ). sourceCode R obj.rna <- readRDS(\"/brahms/haoy/seurat4_pbmc/pbmc_multimodal_2023.rds\") What if I want to use my own reference dataset? As an alternative to using a pre-built reference, you can also use your own reference. To demonstrate, you can download a scRNA-seq dataset of 23,837 human PBMC here , which we have already annotated. sourceCode R obj.rna = readRDS(\"/path/to/reference.rds\") obj.rna = SCTransform(object = obj.rna) %>% RunPCA() %>% RunUMAP(dims = 1:50, return.model = TRUE) When using your own reference, set reference.reduction = \"pca\" in the PrepareBridgeReference function. Preprocessing/normalization for all datasets anchor Prior to performing bridge integration, we normalize and pre-process each of the datasets (note that the reference has already been normalized). We normalize gene expression data using sctransform , and ATAC data using TF-IDF. ```sourceCode R normalize multiome RNA DefaultAssay(obj.multi) <- \"RNA\" obj.multi <- SCTransform(obj.multi, verbose = FALSE) normalize multiome ATAC DefaultAssay(obj.multi) <- \"ATAC\" obj.multi <- RunTFIDF(obj.multi) obj.multi <- FindTopFeatures(obj.multi, min.cutoff = \"q0\") normalize query obj.atac <- RunTFIDF(obj.atac) ``` Map scATAC-seq dataset using bridge integration anchor Now that we have the reference, query, and bridge datasets set up, we can begin integration. The bridge dataset enables translation between the scRNA-seq reference and the scATAC-seq query, effectively augmenting the reference so that it can map a new data type. We call this an extended reference, and first set it up. Note that you can save the results of this function and map multiple scATAC-seq datasets without having to rerun. First, we drop the first dimension of the ATAC reduction. sourceCode R dims.atac <- 2:50 dims.rna <- 1:50 DefaultAssay(obj.multi) <- \"RNA\" DefaultAssay(obj.rna) <- \"SCT\" obj.rna.ext <- PrepareBridgeReference( reference = obj.rna, bridge = obj.multi, reference.reduction = \"spca\", reference.dims = dims.rna, normalization.method = \"SCT\") Now, we can directly find anchors between the extended reference and query objects. We use the FindBridgeTransferAnchors function, which translates the query dataset using the same dictionary as was used to translate the reference, and then identifies anchors in this space. The function is meant to mimic our FindTransferAnchors function, but to identify correspondences across modalities. sourceCode R bridge.anchor <- FindBridgeTransferAnchors( extended.reference = obj.rna.ext, query = obj.atac, reduction = \"lsiproject\", dims = dims.atac) Once we have identified anchors, we can map the query dataset onto the reference. The MapQuery function is the same as we have previously introduced for reference mapping . It transfers cell annotations from the reference dataset, and also visualizes the query dataset on a previously computed UMAP embedding. Since our reference dataset contains cell type annotations at three levels of resolution (l1 - l3), we can transfer each level to the query dataset. sourceCode R obj.atac <- MapQuery( anchorset = bridge.anchor, reference = obj.rna.ext, query = obj.atac, refdata = list( l1 = \"celltype.l1\", l2 = \"celltype.l2\", l3 = \"celltype.l3\"), reduction.model = \"wnn.umap\") Now we can visualize the results, plotting the scATAC-seq cells based on their predicted annotations, on the reference UMAP embedding. You can see that each scATAC-seq cell has been assigned a cell name based on the scRNA-seq defined cell ontology. sourceCode R DimPlot( obj.atac, group.by = \"predicted.l2\", reduction = \"ref.umap\", label = TRUE ) + ggtitle(\"ATAC\") + NoLegend() Assessing the mapping anchor To assess the mapping and cell type predictions, we will first see if the predicted cell type labels are concordant with an unsupervised analysis of the scATAC-seq dataset. We follow the standard unsupervised processing workflow for scATAC-seq data: sourceCode R obj.atac <- FindTopFeatures(obj.atac, min.cutoff = \"q0\") obj.atac <- RunSVD(obj.atac) obj.atac <- RunUMAP(obj.atac, reduction = \"lsi\", dims = 2:50) Now, we visualize the predicted cluster labels on the unsupervised UMAP emebdding. We can see that predicted cluster labels (from the scRNA-seq reference) are concordant with the structure of the scATAC-seq data. However, there are some cell types (i.e. Treg), that do not appear to separate in unsupervised analysis. These may be prediction errors, or cases where the reference mapping provides additional resolution. sourceCode R DimPlot(obj.atac, group.by = \"predicted.l2\", reduction = \"umap\", label = FALSE) Lastly, we validate the predicted cell types for the scATAC-seq data by examining their chromatin accessibility profiles at canonical loci. We use the CoveragePlot function to visualize accessibility patterns at the CD8A, FOXP3, and RORC, after grouping cells by their predicted labels. We see expected patterns in each case. For example, the PAX5 locus exhibits peaks that are accessible exclusively in B cells, and the CD8A locus shows the same in CD8 T cell subsets. Similarly, the accessibility of FOXP3, a canonical marker of regulatory T cells (Tregs), in predicted Tregs provides strong support for the accuracy of our prediction. sourceCode R CoveragePlot( obj.atac, region = \"PAX5\", group.by = \"predicted.l1\", idents = c(\"B\", \"CD4 T\", \"Mono\", \"NK\"), window = 200, extend.upstream = -150000) sourceCode R CoveragePlot( obj.atac, region = \"CD8A\", group.by = \"predicted.l2\", idents = c(\"CD8 Naive\", \"CD4 Naive\", \"CD4 TCM\", \"CD8 TCM\"), extend.downstream = 5000, extend.upstream = 5000) sourceCode R CoveragePlot( obj.atac, region = \"FOXP3\", group.by = \"predicted.l2\", idents = c( \"CD4 Naive\", \"CD4 TCM\", \"CD4 TEM\", \"Treg\"), extend.downstream = 0, extend.upstream = 0) sourceCode R CoveragePlot( obj.atac, region = \"RORC\", group.by = \"predicted.l2\", idents = c(\"CD8 Naive\", \"CD8 TEM\", \"CD8 TCM\", \"MAIT\"), extend.downstream = 5000, extend.upstream = 5000) Session Info sourceCode R sessionInfo() ``` R version 4.2.2 Patched (2022-11-10 r83330) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.6 LTS Matrix products: default BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats4 stats graphics grDevices utils datasets methods [8] base other attached packages: [1] ggplot2_3.4.4 dplyr_1.1.3 [3] EnsDb.Hsapiens.v86_2.99.0 ensembldb_2.22.0 [5] AnnotationFilter_1.22.0 GenomicFeatures_1.50.4 [7] AnnotationDbi_1.60.2 Biobase_2.58.0 [9] GenomicRanges_1.50.2 GenomeInfoDb_1.34.9 [11] IRanges_2.32.0 S4Vectors_0.36.2 [13] BiocGenerics_0.44.0 Signac_1.12.9000 [15] Seurat_5.0.0 SeuratObject_5.0.0 [17] sp_2.1-1 loaded via a namespace (and not attached): [1] rappdirs_0.3.3 rtracklayer_1.58.0 [3] scattermore_1.2 R.methodsS3_1.8.2 [5] ragg_1.2.5 tidyr_1.3.0 [7] bit64_4.0.5 knitr_1.45 [9] irlba_2.3.5.1 DelayedArray_0.24.0 [11] R.utils_2.12.2 styler_1.10.2 [13] data.table_1.14.8 rpart_4.1.19 [15] KEGGREST_1.38.0 RCurl_1.98-1.12 [17] generics_0.1.3 cowplot_1.1.1 [19] RSQLite_2.3.1 RANN_2.6.1 [21] future_1.33.0 bit_4.0.5 [23] spatstat.data_3.0-3 xml2_1.3.5 [25] httpuv_1.6.12 SummarizedExperiment_1.28.0 [27] xfun_0.40 hms_1.1.3 [29] jquerylib_0.1.4 evaluate_0.22 [31] promises_1.2.1 fansi_1.0.5 [33] restfulr_0.0.15 progress_1.2.2 [35] dbplyr_2.3.4 igraph_1.5.1 [37] DBI_1.1.3 htmlwidgets_1.6.2 [39] spatstat.geom_3.2-7 purrr_1.0.2 [41] ellipsis_0.3.2 RSpectra_0.16-1 [43] backports_1.4.1 biomaRt_2.54.1 [45] deldir_1.0-9 sparseMatrixStats_1.10.0 [47] MatrixGenerics_1.10.0 vctrs_0.6.4 [49] ROCR_1.0-11 abind_1.4-5 [51] cachem_1.0.8 withr_2.5.2 [53] BSgenome_1.66.3 progressr_0.14.0 [55] checkmate_2.2.0 sctransform_0.4.1 [57] GenomicAlignments_1.34.1 prettyunits_1.1.1 [59] goftest_1.2-3 cluster_2.1.4 [61] dotCall64_1.1-0 lazyeval_0.2.2 [63] crayon_1.5.2 hdf5r_1.3.8 [65] spatstat.explore_3.2-5 pkgconfig_2.0.3 [67] labeling_0.4.3 nlme_3.1-162 [69] ProtGenerics_1.30.0 nnet_7.3-18 [71] rlang_1.1.1 globals_0.16.2 [73] lifecycle_1.0.3 miniUI_0.1.1.1 [75] filelock_1.0.2 fastDummies_1.7.3 [77] BiocFileCache_2.6.1 dichromat_2.0-0.1 [79] rprojroot_2.0.3 polyclip_1.10-6 [81] RcppHNSW_0.5.0 matrixStats_1.0.0 [83] lmtest_0.9-40 Matrix_1.6-1.1 [85] zoo_1.8-12 base64enc_0.1-3 [87] ggridges_0.5.4 png_0.1-8 [89] viridisLite_0.4.2 rjson_0.2.21 [91] bitops_1.0-7 R.oo_1.25.0 [93] KernSmooth_2.23-22 spam_2.10-0 [95] Biostrings_2.66.0 blob_1.2.4 [97] DelayedMatrixStats_1.20.0 stringr_1.5.0 [99] parallelly_1.36.0 spatstat.random_3.2-1 [101] R.cache_0.16.0 scales_1.2.1 [103] memoise_2.0.1 magrittr_2.0.3 [105] plyr_1.8.9 ica_1.0-3 [107] zlibbioc_1.44.0 compiler_4.2.2 [109] BiocIO_1.8.0 RColorBrewer_1.1-3 [111] fitdistrplus_1.1-11 Rsamtools_2.14.0 [113] cli_3.6.1 XVector_0.38.0 [115] listenv_0.9.0 patchwork_1.1.3 [117] pbapply_1.7-2 htmlTable_2.4.1 [119] Formula_1.2-5 MASS_7.3-58.2 [121] tidyselect_1.2.0 stringi_1.7.12 [123] textshaping_0.3.6 glmGamPoi_1.10.2 [125] highr_0.10 yaml_2.3.7 [127] ggrepel_0.9.4 grid_4.2.2 [129] sass_0.4.7 VariantAnnotation_1.44.1 [131] fastmatch_1.1-4 tools_4.2.2 [133] future.apply_1.11.0 parallel_4.2.2 [135] rstudioapi_0.14 foreign_0.8-84 [137] gridExtra_2.3 farver_2.1.1 [139] Rtsne_0.16 digest_0.6.33 [141] shiny_1.7.5.1 Rcpp_1.0.11 [143] later_1.3.1 RcppAnnoy_0.0.21 [145] httr_1.4.7 biovizBase_1.46.0 [147] colorspace_2.1-0 XML_3.99-0.14 [149] fs_1.6.3 tensor_1.5 [151] reticulate_1.34.0 splines_4.2.2 [153] uwot_0.1.16 RcppRoll_0.3.0 [155] spatstat.utils_3.0-4 pkgdown_2.0.7 [157] plotly_4.10.3 systemfonts_1.0.4 [159] xtable_1.8-4 jsonlite_1.8.7 [161] R6_2.5.1 Hmisc_5.1-1 [163] pillar_1.9.0 htmltools_0.5.6.1 [165] mime_0.12 glue_1.6.2 [167] fastmap_1.1.1 BiocParallel_1.32.6 [169] codetools_0.2-19 utf8_1.2.4 [171] lattice_0.21-9 bslib_0.5.1 [173] spatstat.sparse_3.0-3 tibble_3.2.1 [175] curl_5.1.0 leiden_0.4.3 [177] survival_3.5-7 rmarkdown_2.25 [179] desc_1.4.2 munsell_0.5.0 [181] GenomeInfoDbData_1.2.9 reshape2_1.4.4 [183] gtable_0.3.4 ```",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/seurat5_integration_bridge",
      "title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat • Seurat",
      "ogTitle": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "language": "en",
      "og:title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "scrapeId": "5ee142d3-7a7f-4ce8-9a0f-43b4034ca4f6",
      "viewport": "width=device-width, initial-scale=1.0",
      "sourceURL": "https://satijalab.org/seurat/articles/seurat5_integration_bridge",
      "statusCode": 200,
      "ogDescription": "Seurat",
      "og:description": "Seurat"
    }
  },
  {
    "processed_text": "",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/seurat5_mixscape_vignette.html",
      "error": "Not Found",
      "scrapeId": "653cefc3-e023-48c1-b7c9-9e3f0f3148b7",
      "sourceURL": "https://satijalab.org/seurat/articles/seurat5_mixscape_vignette.html",
      "statusCode": 404
    }
  },
  {
    "processed_text": "",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/seurat5_de_vignette.html",
      "error": "Not Found",
      "scrapeId": "70addb32-1859-44ee-8481-3083368c376c",
      "sourceURL": "https://satijalab.org/seurat/articles/seurat5_de_vignette.html",
      "statusCode": 404
    }
  },
  {
    "processed_text": "",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/seurat5_merge_vignette.html",
      "error": "Not Found",
      "scrapeId": "71b2c197-e614-417c-a1ce-beb5af9923e4",
      "sourceURL": "https://satijalab.org/seurat/articles/seurat5_merge_vignette.html",
      "statusCode": 404
    }
  },
  {
    "processed_text": "",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/conversion_vignette.html",
      "error": "Not Found",
      "scrapeId": "725bc6dc-276f-44d9-89ab-b1683a7b008d",
      "sourceURL": "https://satijalab.org/seurat/articles/conversion_vignette.html",
      "statusCode": 404
    }
  },
  {
    "processed_text": "Seurat - Guided Clustering Tutorial Compiled: October 31, 2023 Source: vignettes/pbmc3k_tutorial.Rmd pbmc3k_tutorial.Rmd Setup the Seurat Object anchor For this tutorial, we will be analyzing the a dataset of Peripheral Blood Mononuclear Cells (PBMC) freely available from 10X Genomics. There are 2,700 single cells that were sequenced on the Illumina NextSeq 500. The raw data can be found here . We start by reading in the data. The Read10X() function reads in the output of the cellranger pipeline from 10X, returning a unique molecular identified (UMI) count matrix. The values in this matrix represent the number of molecules for each feature (i.e. gene; row) that are detected in each cell (column). Note that more recent versions of cellranger now also output using the h5 file format , which can be read in using the Read10X_h5() function in Seurat. We next use the count matrix to create a Seurat object. The object serves as a container that contains both data (like the count matrix) and analysis (like PCA, or clustering results) for a single-cell dataset. For more information, check out our [Seurat object interaction vignette], or our GitHub Wiki . For example, in Seurat v5, the count matrix is stored in pbmc[[\"RNA\"]]$counts . ```sourceCode R library(dplyr) library(Seurat) library(patchwork) Load the PBMC dataset pbmc.data <- Read10X(data.dir = \"/brahms/mollag/practice/filtered_gene_bc_matrices/hg19/\") Initialize the Seurat object with the raw (non-normalized data). pbmc <- CreateSeuratObject(counts = pbmc.data, project = \"pbmc3k\", min.cells = 3, min.features = 200) pbmc ``` ``` An object of class Seurat 13714 features across 2700 samples within 1 assay Active assay: RNA (13714 features, 0 variable features) 1 layer present: counts ``` What does data in a count matrix look like? ```sourceCode R Lets examine a few genes in the first thirty cells pbmc.data[c(\"CD3D\", \"TCL1A\", \"MS4A1\"), 1:30] ``` ``` 3 x 30 sparse Matrix of class \"dgCMatrix\" CD3D 4 . 10 . . 1 2 3 1 . . 2 7 1 . . 1 3 . 2 3 . . . . . 3 4 1 5 TCL1A . . . . . . . . 1 . . . . . . . . . . . . 1 . . . . . . . . MS4A1 . 6 . . . . . . 1 1 1 . . . . . . . . . 36 1 2 . . 2 . . . . ``` The . values in the matrix represent 0s (no molecules detected). Since most values in an scRNA-seq matrix are 0, Seurat uses a sparse-matrix representation whenever possible. This results in significant memory and speed savings for Drop-seq/inDrop/10x data. sourceCode R dense.size <- object.size(as.matrix(pbmc.data)) dense.size ``` 709591472 bytes ``` sourceCode R sparse.size <- object.size(pbmc.data) sparse.size ``` 29905192 bytes ``` sourceCode R dense.size/sparse.size ``` 23.7 bytes ``` Standard pre-processing workflow anchor The steps below encompass the standard pre-processing workflow for scRNA-seq data in Seurat. These represent the selection and filtration of cells based on QC metrics, data normalization and scaling, and the detection of highly variable features. QC and selecting cells for further analysis anchor Seurat allows you to easily explore QC metrics and filter cells based on any user-defined criteria. A few QC metrics commonly used by the community include The number of unique genes detected in each cell. Low-quality cells or empty droplets will often have very few genes Cell doublets or multiplets may exhibit an aberrantly high gene count Similarly, the total number of molecules detected within a cell (correlates strongly with unique genes) The percentage of reads that map to the mitochondrial genome Low-quality / dying cells often exhibit extensive mitochondrial contamination We calculate mitochondrial QC metrics with the PercentageFeatureSet() function, which calculates the percentage of counts originating from a set of features We use the set of all genes starting with MT- as a set of mitochondrial genes sourceCode R # The [[ operator can add columns to object metadata. This is a great place to stash QC stats\\ pbmc[[\"percent.mt\"]] <- PercentageFeatureSet(pbmc, pattern = \"^MT-\")\\ \\ \\ Where are QC metrics stored in Seurat? \\ \\ - The number of unique genes and total molecules are automatically calculated during CreateSeuratObject() \\ - You can find them stored in the object meta data\\ \\ sourceCode R\\ # Show QC metrics for the first 5 cells\\ head(pbmc@meta.data, 5)\\ \\ \\ \\ ## orig.ident nCount_RNA nFeature_RNA percent.mt\\ ## AAACATACAACCAC-1 pbmc3k 2419 779 3.0177759\\ ## AAACATTGAGCTAC-1 pbmc3k 4903 1352 3.7935958\\ ## AAACATTGATCAGC-1 pbmc3k 3147 1129 0.8897363\\ ## AAACCGTGCTTCCG-1 pbmc3k 2639 960 1.7430845\\ ## AAACCGTGTATGCG-1 pbmc3k 980 521 1.2244898\\ \\ \\ In the example below, we visualize QC metrics, and use these to filter cells.\\ \\ - We filter cells that have unique feature counts over 2,500 or less than 200\\ - We filter cells that have >5% mitochondrial counts\\ \\ sourceCode R\\ # Visualize QC metrics as a violin plot\\ VlnPlot(pbmc, features = c(\"nFeature_RNA\", \"nCount_RNA\", \"percent.mt\"), ncol = 3)\\ \\ \\ \\ \\ sourceCode R\\ # FeatureScatter is typically used to visualize feature-feature relationships, but can be used\\ # for anything calculated by the object, i.e. columns in object metadata, PC scores etc.\\ \\ plot1 <- FeatureScatter(pbmc, feature1 = \"nCount_RNA\", feature2 = \"percent.mt\")\\ plot2 <- FeatureScatter(pbmc, feature1 = \"nCount_RNA\", feature2 = \"nFeature_RNA\")\\ plot1 + plot2\\ \\ \\ \\ \\ sourceCode R\\ pbmc <- subset(pbmc, subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 5)\\ \\ \\ * * \\ \\ ## Normalizing the data anchor \\ \\ After removing unwanted cells from the dataset, the next step is to normalize the data. By default, we employ a global-scaling normalization method “LogNormalize” that normalizes the feature expression measurements for each cell by the total expression, multiplies this by a scale factor (10,000 by default), and log-transforms the result. In Seurat v5, Normalized values are stored in pbmc[[\"RNA\"]]$data .\\ \\ sourceCode R\\ pbmc <- NormalizeData(pbmc, normalization.method = \"LogNormalize\", scale.factor = 10000)\\ \\ \\ For clarity, in this previous line of code (and in future commands), we provide the default values for certain parameters in the function call. However, this isn’t required and the same behavior can be achieved with:\\ \\ sourceCode R\\ pbmc <- NormalizeData(pbmc)\\ \\ \\ While this method of normalization is standard and widely used in scRNA-seq analysis, global-scaling relies on an assumption that each cell originally contains the same number of RNA molecules. We and others have developed alternative workflows for the single cell preprocessing that do not make these assumptions. For users who are interested, please check out our SCTransform() normalization workflow. The method is described in our paper , with a separate vignette using Seurat here . The use of SCTransform replaces the need to run NormalizeData , FindVariableFeatures , or ScaleData (described below.)\\ \\ ## Identification of highly variable features (feature selection) anchor \\ \\ We next calculate a subset of features that exhibit high cell-to-cell variation in the dataset (i.e, they are highly expressed in some cells, and lowly expressed in others). We and others have found that focusing on these genes in downstream analysis helps to highlight biological signal in single-cell datasets.\\ \\ Our procedure in Seurat is described in detail here , and improves on previous versions by directly modeling the mean-variance relationship inherent in single-cell data, and is implemented in the FindVariableFeatures() function. By default, we return 2,000 features per dataset. These will be used in downstream analysis, like PCA.\\ \\ sourceCode R\\ pbmc <- FindVariableFeatures(pbmc, selection.method = \"vst\", nfeatures = 2000)\\ \\ # Identify the 10 most highly variable genes\\ top10 <- head(VariableFeatures(pbmc), 10)\\ \\ # plot variable features with and without labels\\ plot1 <- VariableFeaturePlot(pbmc)\\ plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)\\ plot1 + plot2\\ \\ \\ \\ \\ * * \\ \\ ## Scaling the data anchor \\ \\ Next, we apply a linear transformation (‘scaling’) that is a standard pre-processing step prior to dimensional reduction techniques like PCA. The ScaleData() function:\\ \\ - Shifts the expression of each gene, so that the mean expression across cells is 0\\ - Scales the expression of each gene, so that the variance across cells is 1\\ - This step gives equal weight in downstream analyses, so that highly-expressed genes do not dominate\\ - The results of this are stored in pbmc[[\"RNA\"]]$scale.data \\ - By default, only variable features are scaled.\\ - You can specify the features argument to scale additional features\\ \\ sourceCode R\\ all.genes <- rownames(pbmc)\\ pbmc <- ScaleData(pbmc, features = all.genes)\\ \\ \\ How can I remove unwanted sources of variation \\ \\ In Seurat, we also use the ScaleData() function to remove unwanted sources of variation from a single-cell dataset. For example, we could ‘regress out’ heterogeneity associated with (for example) cell cycle stage , or mitochondrial contamination i.e.:\\ \\ sourceCode R\\ pbmc <- ScaleData(pbmc, vars.to.regress = \"percent.mt\")\\ \\ \\ However, particularly for advanced users who would like to use this functionality, we strongly recommend the use of our new normalization workflow, SCTransform() . The method is described in our paper , with a separate vignette using Seurat here . As with ScaleData() , the function SCTransform() also includes a vars.to.regress parameter.\\ \\ * * \\ \\ ## Perform linear dimensional reduction anchor \\ \\ Next we perform PCA on the scaled data. By default, only the previously determined variable features are used as input, but can be defined using features argument if you wish to choose a different subset (if you do want to use a custom subset of features, make sure you pass these to ScaleData first).\\ \\ For the first principal components, Seurat outputs a list of genes with the most positive and negative loadings, representing modules of genes that exhibit either correlation (or anti-correlation) across single-cells in the dataset.\\ \\ sourceCode R\\ pbmc <- RunPCA(pbmc, features = VariableFeatures(object = pbmc))\\ \\ \\ Seurat provides several useful ways of visualizing both cells and features that define the PCA, including VizDimReduction() , DimPlot() , and DimHeatmap() \\ \\ sourceCode R\\ # Examine and visualize PCA results a few different ways\\ print(pbmc[[\"pca\"]], dims = 1:5, nfeatures = 5)\\ \\ \\ \\ ## PC_ 1\\ ## Positive: CST3, TYROBP, LST1, AIF1, FTL\\ ## Negative: MALAT1, LTB, IL32, IL7R, CD2\\ ## PC_ 2\\ ## Positive: CD79A, MS4A1, TCL1A, HLA-DQA1, HLA-DQB1\\ ## Negative: NKG7, PRF1, CST7, GZMB, GZMA\\ ## PC_ 3\\ ## Positive: HLA-DQA1, CD79A, CD79B, HLA-DQB1, HLA-DPB1\\ ## Negative: PPBP, PF4, SDPR, SPARC, GNG11\\ ## PC_ 4\\ ## Positive: HLA-DQA1, CD79B, CD79A, MS4A1, HLA-DQB1\\ ## Negative: VIM, IL7R, S100A6, IL32, S100A8\\ ## PC_ 5\\ ## Positive: GZMB, NKG7, S100A8, FGFBP2, GNLY\\ ## Negative: LTB, IL7R, CKB, VIM, MS4A7\\ \\ \\ sourceCode R\\ VizDimLoadings(pbmc, dims = 1:2, reduction = \"pca\")\\ \\ \\ \\ \\ sourceCode R\\ DimPlot(pbmc, reduction = \"pca\") + NoLegend()\\ \\ \\ \\ \\ In particular DimHeatmap() allows for easy exploration of the primary sources of heterogeneity in a dataset, and can be useful when trying to decide which PCs to include for further downstream analyses. Both cells and features are ordered according to their PCA scores. Setting cells to a number plots the ‘extreme’ cells on both ends of the spectrum, which dramatically speeds plotting for large datasets. Though clearly a supervised analysis, we find this to be a valuable tool for exploring correlated feature sets.\\ \\ sourceCode R\\ DimHeatmap(pbmc, dims = 1, cells = 500, balanced = TRUE)\\ \\ \\ \\ \\ sourceCode R\\ DimHeatmap(pbmc, dims = 1:15, cells = 500, balanced = TRUE)\\ \\ \\ \\ \\ ## Determine the ‘dimensionality’ of the dataset anchor \\ \\ To overcome the extensive technical noise in any single feature for scRNA-seq data, Seurat clusters cells based on their PCA scores, with each PC essentially representing a ‘metafeature’ that combines information across a correlated feature set. The top principal components therefore represent a robust compression of the dataset. However, how many components should we choose to include? 10? 20? 100?\\ \\ In Macosko et al , we implemented a resampling test inspired by the JackStraw procedure. While still available in Seurat (see previous vignette) , this is a slow and computationally expensive procedure, and we is no longer routinely used in single cell analysis.\\ \\ An alternative heuristic method generates an ‘Elbow plot’: a ranking of principle components based on the percentage of variance explained by each one ( ElbowPlot() function). In this example, we can observe an ‘elbow’ around PC9-10, suggesting that the majority of true signal is captured in the first 10 PCs.\\ \\ sourceCode R\\ ElbowPlot(pbmc)\\ \\ \\ \\ \\ Identifying the true dimensionality of a dataset – can be challenging/uncertain for the user. We therefore suggest these multiple approaches for users. The first is more supervised, exploring PCs to determine relevant sources of heterogeneity, and could be used in conjunction with GSEA for example. The second ( ElbowPlot ) The third is a heuristic that is commonly used, and can be calculated instantly. In this example, we might have been justified in choosing anything between PC 7-12 as a cutoff.\\ \\ We chose 10 here, but encourage users to consider the following:\\ \\ - Dendritic cell and NK aficionados may recognize that genes strongly associated with PCs 12 and 13 define rare immune subsets (i.e. MZB1 is a marker for plasmacytoid DCs). However, these groups are so rare, they are difficult to distinguish from background noise for a dataset of this size without prior knowledge.\\ - We encourage users to repeat downstream analyses with a different number of PCs (10, 15, or even 50!). As you will observe, the results often do not differ dramatically.\\ - We advise users to err on the higher side when choosing this parameter. For example, performing downstream analyses with only 5 PCs does significantly and adversely affect results.\\ \\ * * \\ \\ ## Cluster the cells anchor \\ \\ Seurat applies a graph-based clustering approach, building upon initial strategies in ( Macosko et al ). Importantly, the distance metric which drives the clustering analysis (based on previously identified PCs) remains the same. However, our approach to partitioning the cellular distance matrix into clusters has dramatically improved. Our approach was heavily inspired by recent manuscripts which applied graph-based clustering approaches to scRNA-seq data [SNN-Cliq, Xu and Su, Bioinformatics, 2015] and CyTOF data [PhenoGraph, Levine et al ., Cell, 2015] . Briefly, these methods embed cells in a graph structure - for example a K-nearest neighbor (KNN) graph, with edges drawn between cells with similar feature expression patterns, and then attempt to partition this graph into highly interconnected ‘quasi-cliques’ or ‘communities’.\\ \\ As in PhenoGraph, we first construct a KNN graph based on the euclidean distance in PCA space, and refine the edge weights between any two cells based on the shared overlap in their local neighborhoods (Jaccard similarity). This step is performed using the FindNeighbors() function, and takes as input the previously defined dimensionality of the dataset (first 10 PCs).\\ \\ To cluster the cells, we next apply modularity optimization techniques such as the Louvain algorithm (default) or SLM [SLM, Blondel et al ., Journal of Statistical Mechanics] , to iteratively group cells together, with the goal of optimizing the standard modularity function. The FindClusters() function implements this procedure, and contains a resolution parameter that sets the ‘granularity’ of the downstream clustering, with increased values leading to a greater number of clusters. We find that setting this parameter between 0.4-1.2 typically returns good results for single-cell datasets of around 3K cells. Optimal resolution often increases for larger datasets. The clusters can be found using the Idents() function.\\ \\ sourceCode R\\ pbmc <- FindNeighbors(pbmc, dims = 1:10)\\ pbmc <- FindClusters(pbmc, resolution = 0.5)\\ \\ \\ \\ ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\\ ##\\ ## Number of nodes: 2638\\ ## Number of edges: 95965\\ ##\\ ## Running Louvain algorithm...\\ ## Maximum modularity in 10 random starts: 0.8723\\ ## Number of communities: 9\\ ## Elapsed time: 0 seconds\\ \\ \\ sourceCode R\\ # Look at cluster IDs of the first 5 cells\\ head(Idents(pbmc), 5)\\ \\ \\ \\ ## AAACATACAACCAC-1 AAACATTGAGCTAC-1 AAACATTGATCAGC-1 AAACCGTGCTTCCG-1\\ ## 2 3 2 1\\ ## AAACCGTGTATGCG-1\\ ## 6\\ ## Levels: 0 1 2 3 4 5 6 7 8\\ \\ \\ * * \\ \\ ## Run non-linear dimensional reduction (UMAP/tSNE) anchor \\ \\ Seurat offers several non-linear dimensional reduction techniques, such as tSNE and UMAP, to visualize and explore these datasets. The goal of these algorithms is to learn underlying structure in the dataset, in order to place similar cells together in low-dimensional space. Therefore, cells that are grouped together within graph-based clusters determined above should co-localize on these dimension reduction plots.\\ \\ While we and others have routinely found 2D visualization techniques like tSNE and UMAP to be valuable tools for exploring datasets, all visualization techniques have limitations, and cannot fully represent the complexity of the underlying data. In particular, these methods aim to preserve local distances in the dataset (i.e. ensuring that cells with very similar gene expression profiles co-localize), but often do not preserve more global relationships. We encourage users to leverage techniques like UMAP for visualization, but to avoid drawing biological conclusions solely on the basis of visualization techniques.\\ \\ sourceCode R\\ pbmc <- RunUMAP(pbmc, dims = 1:10)\\ \\ \\ sourceCode R\\ # note that you can set `label = TRUE` or use the LabelClusters function to help label\\ # individual clusters\\ DimPlot(pbmc, reduction = \"umap\")\\ \\ \\ \\ \\ You can save the object at this point so that it can easily be loaded back in without having to rerun the computationally intensive steps performed above, or easily shared with collaborators.\\ \\ sourceCode R\\ saveRDS(pbmc, file = \"../output/pbmc_tutorial.rds\")\\ \\ \\ * * \\ \\ ## Finding differentially expressed features (cluster biomarkers) anchor \\ \\ Seurat can help you find markers that define clusters via differential expression (DE). By default, it identifies positive and negative markers of a single cluster (specified in ident.1 ), compared to all other cells. FindAllMarkers() automates this process for all clusters, but you can also test groups of clusters vs. each other, or against all cells.\\ \\ In Seurat v5, we use the presto package (as described here and available for installation here ), to dramatically improve the speed of DE analysis, particularly for large datasets. For users who are not using presto, you can examine the documentation for this function ( ?FindMarkers ) to explore the min.pct and logfc.threshold parameters, which can be increased in order to increase the speed of DE testing.\\ \\ sourceCode R\\ # find all markers of cluster 2\\ cluster2.markers <- FindMarkers(pbmc, ident.1 = 2)\\ head(cluster2.markers, n = 5)\\ \\ \\ \\ ## p_val avg_log2FC pct.1 pct.2 p_val_adj\\ ## IL32 2.593535e-91 1.3221171 0.949 0.466 3.556774e-87\\ ## LTB 7.994465e-87 1.3450377 0.981 0.644 1.096361e-82\\ ## CD3D 3.922451e-70 1.0562099 0.922 0.433 5.379250e-66\\ ## IL7R 1.130870e-66 1.4256944 0.748 0.327 1.550876e-62\\ ## LDHB 4.082189e-65 0.9765875 0.953 0.614 5.598314e-61\\ \\ \\ sourceCode R\\ # find all markers distinguishing cluster 5 from clusters 0 and 3\\ cluster5.markers <- FindMarkers(pbmc, ident.1 = 5, ident.2 = c(0, 3))\\ head(cluster5.markers, n = 5)\\ \\ \\ \\ ## p_val avg_log2FC pct.1 pct.2 p_val_adj\\ ## FCGR3A 2.150929e-209 6.832372 0.975 0.039 2.949784e-205\\ ## IFITM3 6.103366e-199 6.181000 0.975 0.048 8.370156e-195\\ ## CFD 8.891428e-198 6.052575 0.938 0.037 1.219370e-193\\ ## CD68 2.374425e-194 5.493138 0.926 0.035 3.256286e-190\\ ## RP11-290F20.3 9.308287e-191 6.335402 0.840 0.016 1.276538e-186\\ \\ \\ sourceCode R\\ # find markers for every cluster compared to all remaining cells, report only the positive\\ # ones\\ pbmc.markers <- FindAllMarkers(pbmc, only.pos = TRUE)\\ pbmc.markers %>%\\ group_by(cluster) %>%\\ dplyr::filter(avg_log2FC > 1)\\ \\ \\ \\ ## # A tibble: 7,046 × 7\\ ## # Groups: cluster [9]\\ ## p_val avg_log2FC pct.1 pct.2 p_val_adj cluster gene\\ ## <dbl> <dbl> <dbl> <dbl> <dbl> <fct> <chr>\\ ## 1 1.74e-109 1.19 0.897 0.593 2.39e-105 0 LDHB\\ ## 2 1.17e- 83 2.37 0.435 0.108 1.60e- 79 0 CCR7\\ ## 3 8.94e- 79 1.09 0.838 0.403 1.23e- 74 0 CD3D\\ ## 4 3.05e- 53 1.02 0.722 0.399 4.19e- 49 0 CD3E\\ ## 5 3.28e- 49 2.10 0.333 0.103 4.50e- 45 0 LEF1\\ ## 6 6.66e- 49 1.25 0.623 0.358 9.13e- 45 0 NOSIP\\ ## 7 9.31e- 44 2.02 0.328 0.11 1.28e- 39 0 PRKCQ-AS1\\ ## 8 4.69e- 43 1.53 0.435 0.184 6.43e- 39 0 PIK3IP1\\ ## 9 1.47e- 39 2.70 0.195 0.04 2.01e- 35 0 FHIT\\ ## 10 2.44e- 33 1.94 0.262 0.087 3.34e- 29 0 MAL\\ ## # ℹ 7,036 more rows\\ \\ \\ Seurat has several tests for differential expression which can be set with the test.use parameter (see our DE vignette for details). For example, the ROC test returns the ‘classification power’ for any individual marker (ranging from 0 - random, to 1 - perfect).\\ \\ sourceCode R\\ cluster0.markers <- FindMarkers(pbmc, ident.1 = 0, logfc.threshold = 0.25, test.use = \"roc\", only.pos = TRUE)\\ \\ \\ We include several tools for visualizing marker expression. VlnPlot() (shows expression probability distributions across clusters), and FeaturePlot() (visualizes feature expression on a tSNE or PCA plot) are our most commonly used visualizations. We also suggest exploring RidgePlot() , CellScatter() , and DotPlot() as additional methods to view your dataset.\\ \\ sourceCode R\\ VlnPlot(pbmc, features = c(\"MS4A1\", \"CD79A\"))\\ \\ \\ \\ \\ sourceCode R\\ # you can plot raw counts as well\\ VlnPlot(pbmc, features = c(\"NKG7\", \"PF4\"), slot = \"counts\", log = TRUE)\\ \\ \\ \\ \\ sourceCode R\\ FeaturePlot(pbmc, features = c(\"MS4A1\", \"GNLY\", \"CD3E\", \"CD14\", \"FCER1A\", \"FCGR3A\", \"LYZ\", \"PPBP\",\\ \"CD8A\"))\\ \\ \\ DoHeatmap() generates an expression heatmap for given cells and features. In this case, we are plotting the top 20 markers (or all markers if less than 20) for each cluster.\\ \\ sourceCode R\\ pbmc.markers %>%\\ group_by(cluster) %>%\\ dplyr::filter(avg_log2FC > 1) %>%\\ slice_head(n = 10) %>%\\ ungroup() -> top10\\ DoHeatmap(pbmc, features = top10$gene) + NoLegend()\\ \\ \\ \\ \\ * * \\ \\ ## Assigning cell type identity to clusters anchor \\ \\ Fortunately in the case of this dataset, we can use canonical markers to easily match the unbiased clustering to known cell types:\\ \\ | 0 | IL7R, CCR7 | Naive CD4+ T |\\ | 1 | CD14, LYZ | CD14+ Mono |\\ | 2 | IL7R, S100A4 | Memory CD4+ |\\ | 3 | MS4A1 | B |\\ | 4 | CD8A | CD8+ T |\\ | 5 | FCGR3A, MS4A7 | FCGR3A+ Mono |\\ | 6 | GNLY, NKG7 | NK |\\ | 7 | FCER1A, CST3 | DC |\\ | 8 | PPBP | Platelet |\\ \\ sourceCode R\\ new.cluster.ids <- c(\"Naive CD4 T\", \"CD14+ Mono\", \"Memory CD4 T\", \"B\", \"CD8 T\", \"FCGR3A+ Mono\",\\ \"NK\", \"DC\", \"Platelet\")\\ names(new.cluster.ids) <- levels(pbmc)\\ pbmc <- RenameIdents(pbmc, new.cluster.ids)\\ DimPlot(pbmc, reduction = \"umap\", label = TRUE, pt.size = 0.5) + NoLegend()\\ \\ \\ \\ \\ sourceCode R\\ library(ggplot2)\\ plot <- DimPlot(pbmc, reduction = \"umap\", label = TRUE, label.size = 4.5) + xlab(\"UMAP 1\") + ylab(\"UMAP 2\") +\\ theme(axis.title = element_text(size = 18), legend.text = element_text(size = 18)) + guides(colour = guide_legend(override.aes = list(size = 10)))\\ ggsave(filename = \"../output/images/pbmc3k_umap.jpg\", height = 7, width = 12, plot = plot, quality = 50)\\ \\ \\ sourceCode R\\ saveRDS(pbmc, file = \"../output/pbmc3k_final.rds\")\\ \\ \\ Session Info *\\ \\ sourceCode R\\ sessionInfo()\\ \\ \\ \\ ## R version 4.2.2 Patched (2022-11-10 r83330)\\ ## Platform: x86_64-pc-linux-gnu (64-bit)\\ ## Running under: Ubuntu 20.04.6 LTS\\ ##\\ ## Matrix products: default\\ ## BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0\\ ## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\\ ##\\ ## locale:\\ ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C\\ ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8\\ ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8\\ ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C\\ ## [9] LC_ADDRESS=C LC_TELEPHONE=C\\ ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C\\ ##\\ ## attached base packages:\\ ## [1] stats graphics grDevices utils datasets methods base\\ ##\\ ## other attached packages:\\ ## [1] ggplot2_3.4.4 patchwork_1.1.3 Seurat_5.0.0 SeuratObject_5.0.0\\ ## [5] sp_2.1-1 dplyr_1.1.3\\ ##\\ ## loaded via a namespace (and not attached):\\ ## [1] spam_2.10-0 systemfonts_1.0.4 plyr_1.8.9\\ ## [4] igraph_1.5.1 lazyeval_0.2.2 splines_4.2.2\\ ## [7] RcppHNSW_0.5.0 listenv_0.9.0 scattermore_1.2\\ ## [10] digest_0.6.33 htmltools_0.5.6.1 fansi_1.0.5\\ ## [13] magrittr_2.0.3 memoise_2.0.1 tensor_1.5\\ ## [16] cluster_2.1.4 ROCR_1.0-11 limma_3.54.1\\ ## [19] globals_0.16.2 matrixStats_1.0.0 R.utils_2.12.2\\ ## [22] pkgdown_2.0.7 spatstat.sparse_3.0-3 colorspace_2.1-0\\ ## [25] ggrepel_0.9.4 textshaping_0.3.6 xfun_0.40\\ ## [28] jsonlite_1.8.7 progressr_0.14.0 spatstat.data_3.0-3\\ ## [31] survival_3.5-7 zoo_1.8-12 glue_1.6.2\\ ## [34] polyclip_1.10-6 gtable_0.3.4 leiden_0.4.3\\ ## [37] future.apply_1.11.0 abind_1.4-5 scales_1.2.1\\ ## [40] spatstat.random_3.2-1 miniUI_0.1.1.1 Rcpp_1.0.11\\ ## [43] viridisLite_0.4.2 xtable_1.8-4 reticulate_1.34.0\\ ## [46] dotCall64_1.1-0 htmlwidgets_1.6.2 httr_1.4.7\\ ## [49] RColorBrewer_1.1-3 ellipsis_0.3.2 ica_1.0-3\\ ## [52] pkgconfig_2.0.3 R.methodsS3_1.8.2 farver_2.1.1\\ ## [55] sass_0.4.7 uwot_0.1.16 deldir_1.0-9\\ ## [58] utf8_1.2.4 tidyselect_1.2.0 labeling_0.4.3\\ ## [61] rlang_1.1.1 reshape2_1.4.4 later_1.3.1\\ ## [64] munsell_0.5.0 tools_4.2.2 cachem_1.0.8\\ ## [67] cli_3.6.1 generics_0.1.3 ggridges_0.5.4\\ ## [70] evaluate_0.22 stringr_1.5.0 fastmap_1.1.1\\ ## [73] yaml_2.3.7 ragg_1.2.5 goftest_1.2-3\\ ## [76] knitr_1.45 fs_1.6.3 fitdistrplus_1.1-11\\ ## [79] purrr_1.0.2 RANN_2.6.1 pbapply_1.7-2\\ ## [82] future_1.33.0 nlme_3.1-162 mime_0.12\\ ## [85] formatR_1.14 ggrastr_1.0.1 R.oo_1.25.0\\ ## [88] compiler_4.2.2 beeswarm_0.4.0 plotly_4.10.3\\ ## [91] png_0.1-8 spatstat.utils_3.0-4 tibble_3.2.1\\ ## [94] bslib_0.5.1 stringi_1.7.12 highr_0.10\\ ## [97] desc_1.4.2 RSpectra_0.16-1 lattice_0.21-9\\ ## [100] Matrix_1.6-1.1 vctrs_0.6.4 pillar_1.9.0\\ ## [103] lifecycle_1.0.3 spatstat.geom_3.2-7 lmtest_0.9-40\\ ## [106] jquerylib_0.1.4 RcppAnnoy_0.0.21 data.table_1.14.8\\ ## [109] cowplot_1.1.1 irlba_2.3.5.1 httpuv_1.6.12\\ ## [112] R6_2.5.1 promises_1.2.1 KernSmooth_2.23-22\\ ## [115] gridExtra_2.3 vipor_0.4.5 parallelly_1.36.0\\ ## [118] codetools_0.2-19 fastDummies_1.7.3 MASS_7.3-58.2\\ ## [121] rprojroot_2.0.3 withr_2.5.2 presto_1.0.0\\ ## [124] sctransform_0.4.1 parallel_4.2.2 grid_4.2.2\\ ## [127] tidyr_1.3.0 rmarkdown_2.25 Rtsne_0.16\\ ## [130] spatstat.explore_3.2-5 shiny_1.7.5.1 ggbeeswarm_0.7.1\\",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/pbmc3k_tutorial",
      "title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat • Seurat",
      "ogTitle": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "language": "en",
      "og:title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "scrapeId": "7bbed28f-6dce-400f-bea9-a82ee91f6a97",
      "viewport": "width=device-width, initial-scale=1.0",
      "sourceURL": "https://satijalab.org/seurat/articles/pbmc3k_tutorial",
      "statusCode": 200,
      "ogDescription": "Seurat",
      "og:description": "Seurat"
    }
  },
  {
    "processed_text": "",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/interaction_vignette.html",
      "error": "Not Found",
      "scrapeId": "7e3a79d0-fe21-45a8-9313-5e37f7baa4a9",
      "sourceURL": "https://satijalab.org/seurat/articles/interaction_vignette.html",
      "statusCode": 404
    }
  },
  {
    "processed_text": "",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/seurat5_integration_large_datasets.html",
      "error": "Not Found",
      "scrapeId": "834b692f-3420-492c-9eea-9861ce3f90a4",
      "sourceURL": "https://satijalab.org/seurat/articles/seurat5_integration_large_datasets.html",
      "statusCode": 404
    }
  },
  {
    "processed_text": "Analysis, visualization, and integration of spatial datasets with Seurat Compiled: 2023-10-31 Source: vignettes/spatial_vignette.Rmd spatial_vignette.Rmd Overview anchor This tutorial demonstrates how to use Seurat (>=3.2) to analyze spatially-resolved RNA-seq data. While the analytical pipelines are similar to the Seurat workflow for single-cell RNA-seq analysis , we introduce updated interaction and visualization tools, with a particular emphasis on the integration of spatial and molecular information. This tutorial will cover the following tasks, which we believe will be common for many spatial analyses: Normalization Dimensional reduction and clustering Detecting spatially-variable features Interactive visualization Integration with single-cell RNA-seq data Working with multiple slices For our first vignette, we analyze a dataset generated with the Visium technology from 10x Genomics. We will be extending Seurat to work with additional data types in the near-future, including SLIDE-Seq , STARmap , and MERFISH . First, we load Seurat and the other packages necessary for this vignette. sourceCode R library(Seurat) library(SeuratData) library(ggplot2) library(patchwork) library(dplyr) 10x Visium anchor Dataset anchor Here, we will be using a recently released dataset of sagital mouse brain slices generated using the Visium v1 chemistry. There are two serial anterior sections, and two (matched) serial posterior sections. You can download the data here , and load it into Seurat using the Load10X_Spatial() function. This reads in the output of the spaceranger pipeline, and returns a Seurat object that contains both the spot-level expression data along with the associated image of the tissue slice. You can also use our SeuratData package for easy data access, as demonstrated below. After installing the dataset, you can type ?stxBrain to learn more. sourceCode R InstallData(\"stxBrain\") sourceCode R brain <- LoadData(\"stxBrain\", type = \"anterior1\") How is the spatial data stored within Seurat? The visium data from 10x consists of the following data types: A spot by gene expression matrix An image of the tissue slice (obtained from H&E staining during data acquisition) Scaling factors that relate the original high resolution image to the lower resolution image used here for visualization. In the Seurat object, the spot by gene expression matrix is similar to a typical “RNA” Assay but contains spot level, not single-cell level data. The image itself is stored in a new images slot in the Seurat object. The images slot also stores the information necessary to associate spots with their physical position on the tissue image. Data preprocessing anchor The initial preprocessing steps that we perform on the spot by gene expression data are similar to a typical scRNA-seq experiment. We first need to normalize the data in order to account for variance in sequencing depth across data points. We note that the variance in molecular counts / spot can be substantial for spatial datasets, particularly if there are differences in cell density across the tissue. We see substantial heterogeneity here, which requires effective normalization. sourceCode R plot1 <- VlnPlot(brain, features = \"nCount_Spatial\", pt.size = 0.1) + NoLegend() plot2 <- SpatialFeaturePlot(brain, features = \"nCount_Spatial\") + theme(legend.position = \"right\") wrap_plots(plot1, plot2) These plots demonstrate that the variance in molecular counts across spots is not just technical in nature, but also is dependent on the tissue anatomy. For example, regions of the tissue that are depleted for neurons (such as the cortical white matter), reproducibly exhibit lower molecular counts. As a result, standard approaches (such as the LogNormalize() function), which force each data point to have the same underlying ‘size’ after normalization, can be problematic. As an alternative, we recommend using sctransform (Hafemeister and Satija, Genome Biology 2019), which which builds regularized negative binomial models of gene expression in order to account for technical artifacts while preserving biological variance. For more details on sctransform, please see the paper here and the Seurat vignette here . sctransform normalizes the data, detects high-variance features, and stores the data in the SCT assay. sourceCode R brain <- SCTransform(brain, assay = \"Spatial\", verbose = FALSE) How do results compare to log-normalization? To explore the differences in normalization methods, we examine how both the sctransform and log normalization results correlate with the number of UMIs. For this comparison, we first rerun sctransform to store values for all genes and run a log-normalization procedure via NormalizeData() . ```sourceCode R rerun normalization to store sctransform residuals for all genes brain <- SCTransform(brain, assay = \"Spatial\", return.only.var.genes = FALSE, verbose = FALSE) also run standard log normalization for comparison brain <- NormalizeData(brain, verbose = FALSE, assay = \"Spatial\") ``` ```sourceCode R Computes the correlation of the log normalized data and sctransform residuals with the number of UMIs brain <- GroupCorrelation(brain, group.assay = \"Spatial\", assay = \"Spatial\", slot = \"data\", do.plot = FALSE) ``` ``` Error in object[[assay]][] <- grp.cors: object of type 'S4' is not subsettable ``` sourceCode R brain <- GroupCorrelation(brain, group.assay = \"Spatial\", assay = \"SCT\", slot = \"scale.data\", do.plot = FALSE) ``` Error in object[[assay]][] <- grp.cors: object of type 'S4' is not subsettable ``` sourceCode R p1 <- GroupCorrelationPlot(brain, assay = \"Spatial\", cor = \"nCount_Spatial_cor\") + ggtitle(\"Log Normalization\") + theme(plot.title = element_text(hjust = 0.5)) ``` Error in methods::slot(object = object, name = layer): no slot of name \"feature.grp\" for this object of class \"Assay\" ``` sourceCode R p2 <- GroupCorrelationPlot(brain, assay = \"SCT\", cor = \"nCount_Spatial_cor\") + ggtitle(\"SCTransform Normalization\") + theme(plot.title = element_text(hjust = 0.5)) ``` Error in methods::slot(object = object, name = layer): no slot of name \"feature.grp\" for this object of class \"SCTAssay\" ``` sourceCode R p1 + p2 ``` Error in eval(expr, envir, enclos): object 'p1' not found ``` For the boxplots above, we calculate the correlation of each feature (gene) with the number of UMIs (the nCount_Spatial variable here). We then place genes into groups based on their mean expression, and generate boxplots of these correlations. You can see that log-normalization fails to adequately normalize genes in the first three groups, suggesting that technical factors continue to influence normalized expression estimates for highly expressed genes. In contrast, sctransform normalization substantially mitigates this effect. Gene expression visualization anchor In Seurat, we have functionality to explore and interact with the inherently visual nature of spatial data. The SpatialFeaturePlot() function in Seurat extends FeaturePlot() , and can overlay molecular data on top of tissue histology. For example, in this data set of the mouse brain, the gene Hpca is a strong hippocampus marker and Ttr is a marker of the choroid plexus. sourceCode R SpatialFeaturePlot(brain, features = c(\"Hpca\", \"Ttr\")) sourceCode R library(ggplot2) plot <- SpatialFeaturePlot(brain, features = c(\"Ttr\")) + theme(legend.text = element_text(size = 0), legend.title = element_text(size = 20), legend.key.size = unit(1, \"cm\")) jpeg(filename = \"../output/images/spatial_vignette_ttr.jpg\", height = 700, width = 1200, quality = 50) print(plot) dev.off() ``` agg_png 2 ``` The default parameters in Seurat emphasize the visualization of molecular data. However, you can also adjust the size of the spots (and their transparency) to improve the visualization of the histology image, by changing the following parameters: pt.size.factor - This will scale the size of the spots. Default is 1.6 alpha - minimum and maximum transparency. Default is c(1, 1). Try setting to alpha c(0.1, 1), to downweight the transparency of points with lower expression sourceCode R p1 <- SpatialFeaturePlot(brain, features = \"Ttr\", pt.size.factor = 1) p2 <- SpatialFeaturePlot(brain, features = \"Ttr\", alpha = c(0.1, 1)) p1 + p2 Dimensionality reduction, clustering, and visualization anchor We can then proceed to run dimensionality reduction and clustering on the RNA expression data, using the same workflow as we use for scRNA-seq analysis. sourceCode R brain <- RunPCA(brain, assay = \"SCT\", verbose = FALSE) brain <- FindNeighbors(brain, reduction = \"pca\", dims = 1:30) brain <- FindClusters(brain, verbose = FALSE) brain <- RunUMAP(brain, reduction = \"pca\", dims = 1:30) We can then visualize the results of the clustering either in UMAP space (with DimPlot() ) or overlaid on the image with SpatialDimPlot() . sourceCode R p1 <- DimPlot(brain, reduction = \"umap\", label = TRUE) p2 <- SpatialDimPlot(brain, label = TRUE, label.size = 3) p1 + p2 As there are many colors, it can be challenging to visualize which voxel belongs to which cluster. We have a few strategies to help with this. Setting the label parameter places a colored box at the median of each cluster (see the plot above). You can also use the cells.highlight parameter to demarcate particular cells of interest on a SpatialDimPlot() . This can be very useful for distinguishing the spatial localization of individual clusters, as we show below: sourceCode R SpatialDimPlot(brain, cells.highlight = CellsByIdentities(object = brain, idents = c(2, 1, 4, 3, 5, 8)), facet.highlight = TRUE, ncol = 3) Interactive plotting anchor We have also built in a number of interactive plotting capabilities. Both SpatialDimPlot() and SpatialFeaturePlot() now have an interactive parameter, that when set to TRUE , will open up the Rstudio viewer pane with an interactive Shiny plot. The example below demonstrates an interactive SpatialDimPlot() in which you can hover over spots and view the cell name and current identity class (analogous to the previous do.hover behavior). sourceCode R SpatialDimPlot(brain, interactive = TRUE) Interactive SpatialDimPlot Demonstration - YouTube Satija Lab 3.04K subscribers Interactive SpatialDimPlot Demonstration Satija Lab Search Watch later Share Copy link Info Shopping Tap to unmute If playback doesn't begin shortly, try restarting your device. More videos More videos You're signed out Videos you watch may be added to the TV's watch history and influence TV recommendations. To avoid this, cancel and sign in to YouTube on your computer. CancelConfirm Share Include playlist An error occurred while retrieving sharing information. Please try again later. Watch on 0:00 0:00 / 0:08•Live • Watch on YouTube For SpatialFeaturePlot() , setting interactive to TRUE brings up an interactive pane in which you can adjust the transparency of the spots, the point size, as well as the Assay and feature being plotted. After exploring the data, selecting the done button will return the last active plot as a ggplot object. sourceCode R SpatialFeaturePlot(brain, features = \"Ttr\", interactive = TRUE) Interactive SpatialFeaturePlot Demonstration - YouTube Satija Lab 3.04K subscribers Interactive SpatialFeaturePlot Demonstration Satija Lab Search Watch later Share Copy link Info Shopping Tap to unmute If playback doesn't begin shortly, try restarting your device. More videos More videos You're signed out Videos you watch may be added to the TV's watch history and influence TV recommendations. To avoid this, cancel and sign in to YouTube on your computer. CancelConfirm Share Include playlist An error occurred while retrieving sharing information. Please try again later. Watch on 0:00 0:00 / 0:06•Live • Watch on YouTube The LinkedDimPlot() function links the UMAP representation to the tissue image representation and allows for interactive selection. For example, you can select a region in the UMAP plot and the corresponding spots in the image representation will be highlighted. sourceCode R LinkedDimPlot(brain) LinkedDimPlot Demonstration - YouTube Satija Lab 3.04K subscribers LinkedDimPlot Demonstration Satija Lab Search Watch later Share Copy link Info Shopping Tap to unmute If playback doesn't begin shortly, try restarting your device. More videos More videos You're signed out Videos you watch may be added to the TV's watch history and influence TV recommendations. To avoid this, cancel and sign in to YouTube on your computer. CancelConfirm Share Include playlist An error occurred while retrieving sharing information. Please try again later. Watch on 0:00 0:00 / 0:11•Live • Watch on YouTube Identification of Spatially Variable Features anchor Seurat offers two workflows to identify molecular features that correlate with spatial location within a tissue. The first is to perform differential expression based on pre-annotated anatomical regions within the tissue, which may be determined either from unsupervised clustering or prior knowledge. This strategy works will in this case, as the clusters above exhibit clear spatial restriction. sourceCode R de_markers <- FindMarkers(brain, ident.1 = 5, ident.2 = 6) SpatialFeaturePlot(object = brain, features = rownames(de_markers)[1:3], alpha = c(0.1, 1), ncol = 3) An alternative approach, implemented in FindSpatiallyVariables() , is to search for features exhibiting spatial patterning in the absence of pre-annotation. The default method ( method = 'markvariogram ), is inspired by the Trendsceek , which models spatial transcriptomics data as a mark point process and computes a ‘variogram’, which identifies genes whose expression level is dependent on their spatial location. More specifically, this process calculates gamma(r) values measuring the dependence between two spots a certain “r” distance apart. By default, we use an r-value of ‘5’ in these analyses, and only compute these values for variable genes (where variation is calculated independently of spatial location) to save time. We note that there are multiple methods in the literature to accomplish this task, including SpatialDE , and Splotch . We encourage interested users to explore these methods, and hope to add support for them in the near future. sourceCode R brain <- FindSpatiallyVariableFeatures(brain, assay = \"SCT\", features = VariableFeatures(brain)[1:1000], selection.method = \"moransi\") Now we visualize the expression of the top 6 features identified by this measure. sourceCode R top.features <- head(SpatiallyVariableFeatures(brain, selection.method = \"moransi\"), 6) SpatialFeaturePlot(brain, features = top.features, ncol = 3, alpha = c(0.1, 1)) Subset out anatomical regions anchor As with single-cell objects, you can subset the object to focus on a subset of data. Here, we approximately subset the frontal cortex. This process also facilitates the integration of these data with a cortical scRNA-seq dataset in the next section. First, we take a subset of clusters, and then further segment based on exact positions. After subsetting, we can visualize the cortical cells either on the full image, or a cropped image. ```sourceCode R cortex <- subset(brain, idents = c(1, 2, 3, 4, 6, 7)) now remove additional cells, use SpatialDimPlots to visualize what to remove SpatialDimPlot(cortex,cells.highlight = WhichCells(cortex, expression = image_imagerow > 400 | image_imagecol < 150)) cortex <- subset(cortex, anterior1_imagerow > 400 | anterior1_imagecol < 150, invert = TRUE) cortex <- subset(cortex, anterior1_imagerow > 275 & anterior1_imagecol > 370, invert = TRUE) cortex <- subset(cortex, anterior1_imagerow > 250 & anterior1_imagecol > 440, invert = TRUE) ``` sourceCode R p1 <- SpatialDimPlot(cortex, crop = TRUE, label = TRUE) p2 <- SpatialDimPlot(cortex, crop = FALSE, label = TRUE, pt.size.factor = 1, label.size = 3) p1 + p2 Integration with single-cell data anchor At ~50um, spots from the visium assay will encompass the expression profiles of multiple cells. For the growing list of systems where scRNA-seq data is available, users may be interested to ‘deconvolute’ each of the spatial voxels to predict the underlying composition of cell types. In preparing this vignette, we tested a wide variety of decovonlution and integration methods, using a reference scRNA-seq dataset of ~14,000 adult mouse cortical cell taxonomy from the Allen Institute, generated with the SMART-Seq2 protocol. We consistently found superior performance using integration methods (as opposed to deconvolution methods), likely because of substantially different noise models that characterize spatial and single-cell datasets, and integration methods are specifiically designed to be robust to these differences. We therefore apply the ‘anchor’-based integration workflow introduced in Seurat v3 , that enables the probabilistic transfer of annotations from a reference to a query set. We therefore follow the label transfer workflow introduced here , taking advantage of sctransform normalization, but anticipate new methods to be developed to accomplish this task. We first load the data (download available here ), pre-process the scRNA-seq reference, and then perform label transfer. The procedure outputs, for each spot, a probabilistic classification for each of the scRNA-seq derived classes. We add these predictions as a new assay in the Seurat object. sourceCode R allen_reference <- readRDS(\"/brahms/shared/vignette-data/allen_cortex.rds\") ```sourceCode R note that setting ncells=3000 normalizes the full dataset but learns noise models on 3k cells this speeds up SCTransform dramatically with no loss in performance library(dplyr) allen_reference <- SCTransform(allen_reference, ncells = 3000, verbose = FALSE) %>% RunPCA(verbose = FALSE) %>% RunUMAP(dims = 1:30) ``` ```sourceCode R After subsetting, we renormalize cortex cortex <- SCTransform(cortex, assay = \"Spatial\", verbose = FALSE) %>% RunPCA(verbose = FALSE) the annotation is stored in the 'subclass' column of object metadata DimPlot(allen_reference, group.by = \"subclass\", label = TRUE) ``` sourceCode R anchors <- FindTransferAnchors(reference = allen_reference, query = cortex, normalization.method = \"SCT\") predictions.assay <- TransferData(anchorset = anchors, refdata = allen_reference$subclass, prediction.assay = TRUE, weight.reduction = cortex[[\"pca\"]], dims = 1:30) cortex[[\"predictions\"]] <- predictions.assay Now we get prediction scores for each spot for each class. Of particular interest in the frontal cortex region are the laminar excitatory neurons. Here we can distinguish between distinct sequential layers of these neuronal subtypes, for example: sourceCode R DefaultAssay(cortex) <- \"predictions\" SpatialFeaturePlot(cortex, features = c(\"L2/3 IT\", \"L4\"), pt.size.factor = 1.6, ncol = 2, crop = TRUE) Based on these prediction scores, we can also predict cell types whose location is spatially restricted. We use the same methods based on marked point processes to define spatially variable features, but use the cell type prediction scores as the “marks” rather than gene expression. sourceCode R cortex <- FindSpatiallyVariableFeatures(cortex, assay = \"predictions\", selection.method = \"moransi\", features = rownames(cortex), r.metric = 5, slot = \"data\") top.clusters <- head(SpatiallyVariableFeatures(cortex, selection.method = \"moransi\"), 4) SpatialPlot(object = cortex, features = top.clusters, ncol = 2) Finally, we show that our integrative procedure is capable of recovering the known spatial localization patterns of both neuronal and non-neuronal subsets, including laminar excitatory, layer-1 astrocytes, and the cortical grey matter. sourceCode R SpatialFeaturePlot(cortex, features = c(\"Astro\", \"L2/3 IT\", \"L4\", \"L5 PT\", \"L5 IT\", \"L6 CT\", \"L6 IT\", \"L6b\", \"Oligo\"), pt.size.factor = 1, ncol = 2, crop = FALSE, alpha = c(0.1, 1)) Working with multiple slices in Seurat anchor This dataset of the mouse brain contains another slice corresponding to the other half of the brain. Here we read it in and perform the same initial normalization. sourceCode R brain2 <- LoadData(\"stxBrain\", type = \"posterior1\") brain2 <- SCTransform(brain2, assay = \"Spatial\", verbose = FALSE) In order to work with multiple slices in the same Seurat object, we provide the merge function. sourceCode R brain.merge <- merge(brain, brain2) This then enables joint dimensional reduction and clustering on the underlying RNA expression data. sourceCode R DefaultAssay(brain.merge) <- \"SCT\" VariableFeatures(brain.merge) <- c(VariableFeatures(brain), VariableFeatures(brain2)) brain.merge <- RunPCA(brain.merge, verbose = FALSE) brain.merge <- FindNeighbors(brain.merge, dims = 1:30) brain.merge <- FindClusters(brain.merge, verbose = FALSE) brain.merge <- RunUMAP(brain.merge, dims = 1:30) Finally, the data can be jointly visualized in a single UMAP plot. SpatialDimPlot() and SpatialFeaturePlot() will by default plot all slices as columns and groupings/features as rows. sourceCode R DimPlot(brain.merge, reduction = \"umap\", group.by = c(\"ident\", \"orig.ident\")) sourceCode R SpatialDimPlot(brain.merge) sourceCode R SpatialFeaturePlot(brain.merge, features = c(\"Hpca\", \"Plp1\")) Acknowledgments anchor We would like to thank Nigel Delaney and Stephen Williams for their helpful feedback and contributions to the new spatial Seurat code. Slide-seq anchor Dataset anchor Here, we will be analyzing a dataset generated using Slide-seq v2 of the mouse hippocampus. This tutorial will follow much of the same structure as the spatial vignette for 10x Visium data but is tailored to give a demonstration specific to Slide-seq data. You can use our SeuratData package for easy data access, as demonstrated below. After installing the dataset, you can type ?ssHippo to see the commands used to create the Seurat object. sourceCode R InstallData(\"ssHippo\") sourceCode R slide.seq <- LoadData(\"ssHippo\") Data preprocessing anchor The initial preprocessing steps for the bead by gene expression data are similar to other spatial Seurat analyses and to typical scRNA-seq experiments. Here, we note that many beads contain particularly low UMI counts but choose to keep all detected beads for downstream analysis. sourceCode R plot1 <- VlnPlot(slide.seq, features = \"nCount_Spatial\", pt.size = 0, log = TRUE) + NoLegend() slide.seq$log_nCount_Spatial <- log(slide.seq$nCount_Spatial) plot2 <- SpatialFeaturePlot(slide.seq, features = \"log_nCount_Spatial\") + theme(legend.position = \"right\") wrap_plots(plot1, plot2) We then normalize the data using sctransform and perform a standard scRNA-seq dimensionality reduction and clustering workflow. sourceCode R slide.seq <- SCTransform(slide.seq, assay = \"Spatial\", ncells = 3000, verbose = FALSE) slide.seq <- RunPCA(slide.seq) slide.seq <- RunUMAP(slide.seq, dims = 1:30) slide.seq <- FindNeighbors(slide.seq, dims = 1:30) slide.seq <- FindClusters(slide.seq, resolution = 0.3, verbose = FALSE) We can then visualize the results of the clustering either in UMAP space (with DimPlot() ) or in the bead coordinate space with SpatialDimPlot() . sourceCode R plot1 <- DimPlot(slide.seq, reduction = \"umap\", label = TRUE) plot2 <- SpatialDimPlot(slide.seq, stroke = 0) plot1 + plot2 sourceCode R SpatialDimPlot(slide.seq, cells.highlight = CellsByIdentities(object = slide.seq, idents = c(1, 6, 13)), facet.highlight = TRUE) Integration with a scRNA-seq reference anchor To facilitate cell-type annotation of the Slide-seq dataset, we are leveraging an existing mouse single-cell RNA-seq hippocampus dataset, produced in Saunders*, Macosko*, et al. 2018 . The data is available for download as a processed Seurat object here , with the raw count matrices available on the DropViz website . sourceCode R ref <- readRDS(\"/brahms/shared/vignette-data/mouse_hippocampus_reference.rds\") ref <- UpdateSeuratObject(ref) The original annotations from the paper are provided in the cell metadata of the Seurat object. These annotations are provided at several “resolutions”, from broad classes ( ref$class ) to subclusters within celltypes ( ref$subcluster ). For the purposes of this vignette, we’ll work off of a modification of the celltype annotations ( ref$celltype ) which we felt struck a good balance. We’ll start by running the Seurat label transfer method to predict the major celltype for each bead. sourceCode R anchors <- FindTransferAnchors(reference = ref, query = slide.seq, normalization.method = \"SCT\", npcs = 50) predictions.assay <- TransferData(anchorset = anchors, refdata = ref$celltype, prediction.assay = TRUE, weight.reduction = slide.seq[[\"pca\"]], dims = 1:50) slide.seq[[\"predictions\"]] <- predictions.assay We can then visualize the prediction scores for some of the major expected classes. sourceCode R DefaultAssay(slide.seq) <- \"predictions\" SpatialFeaturePlot(slide.seq, features = c(\"Dentate Principal cells\", \"CA3 Principal cells\", \"Entorhinal cortex\", \"Endothelial tip\", \"Ependymal\", \"Oligodendrocyte\"), alpha = c(0.1, 1)) sourceCode R slide.seq$predicted.id <- GetTransferPredictions(slide.seq) Idents(slide.seq) <- \"predicted.id\" SpatialDimPlot(slide.seq, cells.highlight = CellsByIdentities(object = slide.seq, idents = c(\"CA3 Principal cells\", \"Dentate Principal cells\", \"Endothelial tip\")), facet.highlight = TRUE) Identification of Spatially Variable Features anchor As mentioned in the Visium vignette, we can identify spatially variable features in two general ways: differential expression testing between pre-annotated anatomical regions or statistics that measure the dependence of a feature on spatial location. Here, we demonstrate the latter with an implementation of Moran’s I available via FindSpatiallyVariableFeatures() by setting method = 'moransi' . Moran’s I computes an overall spatial autocorrelation and gives a statistic (similar to a correlation coefficient) that measures the dependence of a feature on spatial location. This allows us to rank features based on how spatially variable their expression is. In order to facilitate quick estimation of this statistic, we implemented a basic binning strategy that will draw a rectangular grid over Slide-seq puck and average the feature and location within each bin. The number of bins in the x and y direction are controlled by the x.cuts and y.cuts parameters respectively. Additionally, while not required, installing the optional Rfast2 package( install.packages('Rfast2') ), will significantly decrease the runtime via a more efficient implementation. sourceCode R DefaultAssay(slide.seq) <- \"SCT\" slide.seq <- FindSpatiallyVariableFeatures(slide.seq, assay = \"SCT\", slot = \"scale.data\", features = VariableFeatures(slide.seq)[1:1000], selection.method = \"moransi\", x.cuts = 100, y.cuts = 100) Now we visualize the expression of the top 6 features identified by Moran’s I. sourceCode R SpatialFeaturePlot(slide.seq, features = head(SpatiallyVariableFeatures(slide.seq, selection.method = \"moransi\"), 6), ncol = 3, alpha = c(0.1, 1), max.cutoff = \"q95\") Spatial deconvolution using RCTD anchor While FindTransferAnchors can be used to integrate spot-level data from spatial transcriptomic datasets, Seurat v5 also includes support for the Robust Cell Type Decomposition , a computational approach to deconvolve spot-level data from spatial datasets, when provided with an scRNA-seq reference. RCTD has been shown to accurately annotate spatial data from a variety of technologies, including SLIDE-seq, Visium, and the 10x Xenium in-situ spatial platform. To run RCTD, we first install the spacexr package from GitHub which implements RCTD. sourceCode R devtools::install_github(\"dmcable/spacexr\", build_vignettes = FALSE) Counts, cluster, and spot information is extracted from the Seurat query and reference objects to construct Reference and SpatialRNA objects used by RCTD for annotation. ```sourceCode R library(spacexr) set up reference ref <- readRDS(\"../data/mouse_hippocampus_reference.rds\") ref <- UpdateSeuratObject(ref) Idents(ref) <- \"celltype\" extract information to pass to the RCTD Reference function counts <- ref[[\"RNA\"]]$counts cluster <- as.factor(ref$celltype) names(cluster) <- colnames(ref) nUMI <- ref$nCount_RNA names(nUMI) <- colnames(ref) reference <- Reference(counts, cluster, nUMI) set up query with the RCTD function SpatialRNA slide.seq <- SeuratData::LoadData(\"ssHippo\") counts <- slide.seq[[\"Spatial\"]]$counts coords <- GetTissueCoordinates(slide.seq) colnames(coords) <- c(\"x\", \"y\") coords[is.na(colnames(coords))] <- NULL query <- SpatialRNA(coords, counts, colSums(counts)) ``` Using the reference and query object, we annotate the dataset and add the cell type labels to the query Seurat object. RCTD parallelizes well, so multiple cores can be specified for faster performance. sourceCode R RCTD <- create.RCTD(query, reference, max_cores = 8) RCTD <- run.RCTD(RCTD, doublet_mode = \"doublet\") slide.seq <- AddMetaData(slide.seq, metadata = RCTD@results$results_df) Next, plot the RCTD annotations. Because we ran RCTD in doublet mode, the algorithm assigns a first_type and second_type for each barcode or spot. sourceCode R p1 <- SpatialDimPlot(slide.seq, group.by = \"first_type\") p2 <- SpatialDimPlot(slide.seq, group.by = \"second_type\") p1 | p2 Session Info sourceCode R sessionInfo() ``` R version 4.2.2 Patched (2022-11-10 r83330) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.6 LTS Matrix products: default BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats graphics grDevices utils datasets methods base other attached packages: [1] spacexr_2.2.1 vembedr_0.1.5 [3] htmltools_0.5.6.1 dplyr_1.1.3 [5] patchwork_1.1.3 ggplot2_3.4.4 [7] thp1.eccite.SeuratData_3.1.5 stxBrain.SeuratData_0.1.1 [9] ssHippo.SeuratData_3.1.4 pbmcsca.SeuratData_3.0.0 [11] pbmcref.SeuratData_1.0.0 pbmcMultiome.SeuratData_0.1.4 [13] pbmc3k.SeuratData_3.1.4 panc8.SeuratData_3.0.2 [15] ifnb.SeuratData_3.0.0 hcabm40k.SeuratData_3.0.0 [17] cbmc.SeuratData_3.1.4 bmcite.SeuratData_0.3.0 [19] SeuratData_0.2.2.9001 Seurat_5.0.0 [21] SeuratObject_5.0.0 sp_2.1-1 loaded via a namespace (and not attached): [1] utf8_1.2.4 spatstat.explore_3.2-5 [3] reticulate_1.34.0 tidyselect_1.2.0 [5] htmlwidgets_1.6.2 grid_4.2.2 [7] Rtsne_0.16 munsell_0.5.0 [9] codetools_0.2-19 ragg_1.2.5 [11] ica_1.0-3 future_1.33.0 [13] miniUI_0.1.1.1 withr_2.5.2 [15] spatstat.random_3.2-1 colorspace_2.1-0 [17] progressr_0.14.0 Biobase_2.58.0 [19] highr_0.10 knitr_1.45 [21] stats4_4.2.2 ROCR_1.0-11 [23] tensor_1.5 listenv_0.9.0 [25] MatrixGenerics_1.10.0 labeling_0.4.3 [27] GenomeInfoDbData_1.2.9 polyclip_1.10-6 [29] farver_2.1.1 rprojroot_2.0.3 [31] parallelly_1.36.0 vctrs_0.6.4 [33] generics_0.1.3 xfun_0.40 [35] doParallel_1.0.17 R6_2.5.1 [37] GenomeInfoDb_1.34.9 ggbeeswarm_0.7.1 [39] RcppZiggurat_0.1.6 DelayedArray_0.24.0 [41] bitops_1.0-7 spatstat.utils_3.0-4 [43] cachem_1.0.8 assertthat_0.2.1 [45] promises_1.2.1 scales_1.2.1 [47] beeswarm_0.4.0 gtable_0.3.4 [49] globals_0.16.2 goftest_1.2-3 [51] spam_2.10-0 rlang_1.1.1 [53] systemfonts_1.0.4 splines_4.2.2 [55] lazyeval_0.2.2 spatstat.geom_3.2-7 [57] yaml_2.3.7 reshape2_1.4.4 [59] abind_1.4-5 Rfast_2.0.8 [61] httpuv_1.6.12 tools_4.2.2 [63] ellipsis_0.3.2 jquerylib_0.1.4 [65] RColorBrewer_1.1-3 BiocGenerics_0.44.0 [67] ggridges_0.5.4 Rcpp_1.0.11 [69] plyr_1.8.9 sparseMatrixStats_1.10.0 [71] zlibbioc_1.44.0 purrr_1.0.2 [73] RCurl_1.98-1.12 deldir_1.0-9 [75] pbapply_1.7-2 cowplot_1.1.1 [77] S4Vectors_0.36.2 zoo_1.8-12 [79] SummarizedExperiment_1.28.0 ggrepel_0.9.4 [81] cluster_2.1.4 fs_1.6.3 [83] magrittr_2.0.3 data.table_1.14.8 [85] RSpectra_0.16-1 glmGamPoi_1.10.2 [87] scattermore_1.2 lmtest_0.9-40 [89] RANN_2.6.1 fitdistrplus_1.1-11 [91] matrixStats_1.0.0 mime_0.12 [93] evaluate_0.22 xtable_1.8-4 [95] fastDummies_1.7.3 IRanges_2.32.0 [97] gridExtra_2.3 compiler_4.2.2 [99] tibble_3.2.1 KernSmooth_2.23-22 [101] crayon_1.5.2 later_1.3.1 [103] tidyr_1.3.0 RcppParallel_5.1.7 [105] Rfast2_0.1.5.1 formatR_1.14 [107] MASS_7.3-58.2 rappdirs_0.3.3 [109] Matrix_1.6-1.1 cli_3.6.1 [111] quadprog_1.5-8 parallel_4.2.2 [113] dotCall64_1.1-0 igraph_1.5.1 [115] GenomicRanges_1.50.2 pkgconfig_2.0.3 [117] pkgdown_2.0.7 plotly_4.10.3 [119] spatstat.sparse_3.0-3 foreach_1.5.2 [121] vipor_0.4.5 bslib_0.5.1 [123] XVector_0.38.0 stringr_1.5.0 [125] digest_0.6.33 sctransform_0.4.1 [127] RcppAnnoy_0.0.21 spatstat.data_3.0-3 [129] rmarkdown_2.25 leiden_0.4.3 [131] uwot_0.1.16 DelayedMatrixStats_1.20.0 [133] shiny_1.7.5.1 lifecycle_1.0.3 [135] nlme_3.1-162 jsonlite_1.8.7 [137] limma_3.54.1 desc_1.4.2 [139] viridisLite_0.4.2 fansi_1.0.5 [141] pillar_1.9.0 lattice_0.21-9 [143] ggrastr_1.0.1 fastmap_1.1.1 [145] httr_1.4.7 survival_3.5-7 [147] glue_1.6.2 iterators_1.0.14 [149] png_0.1-8 presto_1.0.0 [151] stringi_1.7.12 sass_0.4.7 [153] textshaping_0.3.6 RcppHNSW_0.5.0 [155] memoise_2.0.1 irlba_2.3.5.1 [157] future.apply_1.11.0 ```",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/spatial_vignette",
      "title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat • Seurat",
      "robots": [
        "noindex",
        "noindex",
        "noindex"
      ],
      "ogTitle": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "language": "en",
      "og:title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "scrapeId": "872abaa9-3d3e-48f5-b469-492a8a04b088",
      "viewport": [
        "width=device-width, initial-scale=1.0",
        "width=device-width, initial-scale=1",
        "width=device-width, initial-scale=1",
        "width=device-width, initial-scale=1"
      ],
      "sourceURL": "https://satijalab.org/seurat/articles/spatial_vignette",
      "statusCode": 200,
      "ogDescription": "Seurat",
      "og:description": "Seurat"
    }
  },
  {
    "processed_text": "",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/seurat5_dim_reduction_vignette.html",
      "error": "Not Found",
      "scrapeId": "8aa156a3-75c9-4c08-b197-487d5fc51266",
      "sourceURL": "https://satijalab.org/seurat/articles/seurat5_dim_reduction_vignette.html",
      "statusCode": 404
    }
  },
  {
    "processed_text": "Integrative analysis in Seurat v5 Compiled: October 31, 2023 Source: vignettes/seurat5_integration.Rmd seurat5_integration.Rmd ``` library(Seurat) library(SeuratData) library(SeuratWrappers) library(Azimuth) library(ggplot2) library(patchwork) options(future.globals.maxSize = 1e9) ``` Introduction anchor Integration of single-cell sequencing datasets, for example across experimental batches, donors, or conditions, is often an important step in scRNA-seq workflows. Integrative analysis can help to match shared cell types and states across datasets, which can boost statistical power, and most importantly, facilitate accurate comparative analysis across datasets. In previous versions of Seurat we introduced methods for integrative analysis, including our ‘anchor-based’ integration workflow. Many labs have also published powerful and pioneering methods, including Harmony and scVI , for integrative analysis. We recognize that while the goal of matching shared cell types across datasets may be important for many problems, users may also be concerned about which method to use, or that integration could result in a loss of biological resolution. In Seurat v5, we introduce more flexible and streamlined infrastructure to run different integration algorithms with a single line of code. This makes it easier to explore the results of different integration methods, and to compare these results to a workflow that excludes integration steps. For this vignette, we use a dataset of human PBMC profiled with seven different technologies , profiled as part of a systematic comparative analysis ( pbmcsca ). The data is available as part of our SeuratData package. Layers in the Seurat v5 object anchor Seurat v5 assays store data in layers. These layers can store raw, un-normalized counts ( layer='counts' ), normalized data ( layer='data' ), or z-scored/variance-stabilized data ( layer='scale.data' ). We can load in the data, remove low-quality cells, and obtain predicted cell annotations (which will be useful for assessing integration later), using our Azimuth pipeline . ```sourceCode R load in the pbmc systematic comparative analysis dataset obj <- LoadData(\"pbmcsca\") obj <- subset(obj, nFeature_RNA > 1000) obj <- RunAzimuth(obj, reference = \"pbmcref\") currently, the object has two layers in the RNA assay: counts, and data obj ``` ``` An object of class Seurat 33789 features across 10434 samples within 4 assays Active assay: RNA (33694 features, 0 variable features) 2 layers present: counts, data 3 other assays present: prediction.score.celltype.l1, prediction.score.celltype.l2, prediction.score.celltype.l3 2 dimensional reductions calculated: integrated_dr, ref.umap ``` The object contains data from nine different batches (stored in the Method column in the object metadata), representing seven different technologies. We will aim to integrate the different batches together. In previous versions of Seurat, we would require the data to be represented as nine different Seurat objects. When using Seurat v5 assays, we can instead keep all the data in one object, but simply split the layers. After splitting, there are now 18 layers (a counts and data layer for each batch). We can also run a standard scRNA-seq analysis (i.e. without integration). Note that since the data is split into layers, normalization and variable feature identification is performed for each batch independently (a consensus set of variable features is automatically identified). sourceCode R obj[[\"RNA\"]] <- split(obj[[\"RNA\"]], f = obj$Method) obj ``` An object of class Seurat 33789 features across 10434 samples within 4 assays Active assay: RNA (33694 features, 0 variable features) 18 layers present: counts.Smart-seq2, counts.CEL-Seq2, counts.10x_Chromium_v2_A, counts.10x_Chromium_v2_B, counts.10x_Chromium_v3, counts.Drop-seq, counts.Seq-Well, counts.inDrops, counts.10x_Chromium_v2, data.Smart-seq2, data.CEL-Seq2, data.10x_Chromium_v2_A, data.10x_Chromium_v2_B, data.10x_Chromium_v3, data.Drop-seq, data.Seq-Well, data.inDrops, data.10x_Chromium_v2 3 other assays present: prediction.score.celltype.l1, prediction.score.celltype.l2, prediction.score.celltype.l3 2 dimensional reductions calculated: integrated_dr, ref.umap ``` sourceCode R obj <- NormalizeData(obj) obj <- FindVariableFeatures(obj) obj <- ScaleData(obj) obj <- RunPCA(obj) We can now visualize the results of a standard analysis without integration. Note that cells are grouping both by cell type and by underlying method. While a UMAP analysis is just a visualization of this, clustering this dataset would return predominantly batch-specific clusters. Especially if previous cell-type annotations were not available, this would make downstream analysis extremely challenging. sourceCode R obj <- FindNeighbors(obj, dims = 1:30, reduction = \"pca\") obj <- FindClusters(obj, resolution = 2, cluster.name = \"unintegrated_clusters\") ``` Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck Number of nodes: 10434 Number of edges: 412660 Running Louvain algorithm... Maximum modularity in 10 random starts: 0.8981 Number of communities: 48 Elapsed time: 0 seconds ``` ```sourceCode R obj <- RunUMAP(obj, dims = 1:30, reduction = \"pca\", reduction.name = \"umap.unintegrated\") visualize by batch and cell type annotation cell type annotations were previously added by Azimuth DimPlot(obj, reduction = \"umap.unintegrated\", group.by = c(\"Method\", \"predicted.celltype.l2\")) ``` Perform streamlined (one-line) integrative analysis anchor Seurat v5 enables streamlined integrative analysis using the IntegrateLayers function. The method currently supports five integration methods. Each of these methods performs integration in low-dimensional space, and returns a dimensional reduction (i.e. integrated.rpca ) that aims to co-embed shared cell types across batches: Anchor-based CCA integration ( method=CCAIntegration ) Anchor-based RPCA integration ( method=RPCAIntegration ) Harmony ( method=HarmonyIntegration ) FastMNN ( method= FastMNNIntegration ) scVI ( method=scVIIntegration ) Note that our anchor-based RPCA integration represents a faster and more conservative (less correction) method for integration. For interested users, we discuss this method in more detail in our previous RPCA vignette You can find more detail on each method, and any installation prerequisites, in Seurat’s documentation (for example, ?scVIIntegration ). For example, scVI integration requires reticulate which can be installed from CRAN ( install.packages(\"reticulate\") ) as well as scvi-tools and its dependencies installed in a conda environment. Please see scVI installation instructions here . Each of the following lines perform a new integration using a single line of code: sourceCode R obj <- IntegrateLayers( object = obj, method = CCAIntegration, orig.reduction = \"pca\", new.reduction = \"integrated.cca\", verbose = FALSE ) sourceCode R obj <- IntegrateLayers( object = obj, method = RPCAIntegration, orig.reduction = \"pca\", new.reduction = \"integrated.rpca\", verbose = FALSE ) sourceCode R obj <- IntegrateLayers( object = obj, method = HarmonyIntegration, orig.reduction = \"pca\", new.reduction = \"harmony\", verbose = FALSE ) sourceCode R obj <- IntegrateLayers( object = obj, method = FastMNNIntegration, new.reduction = \"integrated.mnn\", verbose = FALSE ) sourceCode R obj <- IntegrateLayers( object = obj, method = scVIIntegration, new.reduction = \"integrated.scvi\", conda_env = \"../miniconda3/envs/scvi-env\", verbose = FALSE ) For any of the methods, we can now visualize and cluster the datasets. We show this for CCA integration and scVI, but you can do this for any method sourceCode R obj <- FindNeighbors(obj, reduction = \"integrated.cca\", dims = 1:30) obj <- FindClusters(obj, resolution = 2, cluster.name = \"cca_clusters\") ``` Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck Number of nodes: 10434 Number of edges: 617402 Running Louvain algorithm... Maximum modularity in 10 random starts: 0.8037 Number of communities: 25 Elapsed time: 1 seconds ``` ```sourceCode R obj <- RunUMAP(obj, reduction = \"integrated.cca\", dims = 1:30, reduction.name = \"umap.cca\") p1 <- DimPlot( obj, reduction = \"umap.cca\", group.by = c(\"Method\", \"predicted.celltype.l2\", \"cca_clusters\"), combine = FALSE, label.size = 2 ) obj <- FindNeighbors(obj, reduction = \"integrated.scvi\", dims = 1:30) obj <- FindClusters(obj, resolution = 2, cluster.name = \"scvi_clusters\") ``` ``` Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck Number of nodes: 10434 Number of edges: 354664 Running Louvain algorithm... Maximum modularity in 10 random starts: 0.7942 Number of communities: 22 Elapsed time: 1 seconds ``` ```sourceCode R obj <- RunUMAP(obj, reduction = \"integrated.scvi\", dims = 1:30, reduction.name = \"umap.scvi\") p2 <- DimPlot( obj, reduction = \"umap.scvi\", group.by = c(\"Method\", \"predicted.celltype.l2\", \"scvi_clusters\"), combine = FALSE, label.size = 2 ) wrap_plots(c(p1, p2), ncol = 2, byrow = F) ``` We hope that by simplifying the process of performing integrative analysis, users can more carefully evaluate the biological information retained in the integrated dataset. For example, users can compare the expression of biological markers based on different clustering solutions, or visualize one method’s clustering solution on different UMAP visualizations. sourceCode R p1 <- VlnPlot( obj, features = \"rna_CD8A\", group.by = \"unintegrated_clusters\" ) + NoLegend() + ggtitle(\"CD8A - Unintegrated Clusters\") p2 <- VlnPlot( obj, \"rna_CD8A\", group.by = \"cca_clusters\" ) + NoLegend() + ggtitle(\"CD8A - CCA Clusters\") p3 <- VlnPlot( obj, \"rna_CD8A\", group.by = \"scvi_clusters\" ) + NoLegend() + ggtitle(\"CD8A - scVI Clusters\") p1 | p2 | p3 sourceCode R obj <- RunUMAP(obj, reduction = \"integrated.rpca\", dims = 1:30, reduction.name = \"umap.rpca\") p4 <- DimPlot(obj, reduction = \"umap.unintegrated\", group.by = c(\"cca_clusters\")) p5 <- DimPlot(obj, reduction = \"umap.rpca\", group.by = c(\"cca_clusters\")) p6 <- DimPlot(obj, reduction = \"umap.scvi\", group.by = c(\"cca_clusters\")) p4 | p5 | p6 Once integrative analysis is complete, you can rejoin the layers - which collapses the individual datasets together and recreates the original counts and data layers. You will need to do this before performing any differential expression analysis. However, you can always resplit the layers in case you would like to reperform integrative analysis. sourceCode R obj <- JoinLayers(obj) obj ``` An object of class Seurat 35789 features across 10434 samples within 5 assays Active assay: RNA (33694 features, 2000 variable features) 3 layers present: data, counts, scale.data 4 other assays present: prediction.score.celltype.l1, prediction.score.celltype.l2, prediction.score.celltype.l3, mnn.reconstructed 12 dimensional reductions calculated: integrated_dr, ref.umap, pca, umap.unintegrated, integrated.cca, integrated.rpca, harmony, integrated.mnn, integrated.scvi, umap.cca, umap.scvi, umap.rpca ``` Lastly, users can also perform integration using sctransform-normalized data (see our SCTransform vignette for more information), by first running SCTransform normalization, and then setting the normalization.method argument in IntegrateLayers . sourceCode R options(future.globals.maxSize = 3e+09) obj <- SCTransform(obj) obj <- RunPCA(obj, npcs = 30, verbose = F) obj <- IntegrateLayers( object = obj, method = RPCAIntegration, normalization.method = \"SCT\", verbose = F ) obj <- FindNeighbors(obj, dims = 1:30, reduction = \"integrated.dr\") obj <- FindClusters(obj, resolution = 2) ``` Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck Number of nodes: 10434 Number of edges: 449127 Running Louvain algorithm... Maximum modularity in 10 random starts: 0.8354 Number of communities: 26 Elapsed time: 1 seconds ``` sourceCode R obj <- RunUMAP(obj, dims = 1:30, reduction = \"integrated.dr\") Session Info sourceCode R sessionInfo() ``` R version 4.2.2 Patched (2022-11-10 r83330) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.6 LTS Matrix products: default BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats graphics grDevices utils datasets methods base other attached packages: [1] patchwork_1.1.3 ggplot2_3.4.4 [3] Azimuth_0.4.6.9004 shinyBS_0.61.1 [5] SeuratWrappers_0.3.19 thp1.eccite.SeuratData_3.1.5 [7] stxBrain.SeuratData_0.1.1 ssHippo.SeuratData_3.1.4 [9] pbmcsca.SeuratData_3.0.0 pbmcref.SeuratData_1.0.0 [11] pbmcMultiome.SeuratData_0.1.4 pbmc3k.SeuratData_3.1.4 [13] panc8.SeuratData_3.0.2 ifnb.SeuratData_3.0.0 [15] hcabm40k.SeuratData_3.0.0 cbmc.SeuratData_3.1.4 [17] bmcite.SeuratData_0.3.0 SeuratData_0.2.2.9001 [19] Seurat_5.0.1 SeuratObject_5.0.1 [21] sp_2.1-1 loaded via a namespace (and not attached): [1] rsvd_1.0.5 ica_1.0-3 [3] RcppRoll_0.3.0 Rsamtools_2.14.0 [5] lmtest_0.9-40 rprojroot_2.0.3 [7] crayon_1.5.2 MASS_7.3-58.2 [9] rhdf5filters_1.10.1 nlme_3.1-162 [11] rlang_1.1.1 XVector_0.38.0 [13] ROCR_1.0-11 irlba_2.3.5.1 [15] filelock_1.0.2 BiocParallel_1.32.6 [17] rjson_0.2.21 CNEr_1.34.0 [19] bit64_4.0.5 glue_1.6.2 [21] harmony_1.0.3 poweRlaw_0.70.6 [23] sctransform_0.4.1 vipor_0.4.5 [25] parallel_4.2.2 spatstat.sparse_3.0-3 [27] AnnotationDbi_1.60.2 SeuratDisk_0.0.0.9020 [29] BiocGenerics_0.44.0 shinydashboard_0.7.2 [31] dotCall64_1.1-0 spatstat.geom_3.2-7 [33] tidyselect_1.2.0 SummarizedExperiment_1.28.0 [35] fitdistrplus_1.1-11 XML_3.99-0.14 [37] tidyr_1.3.0 zoo_1.8-12 [39] GenomicAlignments_1.34.1 xtable_1.8-4 [41] RcppHNSW_0.5.0 magrittr_2.0.3 [43] evaluate_0.22 scuttle_1.8.4 [45] cli_3.6.1 zlibbioc_1.44.0 [47] miniUI_0.1.1.1 bslib_0.5.1 [49] fastmatch_1.1-4 ensembldb_2.22.0 [51] fastDummies_1.7.3 shiny_1.7.5.1 [53] BiocSingular_1.14.0 xfun_0.40 [55] cluster_2.1.4 caTools_1.18.2 [57] KEGGREST_1.38.0 tibble_3.2.1 [59] ggrepel_0.9.4 listenv_0.9.0 [61] TFMPvalue_0.0.9 Biostrings_2.66.0 [63] png_0.1-8 future_1.33.0 [65] withr_2.5.2 bitops_1.0-7 [67] plyr_1.8.9 cellranger_1.1.0 [69] AnnotationFilter_1.22.0 pracma_2.4.2 [71] pillar_1.9.0 cachem_1.0.8 [73] GenomicFeatures_1.50.4 fs_1.6.3 [75] hdf5r_1.3.8 DelayedMatrixStats_1.20.0 [77] vctrs_0.6.4 ellipsis_0.3.2 [79] generics_0.1.3 tools_4.2.2 [81] beeswarm_0.4.0 munsell_0.5.0 [83] DelayedArray_0.24.0 fastmap_1.1.1 [85] compiler_4.2.2 abind_1.4-5 [87] httpuv_1.6.12 rtracklayer_1.58.0 [89] plotly_4.10.3 GenomeInfoDbData_1.2.9 [91] gridExtra_2.3 lattice_0.21-9 [93] deldir_1.0-9 utf8_1.2.4 [95] later_1.3.1 dplyr_1.1.3 [97] BiocFileCache_2.6.1 jsonlite_1.8.7 [99] scales_1.2.1 ScaledMatrix_1.6.0 [101] pbapply_1.7-2 sparseMatrixStats_1.10.0 [103] lazyeval_0.2.2 promises_1.2.1 [105] R.utils_2.12.2 goftest_1.2-3 [107] spatstat.utils_3.0-4 reticulate_1.34.0 [109] rmarkdown_2.25 pkgdown_2.0.7 [111] cowplot_1.1.1 textshaping_0.3.6 [113] glmGamPoi_1.10.2 Rtsne_0.16 [115] BSgenome_1.66.3 Biobase_2.58.0 [117] uwot_0.1.16 igraph_1.5.1 [119] survival_3.5-7 ResidualMatrix_1.8.0 [121] yaml_2.3.7 systemfonts_1.0.4 [123] htmltools_0.5.6.1 memoise_2.0.1 [125] BiocIO_1.8.0 IRanges_2.32.0 [127] viridisLite_0.4.2 digest_0.6.33 [129] RhpcBLASctl_0.23-42 mime_0.12 [131] rappdirs_0.3.3 spam_2.10-0 [133] RSQLite_2.3.1 future.apply_1.11.0 [135] remotes_2.4.2.1 data.table_1.14.8 [137] blob_1.2.4 JASPAR2020_0.99.10 [139] S4Vectors_0.36.2 R.oo_1.25.0 [141] TFBSTools_1.36.0 ragg_1.2.5 [143] styler_1.10.2 splines_4.2.2 [145] labeling_0.4.3 Rhdf5lib_1.20.0 [147] googledrive_2.1.1 ProtGenerics_1.30.0 [149] RCurl_1.98-1.12 hms_1.1.3 [151] rhdf5_2.42.1 colorspace_2.1-0 [153] BiocManager_1.30.22 ggbeeswarm_0.7.1 [155] GenomicRanges_1.50.2 Signac_1.12.9000 [157] ggrastr_1.0.1 sass_0.4.7 [159] Rcpp_1.0.11 BSgenome.Hsapiens.UCSC.hg38_1.4.5 [161] RANN_2.6.1 fansi_1.0.5 [163] tzdb_0.4.0 parallelly_1.36.0 [165] R6_2.5.1 grid_4.2.2 [167] ggridges_0.5.4 lifecycle_1.0.3 [169] curl_5.1.0 googlesheets4_1.1.1 [171] leiden_0.4.3 jquerylib_0.1.4 [173] Matrix_1.6-1.1 desc_1.4.2 [175] RcppAnnoy_0.0.21 RColorBrewer_1.1-3 [177] spatstat.explore_3.2-5 stringr_1.5.0 [179] R.cache_0.16.0 htmlwidgets_1.6.2 [181] beachmat_2.14.2 polyclip_1.10-6 [183] biomaRt_2.54.1 purrr_1.0.2 [185] seqLogo_1.64.0 globals_0.16.2 [187] spatstat.random_3.2-1 progressr_0.14.0 [189] batchelor_1.14.1 codetools_0.2-19 [191] matrixStats_1.0.0 GO.db_3.16.0 [193] gtools_3.9.4 prettyunits_1.1.1 [195] SingleCellExperiment_1.20.1 dbplyr_2.3.4 [197] RSpectra_0.16-1 R.methodsS3_1.8.2 [199] GenomeInfoDb_1.34.9 gtable_0.3.4 [201] DBI_1.1.3 stats4_4.2.2 [203] tensor_1.5 httr_1.4.7 [205] highr_0.10 KernSmooth_2.23-22 [207] stringi_1.7.12 presto_1.0.0 [209] progress_1.2.2 reshape2_1.4.4 [211] farver_2.1.1 annotate_1.76.0 [213] DT_0.30 xml2_1.3.5 [215] EnsDb.Hsapiens.v86_2.99.0 shinyjs_2.1.0 [217] BiocNeighbors_1.16.0 restfulr_0.0.15 [219] readr_2.1.4 scattermore_1.2 [221] bit_4.0.5 MatrixGenerics_1.10.0 [223] spatstat.data_3.0-3 pkgconfig_2.0.3 [225] gargle_1.5.2 DirichletMultinomial_1.40.0 [227] knitr_1.45 ```",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/seurat5_integration",
      "title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat • Seurat",
      "ogTitle": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "language": "en",
      "og:title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "scrapeId": "8b348719-8212-455e-8063-ba269ace4d45",
      "viewport": "width=device-width, initial-scale=1.0",
      "sourceURL": "https://satijalab.org/seurat/articles/seurat5_integration",
      "statusCode": 200,
      "ogDescription": "Seurat",
      "og:description": "Seurat"
    }
  },
  {
    "processed_text": "Integrating scRNA-seq and scATAC-seq data Compiled: October 31, 2023 Source: vignettes/seurat5_atacseq_integration_vignette.Rmd seurat5_atacseq_integration_vignette.Rmd Single-cell transcriptomics has transformed our ability to characterize cell states, but deep biological understanding requires more than a taxonomic listing of clusters. As new methods arise to measure distinct cellular modalities, a key analytical challenge is to integrate these datasets to better understand cellular identity and function. For example, users may perform scRNA-seq and scATAC-seq experiments on the same biological system and to consistently annotate both datasets with the same set of cell type labels. This analysis is particularly challenging as scATAC-seq datasets are difficult to annotate, due to both the sparsity of genomic data collected at single-cell resolution, and the lack of interpretable gene markers in scRNA-seq data. In Stuart*, Butler* et al, 2019 , we introduce methods to integrate scRNA-seq and scATAC-seq datasets collected from the same biological system, and demonstrate these methods in this vignette. In particular, we demonstrate the following analyses: How to use an annotated scRNA-seq dataset to label cells from an scATAC-seq experiment How to co-visualize (co-embed) cells from scRNA-seq and scATAC-seq How to project scATAC-seq cells onto a UMAP derived from an scRNA-seq experiment This vignette makes extensive use of the Signac package , recently developed for the analysis of chromatin datasets collected at single-cell resolution, including scATAC-seq. Please see the Signac website for additional vignettes and documentation for analyzing scATAC-seq data. We demonstrate these methods using a publicly available ~12,000 human PBMC ‘multiome’ dataset from 10x Genomics. In this dataset, scRNA-seq and scATAC-seq profiles were simultaneously collected in the same cells. For the purposes of this vignette, we treat the datasets as originating from two different experiments and integrate them together. Since they were originally measured in the same cells, this provides a ground truth that we can use to assess the accuracy of integration. We emphasize that our use of the multiome dataset here is for demonstration and evaluation purposes, and that users should apply these methods to scRNA-seq and scATAC-seq datasets that are collected separately. We provide a separate weighted nearest neighbors vignette (WNN) that describes analysis strategies for multi-omic single-cell data. Load in data and process each modality individually anchor The PBMC multiome dataset is available from 10x genomics . To facilitate easy loading and exploration, it is also available as part of our SeuratData package. We load the RNA and ATAC data in separately, and pretend that these profiles were measured in separate experiments. We annotated these cells in our WNN vignette, and the annotations are also included in SeuratData. ```sourceCode R library(SeuratData) install the dataset and load requirements InstallData(\"pbmcMultiome\") ``` sourceCode R library(Seurat) library(Signac) library(EnsDb.Hsapiens.v86) library(ggplot2) library(cowplot) ```sourceCode R load both modalities pbmc.rna <- LoadData(\"pbmcMultiome\", \"pbmc.rna\") pbmc.atac <- LoadData(\"pbmcMultiome\", \"pbmc.atac\") pbmc.rna[[\"RNA\"]] <- as(pbmc.rna[[\"RNA\"]], Class = \"Assay5\") repeat QC steps performed in the WNN vignette pbmc.rna <- subset(pbmc.rna, seurat_annotations != \"filtered\") pbmc.atac <- subset(pbmc.atac, seurat_annotations != \"filtered\") Perform standard analysis of each modality independently RNA analysis pbmc.rna <- NormalizeData(pbmc.rna) pbmc.rna <- FindVariableFeatures(pbmc.rna) pbmc.rna <- ScaleData(pbmc.rna) pbmc.rna <- RunPCA(pbmc.rna) pbmc.rna <- RunUMAP(pbmc.rna, dims = 1:30) ATAC analysis add gene annotation information annotations <- GetGRangesFromEnsDb(ensdb = EnsDb.Hsapiens.v86) seqlevelsStyle(annotations) <- \"UCSC\" genome(annotations) <- \"hg38\" Annotation(pbmc.atac) <- annotations We exclude the first dimension as this is typically correlated with sequencing depth pbmc.atac <- RunTFIDF(pbmc.atac) pbmc.atac <- FindTopFeatures(pbmc.atac, min.cutoff = \"q0\") pbmc.atac <- RunSVD(pbmc.atac) pbmc.atac <- RunUMAP(pbmc.atac, reduction = \"lsi\", dims = 2:30, reduction.name = \"umap.atac\", reduction.key = \"atacUMAP_\") ``` Now we plot the results from both modalities. Cells have been previously annotated based on transcriptomic state. We will predict annotations for the scATAC-seq cells. sourceCode R p1 <- DimPlot(pbmc.rna, group.by = \"seurat_annotations\", label = TRUE) + NoLegend() + ggtitle(\"RNA\") p2 <- DimPlot(pbmc.atac, group.by = \"orig.ident\", label = FALSE) + NoLegend() + ggtitle(\"ATAC\") p1 + p2 sourceCode R plot <- (p1 + p2) & xlab(\"UMAP 1\") & ylab(\"UMAP 2\") & theme(axis.title = element_text(size = 18)) ggsave(filename = \"../output/images/atacseq_integration_vignette.jpg\", height = 7, width = 12, plot = plot, quality = 50) Identifying anchors between scRNA-seq and scATAC-seq datasets anchor In order to identify ‘anchors’ between scRNA-seq and scATAC-seq experiments, we first generate a rough estimate of the transcriptional activity of each gene by quantifying ATAC-seq counts in the 2 kb-upstream region and gene body, using the GeneActivity() function in the Signac package. The ensuing gene activity scores from the scATAC-seq data are then used as input for canonical correlation analysis, along with the gene expression quantifications from scRNA-seq. We perform this quantification for all genes identified as being highly variable from the scRNA-seq dataset. ```sourceCode R quantify gene activity gene.activities <- GeneActivity(pbmc.atac, features = VariableFeatures(pbmc.rna)) ``` ```sourceCode R add gene activities as a new assay pbmc.atac[[\"ACTIVITY\"]] <- CreateAssayObject(counts = gene.activities) normalize gene activities DefaultAssay(pbmc.atac) <- \"ACTIVITY\" pbmc.atac <- NormalizeData(pbmc.atac) pbmc.atac <- ScaleData(pbmc.atac, features = rownames(pbmc.atac)) ``` ```sourceCode R Identify anchors transfer.anchors <- FindTransferAnchors(reference = pbmc.rna, query = pbmc.atac, features = VariableFeatures(object = pbmc.rna), reference.assay = \"RNA\", query.assay = \"ACTIVITY\", reduction = \"cca\") ``` Annotate scATAC-seq cells via label transfer anchor After identifying anchors, we can transfer annotations from the scRNA-seq dataset onto the scATAC-seq cells. The annotations are stored in the seurat_annotations field, and are provided as input to the refdata parameter. The output will contain a matrix with predictions and confidence scores for each ATAC-seq cell. ```sourceCode R celltype.predictions <- TransferData(anchorset = transfer.anchors, refdata = pbmc.rna$seurat_annotations, weight.reduction = pbmc.atac[[\"lsi\"]], dims = 2:30) pbmc.atac <- AddMetaData(pbmc.atac, metadata = celltype.predictions) ``` Why do you choose different (non-default) values for reduction and weight.reduction? In FindTransferAnchors() , we typically project the PCA structure from the reference onto the query when transferring between scRNA-seq datasets. However, when transferring across modalities we find that CCA better captures the shared feature correlation structure and therefore set reduction = 'cca' here. Additionally, by default in TransferData() we use the same projected PCA structure to compute the weights of the local neighborhood of anchors that influence each cell’s prediction. In the case of scRNA-seq to scATAC-seq transfer, we use the low dimensional space learned by computing an LSI on the ATAC-seq data to compute these weights as this better captures the internal structure of the ATAC-seq data. After performing transfer, the ATAC-seq cells have predicted annotations (transferred from the scRNA-seq dataset) stored in the predicted.id field. Since these cells were measured with the multiome kit, we also have a ground-truth annotation that can be used for evaluation. You can see that the predicted and actual annotations are extremely similar. sourceCode R pbmc.atac$annotation_correct <- pbmc.atac$predicted.id == pbmc.atac$seurat_annotations p1 <- DimPlot(pbmc.atac, group.by = \"predicted.id\", label = TRUE) + NoLegend() + ggtitle(\"Predicted annotation\") p2 <- DimPlot(pbmc.atac, group.by = \"seurat_annotations\", label = TRUE) + NoLegend() + ggtitle(\"Ground-truth annotation\") p1 | p2 In this example, the annotation for an scATAC-seq profile is correctly predicted via scRNA-seq integration ~90% of the time. In addition, the prediction.score.max field quantifies the uncertainty associated with our predicted annotations. We can see that cells that are correctly annotated are typically associated with high prediction scores (>90%), while cells that are incorrectly annotated are associated with sharply lower prediction scores (<50%). Incorrect assignments also tend to reflect closely related cell types (i.e. Intermediate vs. Naive B cells). ```sourceCode R predictions <- table(pbmc.atac$seurat_annotations, pbmc.atac$predicted.id) predictions <- predictions/rowSums(predictions) # normalize for number of cells in each cell type predictions <- as.data.frame(predictions) p1 <- ggplot(predictions, aes(Var1, Var2, fill = Freq)) + geom_tile() + scale_fill_gradient(name = \"Fraction of cells\", low = \"#ffffc8\", high = \"#7d0025\") + xlab(\"Cell type annotation (RNA)\") + ylab(\"Predicted cell type label (ATAC)\") + theme_cowplot() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) correct <- length(which(pbmc.atac$seurat_annotations == pbmc.atac$predicted.id)) incorrect <- length(which(pbmc.atac$seurat_annotations != pbmc.atac$predicted.id)) data <- FetchData(pbmc.atac, vars = c(\"prediction.score.max\", \"annotation_correct\")) p2 <- ggplot(data, aes(prediction.score.max, fill = annotation_correct, colour = annotation_correct)) + geom_density(alpha = 0.5) + theme_cowplot() + scale_fill_discrete(name = \"Annotation Correct\", labels = c(paste0(\"FALSE (n = \", incorrect, \")\"), paste0(\"TRUE (n = \", correct, \")\"))) + scale_color_discrete(name = \"Annotation Correct\", labels = c(paste0(\"FALSE (n = \", incorrect, \")\"), paste0(\"TRUE (n = \", correct, \")\"))) + xlab(\"Prediction Score\") p1 + p2 ``` Co-embedding scRNA-seq and scATAC-seq datasets anchor In addition to transferring labels across modalities, it is also possible to visualize scRNA-seq and scATAC-seq cells on the same plot. We emphasize that this step is primarily for visualization, and is an optional step. Typically, when we perform integrative analysis between scRNA-seq and scATAC-seq datasets, we focus primarily on label transfer as described above. We demonstrate our workflows for co-embedding below, and again highlight that this is for demonstration purposes, especially as in this particular case both the scRNA-seq profiles and scATAC-seq profiles were actually measured in the same cells. In order to perform co-embedding, we first ‘impute’ RNA expression into the scATAC-seq cells based on the previously computed anchors, and then merge the datasets. ```sourceCode R note that we restrict the imputation to variable genes from scRNA-seq, but could impute the full transcriptome if we wanted to genes.use <- VariableFeatures(pbmc.rna) refdata <- GetAssayData(pbmc.rna, assay = \"RNA\", slot = \"data\")[genes.use, ] refdata (input) contains a scRNA-seq expression matrix for the scRNA-seq cells. imputation (output) will contain an imputed scRNA-seq matrix for each of the ATAC cells imputation <- TransferData(anchorset = transfer.anchors, refdata = refdata, weight.reduction = pbmc.atac[[\"lsi\"]], dims = 2:30) pbmc.atac[[\"RNA\"]] <- imputation coembed <- merge(x = pbmc.rna, y = pbmc.atac) Finally, we run PCA and UMAP on this combined object, to visualize the co-embedding of both datasets coembed <- ScaleData(coembed, features = genes.use, do.scale = FALSE) coembed <- RunPCA(coembed, features = genes.use, verbose = FALSE) coembed <- RunUMAP(coembed, dims = 1:30) DimPlot(coembed, group.by = c(\"orig.ident\", \"seurat_annotations\")) ``` Session Info sourceCode R sessionInfo() ``` R version 4.2.2 Patched (2022-11-10 r83330) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.6 LTS Matrix products: default BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats4 stats graphics grDevices utils datasets methods [8] base other attached packages: [1] cowplot_1.1.1 ggplot2_3.4.4 [3] EnsDb.Hsapiens.v86_2.99.0 ensembldb_2.22.0 [5] AnnotationFilter_1.22.0 GenomicFeatures_1.50.4 [7] AnnotationDbi_1.60.2 Biobase_2.58.0 [9] GenomicRanges_1.50.2 GenomeInfoDb_1.34.9 [11] IRanges_2.32.0 S4Vectors_0.36.2 [13] BiocGenerics_0.44.0 Signac_1.12.9000 [15] Seurat_5.0.1 SeuratObject_5.0.1 [17] sp_2.1-1 thp1.eccite.SeuratData_3.1.5 [19] stxBrain.SeuratData_0.1.1 ssHippo.SeuratData_3.1.4 [21] pbmcsca.SeuratData_3.0.0 pbmcref.SeuratData_1.0.0 [23] pbmcMultiome.SeuratData_0.1.4 pbmc3k.SeuratData_3.1.4 [25] panc8.SeuratData_3.0.2 ifnb.SeuratData_3.0.0 [27] hcabm40k.SeuratData_3.0.0 cbmc.SeuratData_3.1.4 [29] bmcite.SeuratData_0.3.0 SeuratData_0.2.2.9001 loaded via a namespace (and not attached): [1] rappdirs_0.3.3 rtracklayer_1.58.0 [3] scattermore_1.2 ragg_1.2.5 [5] tidyr_1.3.0 bit64_4.0.5 [7] knitr_1.45 irlba_2.3.5.1 [9] DelayedArray_0.24.0 data.table_1.14.8 [11] rpart_4.1.19 KEGGREST_1.38.0 [13] RCurl_1.98-1.12 generics_0.1.3 [15] RSQLite_2.3.1 RANN_2.6.1 [17] future_1.33.0 bit_4.0.5 [19] spatstat.data_3.0-3 xml2_1.3.5 [21] httpuv_1.6.12 SummarizedExperiment_1.28.0 [23] xfun_0.40 hms_1.1.3 [25] jquerylib_0.1.4 evaluate_0.22 [27] promises_1.2.1 fansi_1.0.5 [29] restfulr_0.0.15 progress_1.2.2 [31] dbplyr_2.3.4 igraph_1.5.1 [33] DBI_1.1.3 htmlwidgets_1.6.2 [35] spatstat.geom_3.2-7 purrr_1.0.2 [37] ellipsis_0.3.2 RSpectra_0.16-1 [39] dplyr_1.1.3 backports_1.4.1 [41] biomaRt_2.54.1 deldir_1.0-9 [43] MatrixGenerics_1.10.0 vctrs_0.6.4 [45] ROCR_1.0-11 abind_1.4-5 [47] cachem_1.0.8 withr_2.5.2 [49] BSgenome_1.66.3 progressr_0.14.0 [51] checkmate_2.2.0 sctransform_0.4.1 [53] GenomicAlignments_1.34.1 prettyunits_1.1.1 [55] goftest_1.2-3 cluster_2.1.4 [57] dotCall64_1.1-0 lazyeval_0.2.2 [59] crayon_1.5.2 spatstat.explore_3.2-5 [61] labeling_0.4.3 pkgconfig_2.0.3 [63] nlme_3.1-162 ProtGenerics_1.30.0 [65] nnet_7.3-18 rlang_1.1.1 [67] globals_0.16.2 lifecycle_1.0.3 [69] miniUI_0.1.1.1 filelock_1.0.2 [71] fastDummies_1.7.3 BiocFileCache_2.6.1 [73] dichromat_2.0-0.1 rprojroot_2.0.3 [75] polyclip_1.10-6 RcppHNSW_0.5.0 [77] matrixStats_1.0.0 lmtest_0.9-40 [79] Matrix_1.6-1.1 zoo_1.8-12 [81] base64enc_0.1-3 ggridges_0.5.4 [83] png_0.1-8 viridisLite_0.4.2 [85] rjson_0.2.21 bitops_1.0-7 [87] KernSmooth_2.23-22 spam_2.10-0 [89] Biostrings_2.66.0 blob_1.2.4 [91] stringr_1.5.0 parallelly_1.36.0 [93] spatstat.random_3.2-1 scales_1.2.1 [95] memoise_2.0.1 magrittr_2.0.3 [97] plyr_1.8.9 ica_1.0-3 [99] zlibbioc_1.44.0 compiler_4.2.2 [101] BiocIO_1.8.0 RColorBrewer_1.1-3 [103] fitdistrplus_1.1-11 Rsamtools_2.14.0 [105] cli_3.6.1 XVector_0.38.0 [107] listenv_0.9.0 patchwork_1.1.3 [109] pbapply_1.7-2 htmlTable_2.4.1 [111] formatR_1.14 Formula_1.2-5 [113] MASS_7.3-58.2 tidyselect_1.2.0 [115] stringi_1.7.12 textshaping_0.3.6 [117] highr_0.10 yaml_2.3.7 [119] ggrepel_0.9.4 grid_4.2.2 [121] VariantAnnotation_1.44.1 sass_0.4.7 [123] fastmatch_1.1-4 tools_4.2.2 [125] future.apply_1.11.0 parallel_4.2.2 [127] rstudioapi_0.14 foreign_0.8-84 [129] gridExtra_2.3 farver_2.1.1 [131] Rtsne_0.16 digest_0.6.33 [133] shiny_1.7.5.1 Rcpp_1.0.11 [135] later_1.3.1 RcppAnnoy_0.0.21 [137] httr_1.4.7 biovizBase_1.46.0 [139] colorspace_2.1-0 XML_3.99-0.14 [141] fs_1.6.3 tensor_1.5 [143] reticulate_1.34.0 splines_4.2.2 [145] uwot_0.1.16 RcppRoll_0.3.0 [147] spatstat.utils_3.0-4 pkgdown_2.0.7 [149] plotly_4.10.3 systemfonts_1.0.4 [151] xtable_1.8-4 jsonlite_1.8.7 [153] R6_2.5.1 Hmisc_5.1-1 [155] pillar_1.9.0 htmltools_0.5.6.1 [157] mime_0.12 glue_1.6.2 [159] fastmap_1.1.1 BiocParallel_1.32.6 [161] codetools_0.2-19 utf8_1.2.4 [163] lattice_0.21-9 bslib_0.5.1 [165] spatstat.sparse_3.0-3 tibble_3.2.1 [167] curl_5.1.0 leiden_0.4.3 [169] survival_3.5-7 rmarkdown_2.25 [171] desc_1.4.2 munsell_0.5.0 [173] GenomeInfoDbData_1.2.9 reshape2_1.4.4 [175] gtable_0.3.4 ```",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/seurat5_atacseq_integration_vignette",
      "title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat • Seurat",
      "ogTitle": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "language": "en",
      "og:title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "scrapeId": "97e49807-f1ae-492c-baed-027f855b3f98",
      "viewport": "width=device-width, initial-scale=1.0",
      "sourceURL": "https://satijalab.org/seurat/articles/seurat5_atacseq_integration_vignette",
      "statusCode": 200,
      "ogDescription": "Seurat",
      "og:description": "Seurat"
    }
  },
  {
    "processed_text": "Getting Started with Seurat Source: vignettes/get_started_v5_new.Rmd get_started_v5_new.Rmd We provide a series of vignettes, tutorials, and analysis walkthroughs to help users get started with Seurat. You can also check out our Reference page which contains a full list of functions available to users. Our previous Get Started page for Seurat v4 is archived here . Introductory Vignettes anchor For new users of Seurat, we suggest starting with a guided walk through of a dataset of 2,700 Peripheral Blood Mononuclear Cells (PBMCs) made publicly available by 10X Genomics. This tutorial implements the major components of a standard unsupervised clustering workflow including QC and data filtration, calculation of high-variance genes, dimensional reduction, graph-based clustering, and the identification of cluster markers. We provide additional vignettes introducing visualization techniques in Seurat, the sctransform normalization workflow, and storage/interaction with multimodal datasets. We also provide an ‘essential commands cheatsheet’ as a quick reference. | | | | | --- | --- | --- | | Guided tutorial — 2,700 PBMCs | Multimodal analysis | Visualization | | | | | | A basic overview of Seurat that includes an introduction to common analytical workflows. | An introduction to working with multi-modal datasets in Seurat. | An overview of the visualization capabilities within Seurat. | | GO | GO | GO | | | | | --- | --- | | SCTransform | Essential Commands Cheat Sheet | | | | | Examples of how to perform normalization, feature selection, integration, and differential expression with an updated version of sctransform. | Reference list of commonly used commands to store, access, explore, and analyze datasets. | | GO | GO | scRNA Data Integration anchor We have developed computational methods for integrated analysis of single-cell datasets generated across different conditions, technologies, or species. As an example, we provide a guided walk through for integrating and comparing PBMC datasets generated under different stimulation conditions. We provide additional vignettes demonstrating how to leverage an annotated scRNA-seq reference to map and label cells from a query, and to efficiently integrate large datasets. | | | | | --- | --- | --- | | Introduction to scRNA-seq integration | scRNA-seq Integration | Mapping and annotating query datasets | | | | | | An introduction to integrating scRNA-seq datasets in order to identify and compare shared cell types across experiments. | Integrate scRNA-seq datasets using a variety of computational methods. | Learn how to map a query scRNA-seq dataset onto a reference in order to automate the annotation and visualization of query cells. | | GO | GO | GO | Multi-assay data anchor Seurat also offers support for a suite of statistical methods for analyzing multimodal single-cell data. These include methods to integrate modalities that are simultaneously measured in the same cells, modalities that are measured in different cells, and techniques to analyze pooled CRISPR screens. | | | | | --- | --- | --- | | Cross-modality Bridge Integration | Weighted Nearest Neighbor Analysis | Integrating scRNA-seq and scATAC-seq data | | | | | | Map scATAC-seq onto an scRNA-seq reference using a multi-omic bridge dataset in Seurat v5. | Analyze multimodal single-cell data with weighted nearest neighbor analysis in Seurat v4. | Annotate, visualize, and interpret an scATAC-seq experiment using scRNA-seq data from the same biological system in Seurat v3. | | GO | GO | GO | | | | | --- | --- | | Reference Mapping for Multimodal Data | Mixscape | | | | | Analyze query data in the context of multimodal reference atlases. | Explore new methods to analyze pooled single-celled perturbation screens. | | GO | GO | Flexible analysis of massively scalable datasets anchor In Seurat v5, we introduce new infrastructure and methods to analyze, interpret, and explore datasets that extend to millions of cells. We introduce support for ‘sketch-based’ techniques, where a subset of representative cells are stored in memory to enable rapid and iterative exploration, while the remaining cells are stored on-disk. Users can flexibly switch between both data representations, and we leverage the BPCells package from Ben Parks in the Greenleaf lab to enable high-performance analysis of disk-backed data. The vignettes below demonstrate three scalable analyses in Seurat v5: Unsupervised clustering analysis of a large dataset (1.3M neurons), Unsupervised integration and comparison of 1M PBMC from healthy and diabetic patients, and Supervised mapping of 1.5M immune cells from healthy and COVID donors. In all cases, the vignettes perform these analyses without ever loading the full datasets into memory. | | | | | --- | --- | --- | | Unsupervised clustering of 1.3M neurons | Integrating/comparing healthy and diabetic samples | Supervised mapping of 1.5M immune cells | | | | | | Analyze a 1.3 million cell mouse brain dataset using on-disk capabilities powered by BPCells. | Perform sketch integration on a large dataset from Parse Biosciences. | Map PBMC datasets from COVID-19 patients to a healthy PBMC reference. | | GO | GO | GO | | | | --- | | BPCells Interaction | | | | Load and save large on-disk matrices using BPCells. | | GO | Spatial analysis anchor These vignettes will help introduce users to the analysis of spatial datasets in Seurat v5, including technologies that leverage sequencing-based readouts, as well as technologies that leverage in-situ imaging-based readouts. The vignettes introduce data from multiple platforms including 10x Visium, SLIDE-seq, Vizgen MERSCOPE, 10x Xenium, Nanostring CosMx, and Akoya CODEX. | | | | | --- | --- | --- | | Analysis of spatial datasets (Imaging-based) | Analysis of spatial datasets (Sequencing-based) | Analysis of Visium HD spatial datasets | | | | | | Learn to explore spatially-resolved data from multiplexed imaging technologies, including MERSCOPE, Xenium, CosMx SMI, and CODEX. | Learn to explore spatially-resolved transcriptomic data with examples from 10x Visium and Slide-seq v2. | Learn to explore spatially-resolved transcriptomic data in high-definition from 10x Visium HD. | | GO | GO | GO | Other anchor Here we provide a series of short vignettes to demonstrate a number of features that are commonly used in Seurat. We’ve focused the vignettes around questions that we frequently receive from users. | | | | | --- | --- | --- | | Cell Cycle Regression | Differential Expression Testing | Demultiplex Cell Hashing data | | | | | | Mitigate the effects of cell cycle heterogeneity by computing cell cycle phase scores based on marker genes. | Perform differential expression (DE) testing in Seurat using a number of frameworks. | Learn how to work with data produced with Cell Hashing. | | GO | GO | GO | SeuratWrappers anchor In order to facilitate the use of community tools with Seurat, we provide the Seurat Wrappers package, which contains code to run other analysis tools on Seurat objects. For the initial release, we provide wrappers for a few packages in the table below but would encourage other package developers interested in interfacing with Seurat to check out our contributor guide here . | Package | Vignette | Reference | Source | | --- | --- | --- | --- | | alevin | Import alevin counts into Seurat | Srivastava et. al., Genome Biology 2019 | https://github.com/k3yavi/alevin-Rtools | | ALRA | Zero-preserving imputation with ALRA | Linderman et al, bioRxiv 2018 | https://github.com/KlugerLab/ALRA | | CoGAPS | Running CoGAPS on Seurat Objects | Stein-O’Brien et al, Cell Systems 2019 | https://www.bioconductor.org/packages/release/bioc/html/CoGAPS.html | | Conos | Integration of datasets using Conos | Barkas et al, Nature Methods 2019 | https://github.com/hms-dbmi/conos | | fastMNN | Running fastMNN on Seurat Objects | Haghverdi et al, Nature Biotechnology 2018 | https://bioconductor.org/packages/release/bioc/html/scran.html | | glmpca | Running GLM-PCA on a Seurat Object | Townes et al, Genome Biology 2019 | https://github.com/willtownes/glmpca | | Harmony | Integration of datasets using Harmony | Korsunsky et al, Nature Methods 2019 | https://github.com/immunogenomics/harmony | | LIGER | Integrating Seurat objects using LIGER | Welch et al, Cell 2019 | https://github.com/MacoskoLab/liger | | Monocle3 | Calculating Trajectories with Monocle 3 and Seurat | Cao et al, Nature 2019 | https://cole-trapnell-lab.github.io/monocle3 | | Nebulosa | Visualization of gene expression with Nebulosa | Jose Alquicira-Hernandez and Joseph E. Powell, Under Review | https://github.com/powellgenomicslab/Nebulosa | | schex | Using schex with Seurat | Freytag, R package 2019 | https://github.com/SaskiaFreytag/schex | | scVelo | Estimating RNA Velocity using Seurat and scVelo | Bergen et al, bioRxiv 2019 | https://scvelo.readthedocs.io/ | | Velocity | Estimating RNA Velocity using Seurat | La Manno et al, Nature 2018 | https://velocyto.org | | CIPR | Using CIPR with human PBMC data | Ekiz et. al., BMC Bioinformatics 2020 | https://github.com/atakanekiz/CIPR-Package | | miQC | Running miQC on Seurat objects | Hippen et. al., bioRxiv 2021 | https://github.com/greenelab/miQC | | tricycle | Running estimate_cycle_position from tricycle on Seurat Objects | Zheng et. al., bioRxiv 2021 | https://www.bioconductor.org/packages/release/bioc/html/tricycle.html |",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/get_started_v5_new",
      "title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat • Seurat",
      "ogTitle": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "language": "en",
      "og:title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "scrapeId": "989cbe87-9dd0-4080-9d67-d031c704d3ab",
      "viewport": "width=device-width, initial-scale=1.0",
      "sourceURL": "https://satijalab.org/seurat/articles/get_started_v5_new",
      "statusCode": 200,
      "ogDescription": "Seurat",
      "og:description": "Seurat"
    }
  },
  {
    "processed_text": "",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/10.1038/s41586-018-0414-6",
      "error": "Not Found",
      "scrapeId": "07785f29-c8cd-414d-b1c4-992021827056",
      "sourceURL": "https://satijalab.org/seurat/articles/10.1038/s41586-018-0414-6",
      "statusCode": 404
    }
  },
  {
    "processed_text": "",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/articles/multimodal_reference_mapping.html",
      "error": "Not Found",
      "scrapeId": "9904c6cc-2a9b-4f69-9b14-126b7d05e414",
      "sourceURL": "https://satijalab.org/seurat/articles/articles/multimodal_reference_mapping.html",
      "statusCode": 404
    }
  },
  {
    "processed_text": "Seurat v5 Command Cheat Sheet Compiled: October 31, 2023 Source: vignettes/seurat5_essential_commands.Rmd seurat5_essential_commands.Rmd Here, we describe important commands and functions to store, access, and process data using Seurat v5. To demonstrate commamnds, we use a dataset of 3,000 PBMC (stored in-memory), and a dataset of 1.3M E18 mouse neurons (stored on-disk), which we constructed as described in the BPCells vignette . sourceCode R library(Seurat) library(SeuratData) library(BPCells) library(dplyr) options(Seurat.object.assay.version = \"v5\") Load datasets anchor ```sourceCode R pbmc3k <- LoadData(\"pbmc3k\") mousebrain1m <- readRDS(\"/brahms/hartmana/vignette_data/1p3_million_mouse_brain.rds\") RNA assay is of the Assay5 class class(pbmc3k[[\"RNA\"]]) class(mousebrain1m[[\"RNA\"]]) ``` Access and store expression data anchor The $ and double-bracket [[]] symbols can be used as efficient accessor functions for Seurat5 assays. ```sourceCode R access the counts matrix from the RNA assay counts_matrix <- pbmc3k[[\"RNA\"]]$counts Add a layer Equivalent to running pbmc3k <-NormalizeData(pbmc3k) pbmc3k[[\"RNA\"]]$data <- NormalizeData(pbmc3k[[\"RNA\"]]$counts) Delete a layer pbmc3k[[\"RNA\"]]$data <- NULL pbmc3k counts matrix is stored in-memory class(pbmc3k[[\"RNA\"]]$counts) 1.3M cell dataset counts matrix is stored on-disk class(mousebrain1m[[\"RNA\"]]$counts) ``` Despite the drastic difference in dataset size, the 1.3M cell dataset occupies a small memory footprint thanks to on-disk storage. ```sourceCode R paste(\"PBMC 3k contains\", length(colnames(pbmc3k)), \"cells\") paste(\"Mouse brain 1.3M contains\", length(colnames(mousebrain1m)), \"cells\") Despite the mouse brain dataset containing 1.3 million cells, the assay is under 350Mbs in size due to on-disk storage paste(\"PBMC 3k assay size:\", format(object.size(pbmc3k[[\"RNA\"]]), units = \"Mb\")) paste(\"Mouse brain 1.3M assay size:\", format(object.size(mousebrain1m[[\"RNA\"]]), units = \"Mb\")) ``` Access cell names and metadata anchor Get cell names. Since Seurat v5 object doesn’t require all assays have the same cells, Cells() is designed to get cell names of the default assay and colnames() is deigned to get cell names of the entire object sourceCode R pbmc3k[[\"RNAsub\"]] <- subset(pbmc3k[[\"RNA\"]], cells = colnames(pbmc3k)[1:100]) DefaultAssay(pbmc3k) <- \"RNAsub\" length(Cells(pbmc3k)) length(colnames(pbmc3k)) Access object metadata ```sourceCode R get all object metadata pbmc_metadata <- pbmc3k[[]] get list of metadata columns colnames(pbmc_metadata) get annotations stored in metadata annotations <- pbmc3k$seurat_annotations ``` Create Seurat or Assay objects anchor By setting a global option ( Seurat.object.assay.version ), you can default to creating either Seurat v3 assays, or Seurat v5 assays. The use of v5 assays is set by default upon package loading, which ensures backwards compatibiltiy with existing workflows. ```sourceCode R create v3 assays options(Seurat.object.assay.version = \"v3\") pbmc.counts <- Read10X(data.dir = \"/brahms/hartmana/vignette_data/pbmc3k/filtered_gene_bc_matrices/hg19/\") pbmc <- CreateSeuratObject(counts = pbmc.counts) class(pbmc[[\"RNA\"]]) create v5 assays options(Seurat.object.assay.version = \"v5\") pbmc.counts <- Read10X(data.dir = \"/brahms/hartmana/vignette_data/pbmc3k/filtered_gene_bc_matrices/hg19/\") pbmc <- CreateSeuratObject(counts = pbmc.counts) class(pbmc[[\"RNA\"]]) ``` CreateAssayObject() and CreateAssay5Object() can be used to create v3 and v5 assay regardless of the setting in Seurat.object.assay.version ```sourceCode R create a v3 assay assay.v3 <- CreateAssayObject(counts = pbmc.counts) create a v5 assay assay.v5 <- CreateAssay5Object(counts = pbmc.counts) class(assay.v3) class(assay.v5) ``` Assay5 objects are more flexible, and can be used to store only a data layer, with no counts data. This can be used to create Seurat objects that require less space ```sourceCode R create an assay using only normalized data assay.v5 <- CreateAssay5Object(data = log1p(pbmc.counts)) create a Seurat object based on this assay pbmc3k_slim <- CreateSeuratObject(assay.v5) pbmc3k_slim ``` We can also convert (cast) between Assay and Assay5 objects with as() . ```sourceCode R convert a v5 assay to a v3 assay pbmc3k[[\"RNA3\"]] <- as(object = pbmc3k[[\"RNA\"]], Class = \"Assay\") convert a v3 assay to a v5 assay pbmc3k[[\"RNA5\"]] <- as(object = pbmc3k[[\"RNA3\"]], Class = \"Assay5\") ``` Working with layers anchor Seurat v5 assays store data in layers. These layers can store raw, un-normalized counts ( layer='counts' ), normalized data ( layer='data' ), or z-scored/variance-stabilized data ( layer='scale.data' ). ```sourceCode R by default, creates an RNA assay with a counts layer obj <- CreateSeuratObject(counts = pbmc.counts) obj creates a normalized data layer obj <- NormalizeData(obj, verbose = FALSE) obj extract only the layer names from an assay Layers(obj[[\"RNA\"]]) ``` Prior to performing integration analysis in Seurat v5, we can split the layers into groups. The IntegrateLayers function, described in our vignette , will then align shared cell types across these layers. After performing integration, you can rejoin the layers. ```sourceCode R create random batches pbmc3k$batch <- sample(c(\"batchA\", \"batchB\", \"batchC\"), ncol(pbmc3k), replace = TRUE) split layers pbmc3k[[\"RNA\"]] <- split(pbmc3k[[\"RNA\"]], f = pbmc3k$batch) Layers(pbmc3k[[\"RNA\"]]) rejoin layers pbmc3k[[\"RNA\"]] <- JoinLayers(pbmc3k[[\"RNA\"]]) Layers(pbmc3k[[\"RNA\"]]) ``` If you have multiple counts matrices, you can also create a Seurat object that is initialized with multiple layers. ```sourceCode R batchA_counts <- pbmc.counts[, 1:200] batchB_counts <- pbmc.counts[, 201:400] batchC_counts <- pbmc.counts[, 401:600] count_list <- list(batchA_counts, batchB_counts, batchC_counts) names(count_list) <- c(\"batchA\", \"batchB\", \"batchC\") create a Seurat object initialized with multiple layers obj <- CreateSeuratObject(counts = count_list) Layers(obj[[\"RNA\"]]) ``` Accessing additional data anchor ```sourceCode R pbmc3k <- FindVariableFeatures(pbmc3k, verbose = FALSE) pbmc3k <- ScaleData(pbmc3k, verbose = FALSE) pbmc3k <- RunPCA(pbmc3k, verbose = FALSE) return variable features returns information from both assay, cell embeddings and meta.data as a data.frame fetch_df <- FetchData(object = pbmc3k, layer = \"counts\", vars = c(\"rna_MS4A1\", \"PC_1\", \"nCount_RNA\")) head(fetch_df) get cell embeddings head(Embeddings(object = pbmc3k[[\"pca\"]])[, 1:5]) get feature loadings head(Loadings(object = pbmc3k[[\"pca\"]])[, 1:5]) ``` Session Info sourceCode R sessionInfo()",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/seurat5_essential_commands",
      "title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat • Seurat",
      "ogTitle": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "language": "en",
      "og:title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "scrapeId": "9f7ac00b-ea82-48a0-9edd-1f9a01e091bb",
      "viewport": "width=device-width, initial-scale=1.0",
      "sourceURL": "https://satijalab.org/seurat/articles/seurat5_essential_commands",
      "statusCode": 200,
      "ogDescription": "Seurat",
      "og:description": "Seurat"
    }
  },
  {
    "processed_text": "",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/integration_large_datasets.html",
      "error": "Not Found",
      "scrapeId": "a4aed10d-b256-427b-8e9c-ad6b02981a9b",
      "sourceURL": "https://satijalab.org/seurat/articles/integration_large_datasets.html",
      "statusCode": 404
    }
  },
  {
    "processed_text": "",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/seurat5_multimodal_vignette.html",
      "error": "Not Found",
      "scrapeId": "a9f782aa-27db-4347-bddb-7c43682c030a",
      "sourceURL": "https://satijalab.org/seurat/articles/seurat5_multimodal_vignette.html",
      "statusCode": 404
    }
  },
  {
    "processed_text": "",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/seurat5_integration_rpca.html",
      "error": "Not Found",
      "scrapeId": "aabc8b85-ee11-43ec-816f-3a3a76754ddd",
      "sourceURL": "https://satijalab.org/seurat/articles/seurat5_integration_rpca.html",
      "statusCode": 404
    }
  },
  {
    "processed_text": "Demultiplexing with hashtag oligos (HTOs) Compiled: 2023-11-14 Source: vignettes/hashing_vignette.Rmd hashing_vignette.Rmd Developed in collaboration with the Technology Innovation Group at NYGC, Cell Hashing uses oligo-tagged antibodies against ubiquitously expressed surface proteins to place a “sample barcode” on each single cell, enabling different samples to be multiplexed together and run in a single experiment. For more information, please refer to this paper . This vignette will give a brief demonstration on how to work with data produced with Cell Hashing in Seurat. Applied to two datasets, we can successfully demultiplex cells to their the original sample-of-origin, and identify cross-sample doublets. The demultiplexing function HTODemux() implements the following procedure: We perform a k-medoid clustering on the normalized HTO values, which initially separates cells into K(# of samples)+1 clusters. We calculate a ‘negative’ distribution for HTO. For each HTO, we use the cluster with the lowest average value as the negative group. For each HTO, we fit a negative binomial distribution to the negative cluster. We use the 0.99 quantile of this distribution as a threshold. Based on these thresholds, each cell is classified as positive or negative for each HTO. Cells that are positive for more than one HTOs are annotated as doublets. 8-HTO dataset from human PBMCs anchor Dataset description: Data represent peripheral blood mononuclear cells (PBMCs) from eight different donors. Cells from each donor are uniquely labeled, using CD45 as a hashing antibody. Samples were subsequently pooled, and run on a single lane of the the 10X Chromium v2 system. You can download the count matrices for RNA and HTO here , or the FASTQ files from GEO Basic setup anchor Load packages sourceCode R library(Seurat) Read in data ```sourceCode R Load in the UMI matrix pbmc.umis <- readRDS(\"/brahms/shared/vignette-data/pbmc_umi_mtx.rds\") For generating a hashtag count matrix from FASTQ files, please refer to https://github.com/Hoohm/CITE-seq-Count. Load in the HTO count matrix pbmc.htos <- readRDS(\"/brahms/shared/vignette-data/pbmc_hto_mtx.rds\") Select cell barcodes detected by both RNA and HTO In the example datasets we have already filtered the cells for you, but perform this step for clarity. joint.bcs <- intersect(colnames(pbmc.umis), colnames(pbmc.htos)) Subset RNA and HTO counts by joint cell barcodes pbmc.umis <- pbmc.umis[, joint.bcs] pbmc.htos <- as.matrix(pbmc.htos[, joint.bcs]) Confirm that the HTO have the correct names rownames(pbmc.htos) ``` ``` [1] \"HTO_A\" \"HTO_B\" \"HTO_C\" \"HTO_D\" \"HTO_E\" \"HTO_F\" \"HTO_G\" \"HTO_H\" ``` Setup Seurat object and add in the HTO data ```sourceCode R Setup Seurat object pbmc.hashtag <- CreateSeuratObject(counts = Matrix::Matrix(as.matrix(pbmc.umis), sparse = T)) Normalize RNA data with log normalization pbmc.hashtag <- NormalizeData(pbmc.hashtag) Find and scale variable features pbmc.hashtag <- FindVariableFeatures(pbmc.hashtag, selection.method = \"mean.var.plot\") pbmc.hashtag <- ScaleData(pbmc.hashtag, features = VariableFeatures(pbmc.hashtag)) ``` Adding HTO data as an independent assay anchor You can read more about working with multi-modal data here ```sourceCode R Add HTO data as a new assay independent from RNA pbmc.hashtag[[\"HTO\"]] <- CreateAssayObject(counts = pbmc.htos) Normalize HTO data, here we use centered log-ratio (CLR) transformation pbmc.hashtag <- NormalizeData(pbmc.hashtag, assay = \"HTO\", normalization.method = \"CLR\") ``` Demultiplex cells based on HTO enrichment anchor Here we use the Seurat function HTODemux() to assign single cells back to their sample origins. ```sourceCode R If you have a very large dataset we suggest using k_function = 'clara'. This is a k-medoid clustering function for large applications You can also play with additional parameters (see documentation for HTODemux()) to adjust the threshold for classification Here we are using the default settings pbmc.hashtag <- HTODemux(pbmc.hashtag, assay = \"HTO\", positive.quantile = 0.99) ``` Visualize demultiplexing results anchor Output from running HTODemux() is saved in the object metadata. We can visualize how many cells are classified as singlets, doublets and negative/ambiguous cells. ```sourceCode R Global classification results table(pbmc.hashtag$HTO_classification.global) ``` ``` Doublet Negative Singlet 2598 346 13972 ``` Visualize enrichment for selected HTOs with ridge plots ```sourceCode R Group cells based on the max HTO signal Idents(pbmc.hashtag) <- \"HTO_maxID\" RidgePlot(pbmc.hashtag, assay = \"HTO\", features = rownames(pbmc.hashtag[[\"HTO\"]])[1:2], ncol = 2) ``` Visualize pairs of HTO signals to confirm mutual exclusivity in singlets sourceCode R FeatureScatter(pbmc.hashtag, feature1 = \"hto_HTO-A\", feature2 = \"hto_HTO-B\") Compare number of UMIs for singlets, doublets and negative cells sourceCode R Idents(pbmc.hashtag) <- \"HTO_classification.global\" VlnPlot(pbmc.hashtag, features = \"nCount_RNA\", pt.size = 0.1, log = TRUE) Generate a two dimensional tSNE embedding for HTOs. Here we are grouping cells by singlets and doublets for simplicity. ```sourceCode R First, we will remove negative cells from the object pbmc.hashtag.subset <- subset(pbmc.hashtag, idents = \"Negative\", invert = TRUE) Calculate a tSNE embedding of the HTO data DefaultAssay(pbmc.hashtag.subset) <- \"HTO\" pbmc.hashtag.subset <- ScaleData(pbmc.hashtag.subset, features = rownames(pbmc.hashtag.subset), verbose = FALSE) pbmc.hashtag.subset <- RunPCA(pbmc.hashtag.subset, features = rownames(pbmc.hashtag.subset), approx = FALSE) pbmc.hashtag.subset <- RunTSNE(pbmc.hashtag.subset, dims = 1:8, perplexity = 100) DimPlot(pbmc.hashtag.subset) ``` ```sourceCode R You can also visualize the more detailed classification result by running Idents(object) <- 'HTO_classification' before plotting. Here, you can see that each of the small clouds on the tSNE plot corresponds to one of the 28 possible doublet combinations. ``` Create an HTO heatmap, based on Figure 1C in the Cell Hashing paper. ```sourceCode R To increase the efficiency of plotting, you can subsample cells using the num.cells argument HTOHeatmap(pbmc.hashtag, assay = \"HTO\", ncells = 5000) ``` Cluster and visualize cells using the usual scRNA-seq workflow, and examine for the potential presence of batch effects. ```sourceCode R Extract the singlets pbmc.singlet <- subset(pbmc.hashtag, idents = \"Singlet\") Select the top 1000 most variable features pbmc.singlet <- FindVariableFeatures(pbmc.singlet, selection.method = \"mean.var.plot\") Scaling RNA data, we only scale the variable features here for efficiency pbmc.singlet <- ScaleData(pbmc.singlet, features = VariableFeatures(pbmc.singlet)) Run PCA pbmc.singlet <- RunPCA(pbmc.singlet, features = VariableFeatures(pbmc.singlet)) ``` ```sourceCode R We select the top 10 PCs for clustering and tSNE based on PCElbowPlot pbmc.singlet <- FindNeighbors(pbmc.singlet, reduction = \"pca\", dims = 1:10) pbmc.singlet <- FindClusters(pbmc.singlet, resolution = 0.6, verbose = FALSE) pbmc.singlet <- RunTSNE(pbmc.singlet, reduction = \"pca\", dims = 1:10) Projecting singlet identities on TSNE visualization DimPlot(pbmc.singlet, group.by = \"HTO_classification\") ``` 12-HTO dataset from four human cell lines anchor Dataset description: Data represent single cells collected from four cell lines: HEK, K562, KG1 and THP1 Each cell line was further split into three samples (12 samples in total). Each sample was labeled with a hashing antibody mixture (CD29 and CD45), pooled, and run on a single lane of 10X. Based on this design, we should be able to detect doublets both across and within cell types You can download the count matrices for RNA and HTO here , and are available on GEO here Create Seurat object, add HTO data and perform normalization anchor ```sourceCode R Read in UMI count matrix for RNA hto12.umis <- readRDS(\"/brahms/shared/vignette-data/hto12_umi_mtx.rds\") Read in HTO count matrix hto12.htos <- readRDS(\"/brahms/shared/vignette-data/hto12_hto_mtx.rds\") Select cell barcodes detected in both RNA and HTO cells.use <- intersect(rownames(hto12.htos), colnames(hto12.umis)) Create Seurat object and add HTO data hto12 <- CreateSeuratObject(counts = Matrix::Matrix(as.matrix(hto12.umis[, cells.use]), sparse = T), min.features = 300) hto12[[\"HTO\"]] <- CreateAssayObject(counts = t(x = hto12.htos[colnames(hto12), 1:12])) Normalize data hto12 <- NormalizeData(hto12) hto12 <- NormalizeData(hto12, assay = \"HTO\", normalization.method = \"CLR\") ``` Demultiplex data anchor sourceCode R hto12 <- HTODemux(hto12, assay = \"HTO\", positive.quantile = 0.99) Visualize demultiplexing results anchor Distribution of selected HTOs grouped by classification, displayed by ridge plots sourceCode R RidgePlot(hto12, assay = \"HTO\", features = c(\"HEK-A\", \"K562-B\", \"KG1-A\", \"THP1-C\"), ncol = 2) Visualize HTO signals in a heatmap sourceCode R HTOHeatmap(hto12, assay = \"HTO\") Visualize RNA clustering anchor Below, we cluster the cells using our standard scRNA-seq workflow. As expected we see four major clusters, corresponding to the cell lines In addition, we see small clusters in between, representing mixed transcriptomes that are correctly annotated as doublets. We also see within-cell type doublets, that are (perhaps unsurprisingly) intermixed with singlets of the same cell type ```sourceCode R Remove the negative cells hto12 <- subset(hto12, idents = \"Negative\", invert = TRUE) Run PCA on most variable features hto12 <- FindVariableFeatures(hto12, selection.method = \"mean.var.plot\") hto12 <- ScaleData(hto12, features = VariableFeatures(hto12)) hto12 <- RunPCA(hto12) hto12 <- RunTSNE(hto12, dims = 1:5, perplexity = 100) DimPlot(hto12) + NoLegend() ``` Session Info sourceCode R sessionInfo() ``` R version 4.2.2 Patched (2022-11-10 r83330) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.6 LTS Matrix products: default BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats graphics grDevices utils datasets methods base other attached packages: [1] Seurat_5.0.0 SeuratObject_5.0.0 sp_2.1-1 loaded via a namespace (and not attached): [1] ggbeeswarm_0.7.1 Rtsne_0.16 colorspace_2.1-0 [4] deldir_1.0-9 ellipsis_0.3.2 ggridges_0.5.4 [7] rprojroot_2.0.4 RcppHNSW_0.5.0 fs_1.6.3 [10] spatstat.data_3.0-3 farver_2.1.1 leiden_0.4.3 [13] listenv_0.9.0 ggrepel_0.9.4 RSpectra_0.16-1 [16] fansi_1.0.5 codetools_0.2-19 splines_4.2.2 [19] cachem_1.0.8 knitr_1.45 polyclip_1.10-6 [22] spam_2.10-0 jsonlite_1.8.7 ica_1.0-3 [25] cluster_2.1.4 png_0.1-8 uwot_0.1.16 [28] spatstat.sparse_3.0-3 sctransform_0.4.1 shiny_1.7.5.1 [31] compiler_4.2.2 httr_1.4.7 Matrix_1.6-1.1 [34] fastmap_1.1.1 lazyeval_0.2.2 cli_3.6.1 [37] later_1.3.1 formatR_1.14 htmltools_0.5.6.1 [40] tools_4.2.2 igraph_1.5.1 dotCall64_1.1-0 [43] gtable_0.3.4 glue_1.6.2 reshape2_1.4.4 [46] RANN_2.6.1 dplyr_1.1.3 Rcpp_1.0.11 [49] scattermore_1.2 jquerylib_0.1.4 pkgdown_2.0.7 [52] vctrs_0.6.4 nlme_3.1-162 spatstat.explore_3.2-5 [55] progressr_0.14.0 lmtest_0.9-40 spatstat.random_3.2-1 [58] xfun_0.40 stringr_1.5.0 globals_0.16.2 [61] mime_0.12 miniUI_0.1.1.1 lifecycle_1.0.4 [64] irlba_2.3.5.1 goftest_1.2-3 future_1.33.0 [67] MASS_7.3-58.2 zoo_1.8-12 scales_1.2.1 [70] spatstat.utils_3.0-4 ragg_1.2.5 promises_1.2.1 [73] parallel_4.2.2 RColorBrewer_1.1-3 yaml_2.3.7 [76] gridExtra_2.3 memoise_2.0.1 reticulate_1.34.0 [79] pbapply_1.7-2 ggrastr_1.0.1 ggplot2_3.4.4 [82] sass_0.4.7 stringi_1.7.12 highr_0.10 [85] desc_1.4.2 fastDummies_1.7.3 rlang_1.1.1 [88] pkgconfig_2.0.3 systemfonts_1.0.4 matrixStats_1.0.0 [91] evaluate_0.22 lattice_0.21-9 tensor_1.5 [94] ROCR_1.0-11 purrr_1.0.2 labeling_0.4.3 [97] patchwork_1.1.3 htmlwidgets_1.6.2 cowplot_1.1.1 [100] tidyselect_1.2.0 parallelly_1.36.0 RcppAnnoy_0.0.21 [103] plyr_1.8.9 magrittr_2.0.3 R6_2.5.1 [106] generics_0.1.3 withr_2.5.2 pillar_1.9.0 [109] fitdistrplus_1.1-11 abind_1.4-5 survival_3.5-7 [112] tibble_3.2.1 future.apply_1.11.0 KernSmooth_2.23-22 [115] utf8_1.2.4 spatstat.geom_3.2-7 plotly_4.10.3 [118] rmarkdown_2.25 grid_4.2.2 data.table_1.14.8 [121] digest_0.6.33 xtable_1.8-4 tidyr_1.3.0 [124] httpuv_1.6.12 textshaping_0.3.6 munsell_0.5.0 [127] beeswarm_0.4.0 viridisLite_0.4.2 vipor_0.4.5 [130] bslib_0.5.1 ```",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/hashing_vignette",
      "title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat • Seurat",
      "ogTitle": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "language": "en",
      "og:title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "scrapeId": "ab6f2cd5-bb08-42e3-accf-70c0989f8c1c",
      "viewport": "width=device-width, initial-scale=1.0",
      "sourceURL": "https://satijalab.org/seurat/articles/hashing_vignette",
      "statusCode": 200,
      "ogDescription": "Seurat",
      "og:description": "Seurat"
    }
  },
  {
    "processed_text": "",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/seurat5_integration_introduction.html",
      "error": "Not Found",
      "scrapeId": "ac43e1a5-7f3e-42a9-b8be-064b3f37edcd",
      "sourceURL": "https://satijalab.org/seurat/articles/seurat5_integration_introduction.html",
      "statusCode": 404
    }
  },
  {
    "processed_text": "News Source: vignettes/announcements.Rmd announcements.Rmd Changes in Seurat v5 anchor We are excited to release Seurat v5 on CRAN, where it is now the default version for new installs. Seurat v5 is designed to be backwards compatible with Seurat v4 so existing code will continue to run, but we have made some changes to the software that will affect user results. We note that users who aim to reproduce their previous workflows in Seurat v4 can still install this version using the instructions on our install page . In particular, we have made changes to: Seurat Object and Assay class: Seurat v5 now includes support for additional assay and data types, including on-disk matrices. To facilitate this, we have introduced an updated Seurat v5 assay. Users can check out this [vignette for more information]. Briefly, Seurat v5 assays store data in layers (previously referred to as ‘slots’). For example, these layers can store: raw counts (layer='counts') , normalized data (layer='data') , or z-scored/variance-stabilized data (layer='scale.data') . Data can be accessed using the $ accessor (i.e. obj[[\"RNA\"]]$counts ), or the ` LayerData function (i.e. LayerData(obj, assay=\"RNA\", layer='counts') . We’ve designed these updates to minimize changes for users. Existing Seurat functions and workflows from v4 continue to work in v5. For example, the command GetAssayData(obj, assay=\"RNA\", slot='counts') , will run successfully in both Seurat v4 and Seurat v5. Integration workflow: Seurat v5 introduces a streamlined integration and data transfer workflows that performs integration in low-dimensional space, and improves speed and memory efficiency. The results of integration are not identical between the two workflows, but users can still run the v4 integration workflow in Seurat v5 if they wish. In previous versions of Seurat, the integration workflow required a list of multiple Seurat objects as input. In Seurat v5, all the data can be kept as a single object, but prior to integration, users can simply split the layers. See our introduction to integration vignette for more information. Differential expression: Seurat v5 now uses the presto package (from the Korunsky and Raychaudhari labs), when available, to perform differential expression analysis. Using presto can dramatically speed up DE testing, and we encourage users to install it. In addition, in Seurat v5 we implement a pseudocount (when calculating log-FC) at the group level instead of the cell level. As a result, users will observe higher logFC estimates in v5 - but should note that these estimates may be more unstable - particularly for genes that are very lowly expressed in one of the two groups. We gratefully acknowledge feedback from the McCarthy and Pachter labs on this topic. SCTransform v2: In Choudhary and Satija, Genome Biology, 2022 , we implement an updated version 2 of sctransform. This is now the default version when running SCTransform in Seurat v5. Users who wish to run the previous workflow can set the vst.flavor = \"v1\" argument in the SCTransform function. Pseudobulk analysis: Once a single-cell dataset has been analyzed to annotate cell subpopulations, pseudobulk analyses (i.e. aggregating together cells within a given subpopulation and sample) can reduce noise, improve quantification of lowly expressed genes, and reduce the size of the data matrix. In Seurat v5, we encourage the use of the AggregateExpression function to perform pseudobulk analysis. Check out our differential expression vignette as well as our pancreatic/healthy PBMC comparison , for examples of how to use AggregateExpression to perform robust differential expression of scRNA-seq data from multiple different conditions.",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/announcements",
      "title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat • Seurat",
      "ogTitle": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "language": "en",
      "og:title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "scrapeId": "7f19bffc-af5e-49f4-bad3-8c36c8a8619e",
      "viewport": "width=device-width, initial-scale=1.0",
      "sourceURL": "https://satijalab.org/seurat/articles/announcements",
      "statusCode": 200,
      "ogDescription": "Seurat",
      "og:description": "Seurat"
    }
  },
  {
    "processed_text": "Introduction to scRNA-seq integration Compiled: November 16, 2023 Source: vignettes/integration_introduction.Rmd integration_introduction.Rmd Introduction to scRNA-seq integration anchor Integration of single-cell sequencing datasets, for example across experimental batches, donors, or conditions, is often an important step in scRNA-seq workflows. Integrative analysis can help to match shared cell types and states across datasets, which can boost statistical power, and most importantly, facilitate accurate comparative analysis across datasets. In previous versions of Seurat we introduced methods for integrative analysis, including our ‘anchor-based’ integration workflow. Many labs have also published powerful and pioneering methods, including Harmony and scVI , for integrative analysis. Please see our Integrating scRNA-seq data with multiple tools vignette. Integration goals anchor The following tutorial is designed to give you an overview of the kinds of comparative analyses on complex cell types that are possible using the Seurat integration procedure. Here, we address a few key goals: Identify cell subpopulations that are present in both datasets Obtain cell type markers that are conserved in both control and stimulated cells Compare the datasets to find cell-type specific responses to stimulation Setup the Seurat objects anchor For convenience, we distribute this dataset through our SeuratData package. sourceCode R library(Seurat) library(SeuratData) library(patchwork) ```sourceCode R install dataset InstallData(\"ifnb\") ``` The object contains data from human PBMC from two conditions, interferon-stimulated and control cells (stored in the stim column in the object metadata). We will aim to integrate the two conditions together, so that we can jointly identify cell subpopulations across datasets, and then explore how each group differs across conditions In previous versions of Seurat, we would require the data to be represented as two different Seurat objects. In Seurat v5, we keep all the data in one object, but simply split it into multiple ‘layers’. To learn more about layers, check out our Seurat object interaction vignette . ```sourceCode R load dataset ifnb <- LoadData(\"ifnb\") split the RNA measurements into two layers one for control cells, one for stimulated cells ifnb[[\"RNA\"]] <- split(ifnb[[\"RNA\"]], f = ifnb$stim) ifnb ``` Perform analysis without integration anchor We can first analyze the dataset without integration. The resulting clusters are defined both by cell type and stimulation condition, which creates challenges for downstream analysis. ```sourceCode R run standard anlaysis workflow ifnb <- NormalizeData(ifnb) ifnb <- FindVariableFeatures(ifnb) ifnb <- ScaleData(ifnb) ifnb <- RunPCA(ifnb) ``` sourceCode R ifnb <- FindNeighbors(ifnb, dims = 1:30, reduction = \"pca\") ifnb <- FindClusters(ifnb, resolution = 2, cluster.name = \"unintegrated_clusters\") ``` Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck Number of nodes: 13999 Number of edges: 555146 Running Louvain algorithm... Maximum modularity in 10 random starts: 0.8153 Number of communities: 26 Elapsed time: 23 seconds ``` sourceCode R ifnb <- RunUMAP(ifnb, dims = 1:30, reduction = \"pca\", reduction.name = \"umap.unintegrated\") DimPlot(ifnb, reduction = \"umap.unintegrated\", group.by = c(\"stim\", \"seurat_clusters\")) Perform integration anchor We now aim to integrate data from the two conditions, so that cells from the same cell type/subpopulation will cluster together. We often refer to this procedure as intergration/alignment. When aligning two genome sequences together, identification of shared/homologous regions can help to interpret differences between the sequences as well. Similarly for scRNA-seq integration, our goal is not to remove biological differences across conditions, but to learn shared cell types/states in an initial step - specifically because that will enable us to compare control stimulated and control profiles for these individual cell types. The Seurat v5 integration procedure aims to return a single dimensional reduction that captures the shared sources of variance across multiple layers, so that cells in a similar biological state will cluster. The method returns a dimensional reduction (i.e. integrated.cca ) which can be used for visualization and unsupervised clustering analysis. For evaluating performance, we can use cell type labels that are pre-loaded in the seurat_annotations metadata column. ```sourceCode R ifnb <- IntegrateLayers(object = ifnb, method = CCAIntegration, orig.reduction = \"pca\", new.reduction = \"integrated.cca\", verbose = FALSE) re-join layers after integration ifnb[[\"RNA\"]] <- JoinLayers(ifnb[[\"RNA\"]]) ifnb <- FindNeighbors(ifnb, reduction = \"integrated.cca\", dims = 1:30) ifnb <- FindClusters(ifnb, resolution = 1) ``` ``` Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck Number of nodes: 13999 Number of edges: 588593 Running Louvain algorithm... Maximum modularity in 10 random starts: 0.8454 Number of communities: 17 Elapsed time: 26 seconds ``` sourceCode R ifnb <- RunUMAP(ifnb, dims = 1:30, reduction = \"integrated.cca\") ```sourceCode R Visualization DimPlot(ifnb, reduction = \"umap\", group.by = c(\"stim\", \"seurat_annotations\")) ``` To visualize the two conditions side-by-side, we can use the split.by argument to show each condition colored by cluster. sourceCode R DimPlot(ifnb, reduction = \"umap\", split.by = \"stim\") Identify conserved cell type markers anchor To identify canonical cell type marker genes that are conserved across conditions, we provide the FindConservedMarkers() function. This function performs differential gene expression testing for each dataset/group and combines the p-values using meta-analysis methods from the MetaDE R package. For example, we can calculated the genes that are conserved markers irrespective of stimulation condition in cluster 6 (NK cells). sourceCode R Idents(ifnb) <- \"seurat_annotations\" nk.markers <- FindConservedMarkers(ifnb, ident.1 = \"NK\", grouping.var = \"stim\", verbose = FALSE) head(nk.markers) ``` CTRL_p_val CTRL_avg_log2FC CTRL_pct.1 CTRL_pct.2 CTRL_p_val_adj GNLY 0 6.854586 0.943 0.046 0 NKG7 0 5.358881 0.953 0.085 0 GZMB 0 5.078135 0.839 0.044 0 CLIC3 0 5.765314 0.601 0.024 0 CTSW 0 5.307246 0.537 0.030 0 KLRD1 0 5.261553 0.507 0.019 0 STIM_p_val STIM_avg_log2FC STIM_pct.1 STIM_pct.2 STIM_p_val_adj max_pval GNLY 0 6.435910 0.956 0.059 0 0 NKG7 0 4.971397 0.950 0.081 0 0 GZMB 0 5.151924 0.897 0.060 0 0 CLIC3 0 5.505208 0.623 0.031 0 0 CTSW 0 5.240729 0.592 0.035 0 0 KLRD1 0 4.852457 0.555 0.027 0 0 minimump_p_val GNLY 0 NKG7 0 GZMB 0 CLIC3 0 CTSW 0 KLRD1 0 ``` You can perform these same analysis on the unsupervised clustering results (stored in seurat_clusters ), and use these conserved markers to annotate cell types in your dataset. The DotPlot() function with the split.by parameter can be useful for viewing conserved cell type markers across conditions, showing both the expression level and the percentage of cells in a cluster expressing any given gene. Here we plot 2-3 strong marker genes for each of our 14 clusters. ```sourceCode R NEEDS TO BE FIXED AND SET ORDER CORRECTLY Idents(ifnb) <- factor(Idents(ifnb), levels = c(\"pDC\", \"Eryth\", \"Mk\", \"DC\", \"CD14 Mono\", \"CD16 Mono\", \"B Activated\", \"B\", \"CD8 T\", \"NK\", \"T activated\", \"CD4 Naive T\", \"CD4 Memory T\")) markers.to.plot <- c(\"CD3D\", \"CREM\", \"HSPH1\", \"SELL\", \"GIMAP5\", \"CACYBP\", \"GNLY\", \"NKG7\", \"CCL5\", \"CD8A\", \"MS4A1\", \"CD79A\", \"MIR155HG\", \"NME1\", \"FCGR3A\", \"VMO1\", \"CCL2\", \"S100A9\", \"HLA-DQA1\", \"GPR183\", \"PPBP\", \"GNG11\", \"HBA2\", \"HBB\", \"TSPAN13\", \"IL3RA\", \"IGJ\", \"PRSS57\") DotPlot(ifnb, features = markers.to.plot, cols = c(\"blue\", \"red\"), dot.scale = 8, split.by = \"stim\") + RotatedAxis() ``` Identify differential expressed genes across conditions anchor Now that we’ve aligned the stimulated and control cells, we can start to do comparative analyses and look at the differences induced by stimulation. We can aggregate cells of a similar type and condition together to create “pseudobulk” profiles using the AggregateExpression command. As an initial exploratory analysis, we can compare pseudobulk profiles of two cell types (naive CD4 T cells, and CD14 monocytes), and compare their gene expression profiles before and after stimulation. We highlight genes that exhibit dramatic responses to interferon stimulation. As you can see, many of the same genes are upregulated in both of these cell types and likely represent a conserved interferon response pathway, though CD14 monocytes exhibit a stronger transcriptional response. ```sourceCode R library(ggplot2) library(cowplot) theme_set(theme_cowplot()) aggregate_ifnb <- AggregateExpression(ifnb, group.by = c(\"seurat_annotations\", \"stim\"), return.seurat = TRUE) genes.to.label = c(\"ISG15\", \"LY6E\", \"IFI6\", \"ISG20\", \"MX1\", \"IFIT2\", \"IFIT1\", \"CXCL10\", \"CCL8\") p1 <- CellScatter(aggregate_ifnb, \"CD14 Mono_CTRL\", \"CD14 Mono_STIM\", highlight = genes.to.label) p2 <- LabelPoints(plot = p1, points = genes.to.label, repel = TRUE) p3 <- CellScatter(aggregate_ifnb, \"CD4 Naive T_CTRL\", \"CD4 Naive T_STIM\", highlight = genes.to.label) p4 <- LabelPoints(plot = p3, points = genes.to.label, repel = TRUE) p2 + p4 ``` We can now ask what genes change in different conditions for cells of the same type. First, we create a column in the meta.data slot to hold both the cell type and stimulation information and switch the current ident to that column. Then we use FindMarkers() to find the genes that are different between stimulated and control B cells. Notice that many of the top genes that show up here are the same as the ones we plotted earlier as core interferon response genes. Additionally, genes like CXCL10 which we saw were specific to monocyte and B cell interferon response show up as highly significant in this list as well. Please note that p-values obtained from this analysis should be interpreted with caution, as these tests treat each cell as an independent replicate, and ignore inherent correlations between cells originating from the same sample. As discussed here , DE tests across multiple conditions should expressly utilize multiple samples/replicates, and can be performed after aggregating (‘pseudobulking’) cells from the same sample and subpopulation together. We do not perform this analysis here, as there is a single replicate in the data, but please see our vignette comparing healthy and diabetic samples as an example for how to perform DE analysis across conditions. sourceCode R ifnb$celltype.stim <- paste(ifnb$seurat_annotations, ifnb$stim, sep = \"_\") Idents(ifnb) <- \"celltype.stim\" b.interferon.response <- FindMarkers(ifnb, ident.1 = \"B_STIM\", ident.2 = \"B_CTRL\", verbose = FALSE) head(b.interferon.response, n = 15) ``` p_val avg_log2FC pct.1 pct.2 p_val_adj ISG15 5.387767e-159 5.0588481 0.998 0.233 7.571429e-155 IFIT3 1.945114e-154 6.1124940 0.965 0.052 2.733468e-150 IFI6 2.503565e-152 5.4933132 0.965 0.076 3.518260e-148 ISG20 6.492570e-150 3.0549593 1.000 0.668 9.124009e-146 IFIT1 1.951022e-139 6.2320388 0.907 0.029 2.741772e-135 MX1 6.897626e-123 3.9798482 0.905 0.115 9.693234e-119 LY6E 2.825649e-120 3.7907800 0.898 0.150 3.970885e-116 TNFSF10 4.007285e-112 6.5802175 0.786 0.020 5.631437e-108 IFIT2 2.672552e-108 5.5525558 0.786 0.037 3.755738e-104 B2M 5.283684e-98 0.6104044 1.000 1.000 7.425161e-94 PLSCR1 4.634658e-96 3.8010721 0.793 0.113 6.513085e-92 IRF7 2.411149e-94 3.1992949 0.835 0.187 3.388388e-90 CXCL10 3.708508e-86 8.0906108 0.651 0.010 5.211566e-82 UBE2L6 5.547472e-83 2.5167981 0.851 0.297 7.795863e-79 PSMB9 1.716262e-77 1.7715351 0.937 0.568 2.411863e-73 ``` Another useful way to visualize these changes in gene expression is with the split.by option to the FeaturePlot() or VlnPlot() function. This will display FeaturePlots of the list of given genes, split by a grouping variable (stimulation condition here). Genes such as CD3D and GNLY are canonical cell type markers (for T cells and NK/CD8 T cells) that are virtually unaffected by interferon stimulation and display similar gene expression patterns in the control and stimulated group. IFI6 and ISG15, on the other hand, are core interferon response genes and are upregulated accordingly in all cell types. Finally, CD14 and CXCL10 are genes that show a cell type specific interferon response. CD14 expression decreases after stimulation in CD14 monocytes, which could lead to misclassification in a supervised analysis framework, underscoring the value of integrated analysis. CXCL10 shows a distinct upregulation in monocytes and B cells after interferon stimulation but not in other cell types. sourceCode R FeaturePlot(ifnb, features = c(\"CD3D\", \"GNLY\", \"IFI6\"), split.by = \"stim\", max.cutoff = 3, cols = c(\"grey\", \"red\"), reduction = \"umap\") sourceCode R plots <- VlnPlot(ifnb, features = c(\"LYZ\", \"ISG15\", \"CXCL10\"), split.by = \"stim\", group.by = \"seurat_annotations\", pt.size = 0, combine = FALSE) wrap_plots(plots = plots, ncol = 1) Perform integration with SCTransform-normalized datasets anchor As an alternative to log-normalization, Seurat also includes support for preprocessing of scRNA-seq using the sctransform workflow . The IntegrateLayers function also supports SCTransform-normalized data, by setting the normalization.method parameter, as shown below. ```sourceCode R ifnb <- LoadData(\"ifnb\") split datasets and process without integration ifnb[[\"RNA\"]] <- split(ifnb[[\"RNA\"]], f = ifnb$stim) ifnb <- SCTransform(ifnb) ifnb <- RunPCA(ifnb) ifnb <- RunUMAP(ifnb, dims = 1:30) DimPlot(ifnb, reduction = \"umap\", group.by = c(\"stim\", \"seurat_annotations\")) ``` ```sourceCode R integrate datasets ifnb <- IntegrateLayers(object = ifnb, method = CCAIntegration, normalization.method = \"SCT\", verbose = F) ifnb <- FindNeighbors(ifnb, reduction = \"integrated.dr\", dims = 1:30) ifnb <- FindClusters(ifnb, resolution = 0.6) ``` ``` Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck Number of nodes: 13999 Number of edges: 528127 Running Louvain algorithm... Maximum modularity in 10 random starts: 0.9060 Number of communities: 20 Elapsed time: 21 seconds ``` sourceCode R ifnb <- RunUMAP(ifnb, dims = 1:30, reduction = \"integrated.dr\") DimPlot(ifnb, reduction = \"umap\", group.by = c(\"stim\", \"seurat_annotations\")) ```sourceCode R perform differential expression ifnb <- PrepSCTFindMarkers(ifnb) ifnb$celltype.stim <- paste(ifnb$seurat_annotations, ifnb$stim, sep = \"_\") Idents(ifnb) <- \"celltype.stim\" b.interferon.response <- FindMarkers(ifnb, ident.1 = \"B_STIM\", ident.2 = \"B_CTRL\", verbose = FALSE) ``` ``` Session Info sourceCode R sessionInfo() ``` R version 4.2.2 Patched (2022-11-10 r83330) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.6 LTS Matrix products: default BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats graphics grDevices utils datasets methods base other attached packages: [1] cowplot_1.1.1 ggplot2_3.4.4 [3] patchwork_1.1.3 thp1.eccite.SeuratData_3.1.5 [5] stxBrain.SeuratData_0.1.1 ssHippo.SeuratData_3.1.4 [7] pbmcsca.SeuratData_3.0.0 pbmcref.SeuratData_1.0.0 [9] pbmcMultiome.SeuratData_0.1.4 pbmc3k.SeuratData_3.1.4 [11] panc8.SeuratData_3.0.2 ifnb.SeuratData_3.0.0 [13] hcabm40k.SeuratData_3.0.0 cbmc.SeuratData_3.1.4 [15] bonemarrowref.SeuratData_1.0.0 bmcite.SeuratData_0.3.0 [17] SeuratData_0.2.2.9001 Seurat_5.0.1 [19] testthat_3.2.0 SeuratObject_5.0.1 [21] sp_2.1-1 loaded via a namespace (and not attached): [1] utf8_1.2.4 spatstat.explore_3.2-5 [3] reticulate_1.34.0 tidyselect_1.2.0 [5] htmlwidgets_1.6.2 grid_4.2.2 [7] Rtsne_0.16 devtools_2.4.5 [9] munsell_0.5.0 mutoss_0.1-13 [11] codetools_0.2-19 ragg_1.2.5 [13] ica_1.0-3 future_1.33.0 [15] miniUI_0.1.1.1 withr_2.5.2 [17] spatstat.random_3.2-1 colorspace_2.1-0 [19] progressr_0.14.0 Biobase_2.58.0 [21] highr_0.10 knitr_1.45 [23] rstudioapi_0.14 stats4_4.2.2 [25] ROCR_1.0-11 tensor_1.5 [27] listenv_0.9.0 MatrixGenerics_1.10.0 [29] Rdpack_2.5 labeling_0.4.3 [31] GenomeInfoDbData_1.2.9 mnormt_2.1.1 [33] polyclip_1.10-6 farver_2.1.1 [35] rprojroot_2.0.4 TH.data_1.1-2 [37] parallelly_1.36.0 vctrs_0.6.4 [39] generics_0.1.3 xfun_0.40 [41] GenomeInfoDb_1.34.9 R6_2.5.1 [43] ggbeeswarm_0.7.1 DelayedArray_0.24.0 [45] bitops_1.0-7 spatstat.utils_3.0-4 [47] cachem_1.0.8 promises_1.2.1 [49] scales_1.2.1 multcomp_1.4-25 [51] beeswarm_0.4.0 gtable_0.3.4 [53] globals_0.16.2 processx_3.8.2 [55] goftest_1.2-3 spam_2.10-0 [57] sandwich_3.0-2 rlang_1.1.1 [59] systemfonts_1.0.4 splines_4.2.2 [61] lazyeval_0.2.2 spatstat.geom_3.2-7 [63] yaml_2.3.7 reshape2_1.4.4 [65] abind_1.4-5 httpuv_1.6.12 [67] tools_4.2.2 usethis_2.1.6 [69] ellipsis_0.3.2 jquerylib_0.1.4 [71] RColorBrewer_1.1-3 BiocGenerics_0.44.0 [73] sessioninfo_1.2.2 ggridges_0.5.4 [75] TFisher_0.2.0 Rcpp_1.0.11 [77] plyr_1.8.9 sparseMatrixStats_1.10.0 [79] zlibbioc_1.44.0 RCurl_1.98-1.12 [81] purrr_1.0.2 ps_1.7.5 [83] prettyunits_1.2.0 deldir_1.0-9 [85] pbapply_1.7-2 urlchecker_1.0.1 [87] S4Vectors_0.36.2 zoo_1.8-12 [89] SummarizedExperiment_1.28.0 ggrepel_0.9.4 [91] cluster_2.1.4 fs_1.6.3 [93] magrittr_2.0.3 glmGamPoi_1.10.2 [95] data.table_1.14.8 RSpectra_0.16-1 [97] scattermore_1.2 lmtest_0.9-40 [99] RANN_2.6.1 mvtnorm_1.2-3 [101] fitdistrplus_1.1-11 matrixStats_1.0.0 [103] pkgload_1.3.3 mime_0.12 [105] evaluate_0.22 xtable_1.8-4 [107] IRanges_2.32.0 fastDummies_1.7.3 [109] gridExtra_2.3 compiler_4.2.2 [111] tibble_3.2.1 KernSmooth_2.23-22 [113] crayon_1.5.2 htmltools_0.5.6.1 [115] later_1.3.1 tidyr_1.3.0 [117] formatR_1.14 MASS_7.3-58.2 [119] rappdirs_0.3.3 Matrix_1.6-1.1 [121] brio_1.1.3 cli_3.6.1 [123] rbibutils_2.2.15 qqconf_1.3.2 [125] parallel_4.2.2 dotCall64_1.1-0 [127] metap_1.9 igraph_1.5.1 [129] GenomicRanges_1.50.2 pkgconfig_2.0.3 [131] sn_2.1.1 pkgdown_2.0.7 [133] numDeriv_2016.8-1.1 plotly_4.10.3 [135] spatstat.sparse_3.0-3 vipor_0.4.5 [137] bslib_0.5.1 XVector_0.38.0 [139] multtest_2.54.0 stringr_1.5.0 [141] callr_3.7.3 digest_0.6.33 [143] sctransform_0.4.1 RcppAnnoy_0.0.21 [145] spatstat.data_3.0-3 rmarkdown_2.25 [147] leiden_0.4.3 uwot_0.1.16 [149] DelayedMatrixStats_1.20.0 shiny_1.7.5.1 [151] lifecycle_1.0.4 nlme_3.1-162 [153] jsonlite_1.8.7 limma_3.54.1 [155] desc_1.4.2 viridisLite_0.4.2 [157] fansi_1.0.5 pillar_1.9.0 [159] lattice_0.21-9 ggrastr_1.0.1 [161] plotrix_3.8-2 fastmap_1.1.1 [163] httr_1.4.7 pkgbuild_1.4.2 [165] survival_3.5-7 glue_1.6.2 [167] remotes_2.4.2.1 png_0.1-8 [169] presto_1.0.0 stringi_1.7.12 [171] sass_0.4.7 profvis_0.3.7 [173] textshaping_0.3.6 RcppHNSW_0.5.0 [175] memoise_2.0.1 mathjaxr_1.6-0 [177] dplyr_1.1.3 irlba_2.3.5.1 [179] future.apply_1.11.0 ```",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/integration_introduction",
      "title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat • Seurat",
      "ogTitle": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "language": "en",
      "og:title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "scrapeId": "b8e4a1b2-09e2-4433-bc7a-93422d0eb16a",
      "viewport": "width=device-width, initial-scale=1.0",
      "sourceURL": "https://satijalab.org/seurat/articles/integration_introduction",
      "statusCode": 200,
      "ogDescription": "Seurat",
      "og:description": "Seurat"
    }
  },
  {
    "processed_text": "",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/interaction_vignette",
      "error": "Not Found",
      "scrapeId": "6bcded76-904a-4c57-b156-169206d04992",
      "sourceURL": "https://satijalab.org/seurat/articles/interaction_vignette",
      "statusCode": 404
    }
  },
  {
    "processed_text": "Getting Started with Seurat v4 Source: vignettes/get_started.Rmd get_started.Rmd We provide a series of vignettes, tutorials, and analysis walkthroughs to help users get started with Seurat. You can also check out our Reference page which contains a full list of functions available to users. Introductory Vignettes anchor For new users of Seurat, we suggest starting with a guided walk through of a dataset of 2,700 Peripheral Blood Mononuclear Cells (PBMCs) made publicly available by 10X Genomics. This tutorial implements the major components of a standard unsupervised clustering workflow including QC and data filtration, calculation of high-variance genes, dimensional reduction, graph-based clustering, and the identification of cluster markers. We provide additional introductory vignettes for users who are interested in analyzing multimodal single-cell datasets (e.g. from CITE-seq, or the 10x multiome kit), or spatial datasets (e.g. 10x Visium or Vizgen MERFISH). | | | | | --- | --- | --- | | Guided tutorial — 2,700 PBMCs | Multimodal analysis | Analysis of spatial datasets (Sequencing-based) | | | | | | A basic overview of Seurat that includes an introduction to common analytical workflows. | An introduction to working with multi-modal datasets in Seurat. | Learn to explore spatially-resolved transcriptomic data with examples from 10x Visium and Slide-seq v2. | | GO | GO | GO | | | | --- | | Analysis of spatial datasets (Imaging-based) | | | | Learn to explore spatially-resolved data from multiplexed imaging technologies, including MERFISH, Xenium, CosMx SMI, and CODEX. | | GO | Data Integration anchor Recently, we have developed computational methods for integrated analysis of single-cell datasets generated across different conditions, technologies, or species. As an example, we provide a guided walk through for integrating and comparing PBMC datasets generated under different stimulation conditions. We provide additional vignettes demonstrating how to leverage an annotated scRNA-seq reference to map and label cells from a query, and to efficiently integrate large datasets. | | | | | --- | --- | --- | | Introduction to scRNA-seq integration | Mapping and annotating query datasets | Fast integration using reciprocal PCA (RPCA) | | | | | | An introduction to integrating scRNA-seq datasets in order to identify and compare shared cell types across experiments. | Learn how to map a query scRNA-seq dataset onto a reference in order to automate the annotation and visualization of query cells. | Identify anchors using the reciprocal PCA (rPCA) workflow, which performs a faster and more conservative integration. | | GO | GO | GO | | | | | | --- | --- | --- | | Tips for integrating large datasets | Integrating scRNA-seq and scATAC-seq data | Multimodal Reference Mapping | | | | | | Tips and examples for integrating very large scRNA-seq datasets (including >200,000 cells). | Annotate, visualize, and interpret an scATAC-seq experiment using scRNA-seq data from the same biological system. | Analyze query data in the context of multimodal reference atlases. | | GO | GO | GO | Additional New Methods anchor Seurat also offers additional novel statistical methods for analyzing single-cell data. These include: Weighted-nearest neighbor (WNN) analysis: to define cell state based on multiple modalities [ paper ] Mixscape: to analyze data from pooled single-cell CRISPR screens [ paper ] SCTransform: Improved normalization for single-cell RNA-seq data [ paper ]] SCTransform, v2 regularization [ paper ]] | | | | | --- | --- | --- | | Weighted Nearest Neighbor Analysis | Mixscape | SCTransform | | | | | | Analyze multimodal single-cell data with weighted nearest neighbor analysis in Seurat v4. | Explore new methods to analyze pooled single-celled perturbation screens. | Examples of how to use the SCTransform wrapper in Seurat. | | GO | GO | GO | | | | --- | | SCTransform, v2 regularization | | | | Examples of how to perform normalization, feature selection, integration, and differential expression with an updated version of sctransform. | | GO | Other anchor Here we provide a series of short vignettes to demonstrate a number of features that are commonly used in Seurat. We’ve focused the vignettes around questions that we frequently receive from users. Click on a vignette to get started. | | | | | --- | --- | --- | | Visualization | Cell Cycle Regression | Differential Expression Testing | | | | | | An overview of the major visualization functionality within Seurat. | Mitigate the effects of cell cycle heterogeneity by computing cell cycle phase scores based on marker genes. | Perform differential expression (DE) testing in Seurat using a number of frameworks. | | GO | GO | GO | | | | | | --- | --- | --- | | Demultiplex Cell Hashing data | Interoperability with Other Analysis Tools | Parallelization | | | | | | Learn how to work with data produced with Cell Hashing. | Convert data between formats for different analysis tools. | Speed up compute-intensive functions with parallelization. | | GO | GO | GO | SeuratWrappers anchor In order to facilitate the use of community tools with Seurat, we provide the Seurat Wrappers package, which contains code to run other analysis tools on Seurat objects. For the initial release, we provide wrappers for a few packages in the table below but would encourage other package developers interested in interfacing with Seurat to check out our contributor guide here . | Package | Vignette | Reference | Source | | --- | --- | --- | --- | | alevin | Import alevin counts into Seurat | Srivastava et. al., Genome Biology 2019 | https://github.com/k3yavi/alevin-Rtools | | ALRA | Zero-preserving imputation with ALRA | Linderman et al, bioRxiv 2018 | https://github.com/KlugerLab/ALRA | | CoGAPS | Running CoGAPS on Seurat Objects | Stein-O’Brien et al, Cell Systems 2019 | https://www.bioconductor.org/packages/release/bioc/html/CoGAPS.html | | Conos | Integration of datasets using Conos | Barkas et al, Nature Methods 2019 | https://github.com/hms-dbmi/conos | | fastMNN | Running fastMNN on Seurat Objects | Haghverdi et al, Nature Biotechnology 2018 | https://bioconductor.org/packages/release/bioc/html/scran.html | | glmpca | Running GLM-PCA on a Seurat Object | Townes et al, Genome Biology 2019 | https://github.com/willtownes/glmpca | | Harmony | Integration of datasets using Harmony | Korsunsky et al, Nature Methods 2019 | https://github.com/immunogenomics/harmony | | LIGER | Integrating Seurat objects using LIGER | Welch et al, Cell 2019 | https://github.com/MacoskoLab/liger | | Monocle3 | Calculating Trajectories with Monocle 3 and Seurat | Cao et al, Nature 2019 | https://cole-trapnell-lab.github.io/monocle3 | | Nebulosa | Visualization of gene expression with Nebulosa | Jose Alquicira-Hernandez and Joseph E. Powell, Under Review | https://github.com/powellgenomicslab/Nebulosa | | schex | Using schex with Seurat | Freytag, R package 2019 | https://github.com/SaskiaFreytag/schex | | scVelo | Estimating RNA Velocity using Seurat and scVelo | Bergen et al, bioRxiv 2019 | https://scvelo.readthedocs.io/ | | Velocity | Estimating RNA Velocity using Seurat | La Manno et al, Nature 2018 | https://velocyto.org | | CIPR | Using CIPR with human PBMC data | Ekiz et. al., BMC Bioinformatics 2020 | https://github.com/atakanekiz/CIPR-Package | | miQC | Running miQC on Seurat objects | Hippen et. al., bioRxiv 2021 | https://github.com/greenelab/miQC | | tricycle | Running estimate_cycle_position from tricycle on Seurat Objects | Zheng et. al., bioRxiv 2021 | https://www.bioconductor.org/packages/release/bioc/html/tricycle.html |",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/get_started",
      "title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat • Seurat",
      "ogTitle": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "language": "en",
      "og:title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "scrapeId": "bce6568d-73f7-4079-a8cf-92b4eb8d9b0f",
      "viewport": "width=device-width, initial-scale=1.0",
      "sourceURL": "https://satijalab.org/seurat/articles/get_started",
      "statusCode": 200,
      "ogDescription": "Seurat",
      "og:description": "Seurat"
    }
  },
  {
    "processed_text": "Seurat Extension Packages Source: vignettes/extensions.Rmd extensions.Rmd In addition to the core Seurat package, we provide several extensions that enhance the functionality and utility of Seurat. A brief description of each is listed below with links to more complete documentation and examples. Signac anchor Signac is an R toolkit that extends Seurat for the analysis, interpretation, and exploration of single-cell chromatin datasets. The software supports the following features: Calculating single-cell QC metrics Dimensional reduction, visualization, and clustering Identifying cell type-specific peaks Visualizing ‘pseudo-bulk’ coverage tracks Integration with single-cell RNA-seq datasets For documentation and vignettes, click here . SeuratData anchor SeuratData is a mechanism for distributing datasets in the form of Seurat objects using R’s internal package and data management systems. It represents an easy way for users to get access to datasets that are used in the Seurat vignettes. For more information, click here . SeuratWrappers anchor In order to facilitate the use of community tools with Seurat, we provide the SeuratWrappers package, which contains code to run other analysis tools on Seurat objects. For a full list of supported packages and vignettes, please see our vignettes page. SeuratDisk anchor The SeuratDisk package introduces the h5Seurat file format for the storage and analysis of multimodal single-cell and spatially-resolved expression experiments. The SeuratDisk package provides functions to save Seurat objects as h5Seurat files, and functions for rapid on-disk conversion between h5Seurat and AnnData formats with the goal of enhancing interoperability between Seurat and Scanpy. For more information, click here Azimuth anchor Azimuth is a web application that uses an annotated reference dataset to automate the processing, analysis, and interpretation of a new single-cell RNA-seq experiment. Azimuth leverages a ‘reference-based mapping’ pipeline that inputs a counts matrix of gene expression in single cells, and performs normalization, visualization, cell annotation, and differential expression (biomarker discovery). All results can be explored within the app, and easily downloaded for additional downstream analysis. To use the Azimuth web app, visit the Azimuth website here . BPCells anchor Developed by Greenleaf Lab, BPCells is an R package that allows for computationally efficient single-cell analysis. It utilizes bit-packing compression to store counts matrices on disk and C++ code to cache operations. BPCells is an R package that allows for computationally efficient single-cell analysis. It utilizes bit-packing compression to store counts matrices on disk and C++ code to cache operations. presto anchor Developed by Korunsky/Raychaudhari labs, presto performs a fast Wilcoxon rank sum test and auROC analysis. Seurat uses the presto package to perform fast differential expression.",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/extensions",
      "title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat • Seurat",
      "ogTitle": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "language": "en",
      "og:title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "scrapeId": "c055457d-8228-4574-8d67-7a5a22d451b2",
      "viewport": "width=device-width, initial-scale=1.0",
      "sourceURL": "https://satijalab.org/seurat/articles/extensions",
      "statusCode": 200,
      "ogDescription": "Seurat",
      "og:description": "Seurat"
    }
  },
  {
    "processed_text": "Differential expression testing Compiled: 2024-03-04 Source: vignettes/de_vignette.Rmd de_vignette.Rmd Load in the data anchor This vignette highlights some example workflows for performing differential expression in Seurat. For demonstration purposes, we will be using the interferon-beta stimulated human PBMCs dataset ( ifnb ) that is available via the SeuratData package. sourceCode R library(Seurat) library(SeuratData) library(ggplot2) ifnb <- LoadData(\"ifnb\") Perform default differential expression tests anchor The bulk of Seurat’s differential expression features can be accessed through the FindMarkers() function. By default, Seurat performs differential expression (DE) testing based on the non-parametric Wilcoxon rank sum test. To test for DE genes between two specific groups of cells, specify the ident.1 and ident.2 parameters. ```sourceCode R Normalize the data ifnb <- NormalizeData(ifnb) Find DE features between CD16 Mono and CD1 Mono Idents(ifnb) <- \"seurat_annotations\" monocyte.de.markers <- FindMarkers(ifnb, ident.1 = \"CD16 Mono\", ident.2 = \"CD14 Mono\") view results head(monocyte.de.markers) ``` ``` p_val avg_log2FC pct.1 pct.2 p_val_adj VMO1 0 5.700274 0.778 0.084 0 MS4A4A 0 3.349751 0.748 0.143 0 FCGR3A 0 3.281942 0.982 0.418 0 PLAC8 0 3.268470 0.636 0.124 0 CXCL16 0 2.014758 0.938 0.475 0 MS4A7 0 2.386436 0.978 0.558 0 ``` The results data frame has the following columns : p_val : p-value (unadjusted) avg_log2FC : log fold-change of the average expression between the two groups. Positive values indicate that the feature is more highly expressed in the first group. pct.1 : The percentage of cells where the feature is detected in the first group pct.2 : The percentage of cells where the feature is detected in the second group p_val_adj : Adjusted p-value, based on Bonferroni correction using all features in the dataset. If the ident.2 parameter is omitted or set to NULL , FindMarkers() will test for differentially expressed features between the group specified by ident.1 and all other cells. Additionally, the parameter only.pos can be set to TRUE to only search for positive markers, i.e. features that are more highly expressed in the ident.1 group. ```sourceCode R Find differentially expressed features between CD14+ Monocytes and all other cells, only search for positive markers monocyte.de.markers <- FindMarkers(ifnb, ident.1 = \"CD16 Mono\", ident.2 = NULL, only.pos = TRUE) view results head(monocyte.de.markers) ``` ``` p_val avg_log2FC pct.1 pct.2 p_val_adj FCGR3A 0 4.532656 0.982 0.168 0 MS4A7 0 3.806350 0.978 0.216 0 CXCL16 0 3.274267 0.938 0.196 0 VMO1 0 6.254651 0.778 0.044 0 MS4A4A 0 4.747731 0.748 0.055 0 LST1 0 2.927351 0.912 0.228 0 ``` Perform DE analysis within the same cell type across conditions anchor Since this dataset contains treatment information (control versus stimulated with interferon-beta), we can also ask what genes change in different conditions for cells of the same type. First, we create a column in the meta.data slot to hold both the cell type and treatment information and switch the current Idents to that column. Then we use FindMarkers() to find the genes that are different between control and stimulated CD14 monocytes. sourceCode R ifnb$celltype.stim <- paste(ifnb$seurat_annotations, ifnb$stim, sep = \"_\") Idents(ifnb) <- \"celltype.stim\" mono.de <- FindMarkers(ifnb, ident.1 = \"CD14 Mono_STIM\", ident.2 = \"CD14 Mono_CTRL\", verbose = FALSE) head(mono.de, n = 10) ``` p_val avg_log2FC pct.1 pct.2 p_val_adj IFIT1 0 7.319139 0.985 0.033 0 CXCL10 0 8.036564 0.984 0.035 0 RSAD2 0 6.741673 0.988 0.045 0 TNFSF10 0 6.991279 0.989 0.047 0 IFIT3 0 6.883785 0.992 0.056 0 IFIT2 0 7.179929 0.961 0.039 0 CXCL11 0 8.624208 0.932 0.012 0 CCL8 0 9.134191 0.918 0.017 0 IDO1 0 5.455898 0.965 0.089 0 MX1 0 5.059052 0.960 0.093 0 ``` However, the p-values obtained from this analysis should be interpreted with caution, because these tests treat each cell as an independent replicate and ignore inherent correlations between cells originating from the same sample. Such analyses have been shown to find a large number of false positive associations, as has been demonstrated by Squair et al., 2021 , Zimmerman et al., 2021 , Junttila et al., 2022 , and others. Below, we show how pseudobulking can be used to account for such within-sample correlation. Perform DE analysis after pseudobulking anchor To pseudobulk, we will use AggregateExpression() to sum together gene counts of all the cells from the same sample for each cell type. This results in one gene expression profile per sample and cell type. We can then perform DE analysis using DESeq2 on the sample level. This treats the samples, rather than the individual cells, as independent observations. First, we need to retrieve the sample information for each cell. This is not loaded in the metadata, so we will load it from the Github repo of the source data for the original paper. Add sample information to the dataset ```sourceCode R load the inferred sample IDs of each cell ctrl <- read.table(url(\"https://raw.githubusercontent.com/yelabucsf/demuxlet_paper_code/master/fig3/ye1.ctrl.8.10.sm.best\"), head = T, stringsAsFactors = F) stim <- read.table(url(\"https://raw.githubusercontent.com/yelabucsf/demuxlet_paper_code/master/fig3/ye2.stim.8.10.sm.best\"), head = T, stringsAsFactors = F) info <- rbind(ctrl, stim) rename the cell IDs by substituting the '-' into '.' info$BARCODE <- gsub(pattern = \"\\-\", replacement = \"\\.\", info$BARCODE) only keep the cells with high-confidence sample ID info <- info[grep(pattern = \"SNG\", x = info$BEST), ] remove cells with duplicated IDs in both ctrl and stim groups info <- info[!duplicated(info$BARCODE) & !duplicated(info$BARCODE, fromLast = T), ] now add the sample IDs to ifnb rownames(info) <- info$BARCODE info <- info[, c(\"BEST\"), drop = F] names(info) <- c(\"donor_id\") ifnb <- AddMetaData(ifnb, metadata = info) remove cells without donor IDs ifnb$donor_id[is.na(ifnb$donor_id)] <- \"unknown\" ifnb <- subset(ifnb, subset = donor_id != \"unknown\") ``` We can now perform pseudobulking ( AggregateExpression() ) based on the donor IDs. ```sourceCode R pseudobulk the counts based on donor-condition-celltype pseudo_ifnb <- AggregateExpression(ifnb, assays = \"RNA\", return.seurat = T, group.by = c(\"stim\", \"donor_id\", \"seurat_annotations\")) each 'cell' is a donor-condition-celltype pseudobulk profile tail(Cells(pseudo_ifnb)) ``` ``` [1] \"STIM_SNG-1488_NK\" \"STIM_SNG-1488_DC\" [3] \"STIM_SNG-1488_B Activated\" \"STIM_SNG-1488_Mk\" [5] \"STIM_SNG-1488_pDC\" \"STIM_SNG-1488_Eryth\" ``` sourceCode R pseudo_ifnb$celltype.stim <- paste(pseudo_ifnb$seurat_annotations, pseudo_ifnb$stim, sep = \"_\") Next, we perform DE testing on the pseudobulk level for CD14 monocytes, and compare it against the previous single-cell-level DE results. ```sourceCode R Idents(pseudo_ifnb) <- \"celltype.stim\" bulk.mono.de <- FindMarkers(object = pseudo_ifnb, ident.1 = \"CD14 Mono_STIM\", ident.2 = \"CD14 Mono_CTRL\", test.use = \"DESeq2\") head(bulk.mono.de, n = 15) ``` ``` p_val avg_log2FC pct.1 pct.2 p_val_adj IL1RN 3.701542e-275 6.160156 1 1 5.201777e-271 IFITM2 1.955626e-250 4.318976 1 1 2.748242e-246 SSB 2.699554e-203 3.066647 1 1 3.793684e-199 NT5C3A 2.239898e-198 5.412972 1 1 3.147729e-194 RTCB 5.700554e-162 3.133362 1 1 8.010989e-158 RABGAP1L 4.743010e-161 5.562364 1 1 6.665352e-157 DYNLT1 9.735640e-159 2.402726 1 1 1.368150e-154 PLSCR1 3.191691e-146 2.676047 1 1 4.485284e-142 ISG20 9.664488e-145 5.443114 1 1 1.358150e-140 NAPA 2.858013e-144 1.977719 1 1 4.016365e-140 DDX58 5.957026e-142 4.640111 1 1 8.371409e-138 HERC5 6.333722e-133 5.266515 1 1 8.900780e-129 OASL 3.892853e-130 3.946745 1 1 5.470627e-126 EIF2AK2 6.636434e-128 3.940167 1 1 9.326180e-124 TMEM50A 6.731955e-117 1.355947 1 1 9.460417e-113 ``` ```sourceCode R compare the DE P-values between the single-cell level and the pseudobulk level results names(bulk.mono.de) <- paste0(names(bulk.mono.de), \".bulk\") bulk.mono.de$gene <- rownames(bulk.mono.de) names(mono.de) <- paste0(names(mono.de), \".sc\") mono.de$gene <- rownames(mono.de) merge_dat <- merge(mono.de, bulk.mono.de, by = \"gene\") merge_dat <- merge_dat[order(merge_dat$p_val.bulk), ] Number of genes that are marginally significant in both; marginally significant only in bulk; and marginally significant only in single-cell common <- merge_dat$gene[which(merge_dat$p_val.bulk < 0.05 &\\ merge_dat$p_val.sc < 0.05)] only_sc <- merge_dat$gene[which(merge_dat$p_val.bulk > 0.05 &\\ merge_dat$p_val.sc < 0.05)] only_bulk <- merge_dat$gene[which(merge_dat$p_val.bulk < 0.05 &\\ merge_dat$p_val.sc > 0.05)] print(paste0('# Common: ',length(common))) ``` ``` [1] \"# Common: 3519\" ``` sourceCode R print(paste0('# Only in single-cell: ',length(only_sc))) ``` [1] \"# Only in single-cell: 1649\" ``` sourceCode R print(paste0('# Only in bulk: ',length(only_bulk))) ``` [1] \"# Only in bulk: 204\" ``` We can see that while the p-values are correlated between the single-cell and pseudobulk data, the single-cell p-values are often smaller and suggest higher levels of significance. In particular, there are 3,519 genes with evidence of differential expression (prior to multiple hypothesis testing) in both analyses, 1,649 genes that only appear to be differentially expressed in the single-cell analysis, and just 204 genes that only appear to be differentially expressed in the bulk analysis. We can investigate these discrepancies using VlnPlot . First, we can examine the top genes that are differentially expressed in both analyses. ```sourceCode R create a new column to annotate sample-condition-celltype in the single-cell dataset ifnb$donor_id.stim <- paste0(ifnb$stim, \"-\", ifnb$donor_id) generate violin plot Idents(ifnb) <- \"celltype.stim\" print(merge_dat[merge_dat$gene%in%common[1:2],c('gene','p_val.sc','p_val.bulk')]) ``` ``` gene p_val.sc p_val.bulk 2785 IL1RN 0 3.701542e-275 2739 IFITM2 0 1.955626e-250 ``` sourceCode R VlnPlot(ifnb, features = common[1:2], idents = c(\"CD14 Mono_CTRL\", \"CD14 Mono_STIM\"), group.by = \"stim\") sourceCode R VlnPlot(ifnb, features = common[1:2], idents = c(\"CD14 Mono_CTRL\", \"CD14 Mono_STIM\"), group.by = \"donor_id.stim\", ncol = 1) In both the pseudobulk and single-cell analyses, the p-values for these two genes are astronomically small. For both of these genes, when just comparing all stimulated CD4 monocytes to all control CD4 monocytes across samples, we see much higher expression in the stimulated cells. When breaking down these cells by sample, we continue to see consistently higher expression levels in the stimulated samples compared to the control samples; in other words, this finding is not driven by just one or two samples. Because of this consistency, we find this signal in both analyses. By contrast, we can examine examples of genes that are only DE under the single-cell analysis. sourceCode R print(merge_dat[merge_dat$gene%in%c('SRGN','HLA-DRA'),c('gene','p_val.sc','p_val.bulk')]) ``` gene p_val.sc p_val.bulk 5710 SRGN 4.025076e-21 0.1823188 2603 HLA-DRA 4.989863e-09 0.1851302 ``` sourceCode R VlnPlot(ifnb, features <- c('SRGN','HLA-DRA'), idents = c(\"CD14 Mono_CTRL\", \"CD14 Mono_STIM\"), group.by = \"stim\") sourceCode R VlnPlot(ifnb, features <- c('SRGN','HLA-DRA'), idents = c(\"CD14 Mono_CTRL\", \"CD14 Mono_STIM\"), group.by = \"donor_id.stim\", ncol = 1) Here, SRGN and HLA-DRA both have very small p-values in the single-cell analysis (on the orders of 10−2110−21 and 10−910−9), but much larger p-values around 0.18 in the pseudobulk analysis. While there appears to be a difference between control and simulated cells when ignoring sample information, the signal is much weaker on the sample level, and we can see notable variability from sample to sample. Perform DE analysis using alternative tests anchor Finally, we also support many other DE tests using other methods. For completeness, the following tests are currently supported: “wilcox” : Wilcoxon rank sum test (default, using ‘ presto ’ package) “wilcox_limma” : Wilcoxon rank sum test (using ‘ limma ’ package) “bimod” : Likelihood-ratio test for single cell feature expression, (McDavid et al., Bioinformatics, 2013) “roc” : Standard AUC classifier “t” : Student’s t-test “poisson” : Likelihood ratio test assuming an underlying negative binomial distribution. Use only for UMI-based datasets “negbinom” : Likelihood ratio test assuming an underlying negative binomial distribution. Use only for UMI-based datasets “LR” : Uses a logistic regression framework to determine differentially expressed genes. Constructs a logistic regression model predicting group membership based on each feature individually and compares this to a null model with a likelihood ratio test. “MAST” : GLM-framework that treates cellular detection rate as a covariate (Finak et al, Genome Biology, 2015) (Installation instructions) “DESeq2” : DE based on a model using the negative binomial distribution (Love et al, Genome Biology, 2014) (Installation instructions) For MAST and DESeq2, please ensure that these packages are installed separately in order to use them as part of Seurat. Once installed, use the test.use parameter can be used to specify which DE test to use. ```sourceCode R Test for DE features using the MAST package Idents(ifnb) <- \"seurat_annotations\" head(FindMarkers(ifnb, ident.1 = \"CD14 Mono\", ident.2 = \"CD16 Mono\", test.use = \"MAST\")) ```",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/de_vignette",
      "title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat • Seurat",
      "ogTitle": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "language": "en",
      "og:title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "scrapeId": "c1900536-aff6-42ff-8423-36dbd4645584",
      "viewport": "width=device-width, initial-scale=1.0",
      "sourceURL": "https://satijalab.org/seurat/articles/de_vignette",
      "statusCode": 200,
      "ogDescription": "Seurat",
      "og:description": "Seurat"
    }
  },
  {
    "processed_text": "",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/seurat5_integration_mapping.html",
      "error": "Not Found",
      "scrapeId": "c44bde47-fd03-4313-9776-1f880957c20e",
      "sourceURL": "https://satijalab.org/seurat/articles/seurat5_integration_mapping.html",
      "statusCode": 404
    }
  },
  {
    "processed_text": "",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/get_started_v5.html",
      "error": "Not Found",
      "scrapeId": "cd6ee728-4c30-4557-9a52-85a63f945587",
      "sourceURL": "https://satijalab.org/seurat/articles/get_started_v5.html",
      "statusCode": 404
    }
  },
  {
    "processed_text": "Changes in Seurat v4 Source: vignettes/v4_changes.Rmd v4_changes.Rmd Changes in Seurat v4 anchor We have made minor changes in v4, primarily to improve the performance of Seurat v4 on large datasets. This includes minor changes to default parameter settings, and the use of newly available packages for tasks such as the identification of k-nearest neighbors, and graph-based clustering. These changes do not adversely impact downstream results, and we provide a detailed description of key changes below. Users who wish to continue using Seurat v3, or those interested in reproducing results produced by previous versions, may continue to install previous versions here . Changes to parameter defaults anchor FindNeighbors anchor The default method for identifying k-nearest neighbors has been set to annoy . This is an approximate nearest-neighbor approach that is widely used for high-dimensional analysis in many fields, including single-cell analysis. Extensive community benchmarking has shown that annoy substantially improves the speed and memory requirements of neighbor discovery, with negligible impact to downstream results, and is consistent with our analysis and testing. Users may switch back to using the previous default setting using nn.method=\"rann\" . FindMarkers anchor We have restructured the code of the FindMarkers() function to be easier to understand, interpret, and debug. The results of differential expression are unchanged. However, by default we now prefilter genes and report fold change using base 2, as is commonly done in other differential expression packages, instead of natural log. If the default option is set, the output of FindMarkers() will include the column avg_log2FC, instead of avg_logFC. Users can restore the previous behavior (natural log), by specifying base = exp(1) . IntegrateData/TransferData anchor We have made minor changes to the exact calculation of the anchor weight matrix, for example, in cases where a query cell participates in multiple anchor pairs. These changes reflect an improved workflow, but do not result in meaningful differences for downstream analysis (for example, see you can compare the results of our integration vignettes using Seurat v3 and Seurat v4 . SCTransform anchor In SCTransform() , we slightly modify default parameters to improve scalability of parameter estimation for large datasets. For example, when estimating the regularized relationship between mu and theta, we compute this on a subset of the data by setting the ncells parameter to 5,000. The vst() function in sctransform v0.3 (available on CRAN here ) also introduces minor changes to the process of regularization. We have tested these changes extensively and found a substantial improvement in speed and memory, particularly for large dataset, with no adverse impact to performance. User can compare the results of the SCTransform vignette computed using Seurat v3 and Seurat v4 , or set ncells=NULL on larger datasets to compare results. Removed functions anchor The following functions have been removed in Seurat v4: CreateGeneActivityMatrix replaced by GeneActivity in Signac RunLSI replaced by RunTFIDF and RunSVD in Signac ReadAlevin and ReadAlevinCsv moved to SeuratWrappers , see details here ExportToCellbrowser and StopCellbrowser moved to SeuratWrappers , see details here",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/v4_changes",
      "title": "Changes in Seurat v4 • Seurat",
      "ogTitle": "Changes in Seurat v4",
      "language": "en",
      "og:title": "Changes in Seurat v4",
      "scrapeId": "d18d1a58-4579-42cc-8ea6-0335267b2ca6",
      "viewport": "width=device-width, initial-scale=1.0",
      "sourceURL": "https://satijalab.org/seurat/articles/v4_changes",
      "statusCode": 200,
      "ogDescription": "Seurat",
      "og:description": "Seurat"
    }
  },
  {
    "processed_text": "",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/articles/sctransform_vignette.html",
      "error": "Not Found",
      "scrapeId": "36b7e25d-2bfb-46f1-a731-04038008434b",
      "sourceURL": "https://satijalab.org/seurat/articles/articles/sctransform_vignette.html",
      "statusCode": 404
    }
  },
  {
    "processed_text": "",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/future_vignette.html",
      "error": "Not Found",
      "scrapeId": "b32faebd-cab5-4694-83d1-4701a5251b3b",
      "sourceURL": "https://satijalab.org/seurat/articles/future_vignette.html",
      "statusCode": 404
    }
  },
  {
    "processed_text": "Mapping and annotating query datasets Compiled: 2023-10-31 Source: vignettes/integration_mapping.Rmd integration_mapping.Rmd Introduction to single-cell reference mapping anchor In this vignette, we first build an integrated reference and then demonstrate how to leverage this reference to annotate new query datasets. Generating an integrated reference follows the same workflow described in more detail in the integration introduction vignette . Once generated, this reference can be used to analyze additional query datasets through tasks like cell type label transfer and projecting query cells onto reference UMAPs. Notably, this does not require correction of the underlying raw query data and can therefore be an efficient strategy if a high quality reference is available. Dataset preprocessing anchor For the purposes of this example, we’ve chosen human pancreatic islet cell datasets produced across four technologies, CelSeq (GSE81076) CelSeq2 (GSE85241), Fluidigm C1 (GSE86469), and SMART-Seq2 (E-MTAB-5061). For convenience, we distribute this dataset through our SeuratData package. The metadata contains the technology ( tech column) and cell type annotations ( celltype column) for each cell in the four datasets. sourceCode R library(Seurat) library(SeuratData) library(ggplot2) sourceCode R InstallData(\"panc8\") As a demonstration, we will use a subset of technologies to construct a reference. We will then map the remaining datasets onto this reference. We start by selecting cells from four technologies, and performing an analysis without integration. sourceCode R panc8 <- LoadData(\"panc8\") table(panc8$tech) ``` celseq celseq2 fluidigmc1 indrop smartseq2 1004 2285 638 8569 2394 ``` ```sourceCode R we will use data from 2 technologies for the reference pancreas.ref <- subset(panc8, tech %in% c(\"celseq2\", \"smartseq2\")) pancreas.ref[[\"RNA\"]] <- split(pancreas.ref[[\"RNA\"]], f = pancreas.ref$tech) pre-process dataset (without integration) pancreas.ref <- NormalizeData(pancreas.ref) pancreas.ref <- FindVariableFeatures(pancreas.ref) pancreas.ref <- ScaleData(pancreas.ref) pancreas.ref <- RunPCA(pancreas.ref) pancreas.ref <- FindNeighbors(pancreas.ref, dims = 1:30) pancreas.ref <- FindClusters(pancreas.ref) ``` ``` Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck Number of nodes: 4679 Number of edges: 174953 Running Louvain algorithm... Maximum modularity in 10 random starts: 0.9180 Number of communities: 19 Elapsed time: 0 seconds ``` sourceCode R pancreas.ref <- RunUMAP(pancreas.ref, dims = 1:30) DimPlot(pancreas.ref, group.by = c(\"celltytpe\", \"tech\")) Next, we integrate the datasets into a shared reference. Please see our introduction to integration vignette sourceCode R pancreas.ref <- IntegrateLayers(object = pancreas.ref, method = CCAIntegration, orig.reduction = \"pca\", new.reduction = \"integrated.cca\", verbose = FALSE) pancreas.ref <- FindNeighbors(pancreas.ref, reduction = \"integrated.cca\", dims = 1:30) pancreas.ref <- FindClusters(pancreas.ref) ``` Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck Number of nodes: 4679 Number of edges: 190152 Running Louvain algorithm... Maximum modularity in 10 random starts: 0.8680 Number of communities: 15 Elapsed time: 0 seconds ``` sourceCode R pancreas.ref <- RunUMAP(pancreas.ref, reduction = \"integrated.cca\", dims = 1:30) DimPlot(pancreas.ref, group.by = c(\"tech\", \"celltype\")) Cell type classification using an integrated reference anchor Seurat also supports the projection of reference data (or meta data) onto a query object. While many of the methods are conserved (both procedures begin by identifying anchors), there are two important distinctions between data transfer and integration: In data transfer, Seurat does not correct or modify the query expression data. In data transfer, Seurat has an option (set by default) to project the PCA structure of a reference onto the query, instead of learning a joint structure with CCA. We generally suggest using this option when projecting data between scRNA-seq datasets. After finding anchors, we use the TransferData() function to classify the query cells based on reference data (a vector of reference cell type labels). TransferData() returns a matrix with predicted IDs and prediction scores, which we can add to the query metadata. ```sourceCode R select two technologies for the query datasets pancreas.query <- subset(panc8, tech %in% c(\"fluidigmc1\", \"celseq\")) pancreas.query <- NormalizeData(pancreas.query) pancreas.anchors <- FindTransferAnchors(reference = pancreas.ref, query = pancreas.query, dims = 1:30, reference.reduction = \"pca\") predictions <- TransferData(anchorset = pancreas.anchors, refdata = pancreas.ref$celltype, dims = 1:30) pancreas.query <- AddMetaData(pancreas.query, metadata = predictions) ``` Because we have the original label annotations from our full integrated analysis, we can evaluate how well our predicted cell type annotations match the full reference. In this example, we find that there is a high agreement in cell type classification, with over 96% of cells being labeled correctly. sourceCode R pancreas.query$prediction.match <- pancreas.query$predicted.id == pancreas.query$celltype table(pancreas.query$prediction.match) ``` FALSE TRUE 63 1579 ``` To verify this further, we can examine some canonical cell type markers for specific pancreatic islet cell populations. Note that even though some of these cell types are only represented by one or two cells (e.g. epsilon cells), we are still able to classify them correctly. sourceCode R table(pancreas.query$predicted.id) ``` acinar activated_stellate alpha beta 262 39 436 419 delta ductal endothelial gamma 73 330 19 41 macrophage mast schwann 15 2 6 ``` sourceCode R VlnPlot(pancreas.query, c(\"REG1A\", \"PPY\", \"SST\", \"GHRL\", \"VWF\", \"SOX10\"), group.by = \"predicted.id\") Unimodal UMAP Projection anchor We also enable projection of a query onto the reference UMAP structure. This can be achieved by computing the reference UMAP model and then calling MapQuery() instead of TransferData() . sourceCode R pancreas.ref <- RunUMAP(pancreas.ref, dims = 1:30, reduction = \"integrated.cca\", return.model = TRUE) pancreas.query <- MapQuery(anchorset = pancreas.anchors, reference = pancreas.ref, query = pancreas.query, refdata = list(celltype = \"celltype\"), reference.reduction = \"pca\", reduction.model = \"umap\") What is MapQuery doing? MapQuery() is a wrapper around three functions: TransferData() , IntegrateEmbeddings() , and ProjectUMAP() . TransferData() is used to transfer cell type labels and impute the ADT values; IntegrateEmbeddings() is used to integrate reference with query by correcting the query’s projected low-dimensional embeddings; and finally ProjectUMAP() is used to project the query data onto the UMAP structure of the reference. The equivalent code for doing this with the intermediate functions is below: sourceCode R pancreas.query <- TransferData(anchorset = pancreas.anchors, reference = pancreas.ref, query = pancreas.query, refdata = list(celltype = \"celltype\")) pancreas.query <- IntegrateEmbeddings(anchorset = pancreas.anchors, reference = pancreas.ref, query = pancreas.query, new.reduction.name = \"ref.pca\") pancreas.query <- ProjectUMAP(query = pancreas.query, query.reduction = \"ref.pca\", reference = pancreas.ref, reference.reduction = \"pca\", reduction.model = \"umap\") We can now visualize the query cells alongside our reference. sourceCode R p1 <- DimPlot(pancreas.ref, reduction = \"umap\", group.by = \"celltype\", label = TRUE, label.size = 3, repel = TRUE) + NoLegend() + ggtitle(\"Reference annotations\") p2 <- DimPlot(pancreas.query, reduction = \"ref.umap\", group.by = \"predicted.celltype\", label = TRUE, label.size = 3, repel = TRUE) + NoLegend() + ggtitle(\"Query transferred labels\") p1 + p2 Session Info sourceCode R sessionInfo() ``` R version 4.2.2 Patched (2022-11-10 r83330) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.6 LTS Matrix products: default BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats graphics grDevices utils datasets methods base other attached packages: [1] ggplot2_3.4.4 thp1.eccite.SeuratData_3.1.5 [3] stxBrain.SeuratData_0.1.1 ssHippo.SeuratData_3.1.4 [5] pbmcsca.SeuratData_3.0.0 pbmcref.SeuratData_1.0.0 [7] pbmcMultiome.SeuratData_0.1.4 pbmc3k.SeuratData_3.1.4 [9] panc8.SeuratData_3.0.2 ifnb.SeuratData_3.0.0 [11] hcabm40k.SeuratData_3.0.0 cbmc.SeuratData_3.1.4 [13] bmcite.SeuratData_0.3.0 SeuratData_0.2.2.9001 [15] Seurat_5.0.0 SeuratObject_5.0.0 [17] sp_2.1-1 loaded via a namespace (and not attached): [1] spam_2.10-0 systemfonts_1.0.4 plyr_1.8.9 [4] igraph_1.5.1 lazyeval_0.2.2 splines_4.2.2 [7] RcppHNSW_0.5.0 listenv_0.9.0 scattermore_1.2 [10] digest_0.6.33 htmltools_0.5.6.1 fansi_1.0.5 [13] magrittr_2.0.3 memoise_2.0.1 tensor_1.5 [16] cluster_2.1.4 ROCR_1.0-11 globals_0.16.2 [19] matrixStats_1.0.0 pkgdown_2.0.7 spatstat.sparse_3.0-3 [22] colorspace_2.1-0 rappdirs_0.3.3 ggrepel_0.9.4 [25] textshaping_0.3.6 xfun_0.40 dplyr_1.1.3 [28] crayon_1.5.2 jsonlite_1.8.7 progressr_0.14.0 [31] spatstat.data_3.0-3 survival_3.5-7 zoo_1.8-12 [34] glue_1.6.2 polyclip_1.10-6 gtable_0.3.4 [37] leiden_0.4.3 future.apply_1.11.0 abind_1.4-5 [40] scales_1.2.1 spatstat.random_3.2-1 miniUI_0.1.1.1 [43] Rcpp_1.0.11 viridisLite_0.4.2 xtable_1.8-4 [46] reticulate_1.34.0 dotCall64_1.1-0 htmlwidgets_1.6.2 [49] httr_1.4.7 RColorBrewer_1.1-3 ellipsis_0.3.2 [52] ica_1.0-3 farver_2.1.1 pkgconfig_2.0.3 [55] sass_0.4.7 uwot_0.1.16 deldir_1.0-9 [58] utf8_1.2.4 labeling_0.4.3 tidyselect_1.2.0 [61] rlang_1.1.1 reshape2_1.4.4 later_1.3.1 [64] munsell_0.5.0 tools_4.2.2 cachem_1.0.8 [67] cli_3.6.1 generics_0.1.3 ggridges_0.5.4 [70] evaluate_0.22 stringr_1.5.0 fastmap_1.1.1 [73] yaml_2.3.7 ragg_1.2.5 goftest_1.2-3 [76] knitr_1.45 fs_1.6.3 fitdistrplus_1.1-11 [79] purrr_1.0.2 RANN_2.6.1 pbapply_1.7-2 [82] future_1.33.0 nlme_3.1-162 mime_0.12 [85] formatR_1.14 ggrastr_1.0.1 compiler_4.2.2 [88] beeswarm_0.4.0 plotly_4.10.3 png_0.1-8 [91] spatstat.utils_3.0-4 tibble_3.2.1 bslib_0.5.1 [94] stringi_1.7.12 highr_0.10 desc_1.4.2 [97] RSpectra_0.16-1 lattice_0.21-9 Matrix_1.6-1.1 [100] vctrs_0.6.4 pillar_1.9.0 lifecycle_1.0.3 [103] spatstat.geom_3.2-7 lmtest_0.9-40 jquerylib_0.1.4 [106] RcppAnnoy_0.0.21 data.table_1.14.8 cowplot_1.1.1 [109] irlba_2.3.5.1 httpuv_1.6.12 patchwork_1.1.3 [112] R6_2.5.1 promises_1.2.1 KernSmooth_2.23-22 [115] gridExtra_2.3 vipor_0.4.5 parallelly_1.36.0 [118] codetools_0.2-19 fastDummies_1.7.3 MASS_7.3-58.2 [121] rprojroot_2.0.3 withr_2.5.2 sctransform_0.4.1 [124] parallel_4.2.2 grid_4.2.2 tidyr_1.3.0 [127] rmarkdown_2.25 Rtsne_0.16 spatstat.explore_3.2-5 [130] shiny_1.7.5.1 ggbeeswarm_0.7.1 ```",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/integration_mapping",
      "title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat • Seurat",
      "ogTitle": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "language": "en",
      "og:title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "scrapeId": "d3120da6-f969-4738-b533-8ab00eb2c540",
      "viewport": "width=device-width, initial-scale=1.0",
      "sourceURL": "https://satijalab.org/seurat/articles/integration_mapping",
      "statusCode": 200,
      "ogDescription": "Seurat",
      "og:description": "Seurat"
    }
  },
  {
    "processed_text": "",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/articles/immune_alignment.html",
      "error": "Not Found",
      "scrapeId": "9e5b66ff-2d00-4276-9154-3f4900f414e8",
      "sourceURL": "https://satijalab.org/seurat/articles/articles/immune_alignment.html",
      "statusCode": 404
    }
  },
  {
    "processed_text": "Documentation Archive Source: vignettes/archive.Rmd archive.Rmd In version 4, the Seurat documentation was transitioned to pkgdown. Here we provide access to all previous versions of the documentation. Version 2-4 tutorials anchor PBMC scATAC-seq Vignette anchor v4.3 v3.2 v3.1 v3.0 Cell-Cycle Scoring and Regression anchor v4.3 v3.2 v3.1 v3.0 v2.4 Interoperability between single-cell object formats anchor v4.3 v4.3 v3.2 v3.1 v3.0 v2.4 Differential expression testing anchor v4.3 v3.2 v3.1 v3.0 v2.4 Seurat - Dimensional Reduction Vignette anchor v4.3 v3.2 v3.1 v3.0 v2.4 Parallelization in Seurat with future anchor v4.3 v3.2 v3.1 v3.0 Demultiplexing with hashtag oligos (HTOs) anchor v4.3 v3.2 v3.1 v3.0 v2.4 Tutorial: Integrating stimulated vs. control PBMC datasets to learn cell- type specific responses anchor v3.2 v3.1 v3.0 v2.4 Integration and Label Transfer anchor v3.2 v3.1 v3.0 Mapping and annotating query datasets anchor v4.3 Tips for integrating large datasets anchor v4.3 Fast integration using reciprocal PCA (RPCA) anchor v4.3 Seurat - Interaction Tips anchor v4.3 v3.2 v3.1 v3.0 v2.4 Guided Clustering of the Microwell-seq Mouse Cell Atlas anchor v3.2 v3.1 v3.0 v2.4 Seurat - Combining Two 10X Runs anchor v4.3 Mixscape Vignette anchor v4.3 v3.2 v3.1 Multimodal reference mapping anchor v4.3 Using Seurat with multi-modal data anchor v4.3 v3.2 v3.1 v3.0 v2.4 Guided tutorial — 2,700 PBMCs anchor v4.3 v3.2 v3.1 v3.0 v2.4 v1.4 Using sctransform in Seurat anchor v4.3 v3.2 v3.1 v3.0 SCTransform v2 anchor v4.3 Analysis, visualization, and integration of spatial datasets with Seurat anchor v4.3 v3.2 New data visualization methods in v3.0 anchor v4.3 v3.2 v3.1 v3.0 v2.4 Weighted Nearest Neighbor Analysis anchor v4.3 Version 1.3-1.4 tutorials anchor For versions 1.3-1.4, we provide access to the old documentation pages here Version <=1.2 tutorials anchor For versions <=1.2, we provide access to the old documentation pages here",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/archive",
      "title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat • Seurat",
      "ogTitle": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "language": "en",
      "og:title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "scrapeId": "d53c0875-6f5d-483e-bb50-00afffefe9a6",
      "viewport": "width=device-width, initial-scale=1.0",
      "sourceURL": "https://satijalab.org/seurat/articles/archive",
      "statusCode": 200,
      "ogDescription": "Seurat",
      "og:description": "Seurat"
    }
  },
  {
    "processed_text": "Data visualization methods in Seurat Compiled: 2023-10-31 Source: vignettes/visualization_vignette.Rmd visualization_vignette.Rmd We’ll demonstrate visualization techniques in Seurat using our previously computed Seurat object from the 2,700 PBMC tutorial. You can download this dataset from SeuratData sourceCode R SeuratData::InstallData(\"pbmc3k\") sourceCode R library(Seurat) library(SeuratData) library(ggplot2) library(patchwork) pbmc3k.final <- LoadData(\"pbmc3k\", type = \"pbmc3k.final\") pbmc3k.final$groups <- sample(c(\"group1\", \"group2\"), size = ncol(pbmc3k.final), replace = TRUE) features <- c(\"LYZ\", \"CCL5\", \"IL32\", \"PTPRCAP\", \"FCGR3A\", \"PF4\") pbmc3k.final ``` An object of class Seurat 13714 features across 2638 samples within 1 assay Active assay: RNA (13714 features, 2000 variable features) 3 layers present: data, counts, scale.data 2 dimensional reductions calculated: pca, umap ``` Five visualizations of marker feature expression anchor ```sourceCode R Ridge plots - from ggridges. Visualize single cell expression distributions in each cluster RidgePlot(pbmc3k.final, features = features, ncol = 2) ``` ```sourceCode R Violin plot - Visualize single cell expression distributions in each cluster VlnPlot(pbmc3k.final, features = features) ``` ```sourceCode R Feature plot - visualize feature expression in low-dimensional space FeaturePlot(pbmc3k.final, features = features) ``` ```sourceCode R Dot plots - the size of the dot corresponds to the percentage of cells expressing the feature in each cluster. The color represents the average expression level DotPlot(pbmc3k.final, features = features) + RotatedAxis() ``` ```sourceCode R Single cell heatmap of feature expression DoHeatmap(subset(pbmc3k.final, downsample = 100), features = features, size = 3) ``` New additions to FeaturePlot anchor ```sourceCode R Plot a legend to map colors to expression levels FeaturePlot(pbmc3k.final, features = \"MS4A1\") ``` ```sourceCode R Adjust the contrast in the plot FeaturePlot(pbmc3k.final, features = \"MS4A1\", min.cutoff = 1, max.cutoff = 3) ``` ```sourceCode R Calculate feature-specific contrast levels based on quantiles of non-zero expression. Particularly useful when plotting multiple markers FeaturePlot(pbmc3k.final, features = c(\"MS4A1\", \"PTPRCAP\"), min.cutoff = \"q10\", max.cutoff = \"q90\") ``` ```sourceCode R Visualize co-expression of two features simultaneously FeaturePlot(pbmc3k.final, features = c(\"MS4A1\", \"CD79A\"), blend = TRUE) ``` ```sourceCode R Split visualization to view expression by groups (replaces FeatureHeatmap) FeaturePlot(pbmc3k.final, features = c(\"MS4A1\", \"CD79A\"), split.by = \"groups\") ``` Updated and expanded visualization functions anchor In addition to changes to FeaturePlot() , several other plotting functions have been updated and expanded with new features and taking over the role of now-deprecated functions ```sourceCode R Violin plots can also be split on some variable. Simply add the splitting variable to object metadata and pass it to the split.by argument VlnPlot(pbmc3k.final, features = \"percent.mt\", split.by = \"groups\") ``` ```sourceCode R SplitDotPlotGG has been replaced with the split.by parameter for DotPlot DotPlot(pbmc3k.final, features = features, split.by = \"groups\") + RotatedAxis() ``` ```sourceCode R DimPlot replaces TSNEPlot, PCAPlot, etc. In addition, it will plot either 'umap', 'tsne', or 'pca' by default, in that order DimPlot(pbmc3k.final) ``` sourceCode R pbmc3k.final.no.umap <- pbmc3k.final pbmc3k.final.no.umap[[\"umap\"]] <- NULL DimPlot(pbmc3k.final.no.umap) + RotatedAxis() ```sourceCode R DoHeatmap now shows a grouping bar, splitting the heatmap into groups or clusters. This can be changed with the group.by parameter DoHeatmap(pbmc3k.final, features = VariableFeatures(pbmc3k.final)[1:100], cells = 1:500, size = 4, angle = 90) + NoLegend() ``` Applying themes to plots anchor With Seurat, all plotting functions return ggplot2-based plots by default, allowing one to easily capture and manipulate plots just like any other ggplot2-based plot. ```sourceCode R baseplot <- DimPlot(pbmc3k.final, reduction = \"umap\") Add custom labels and titles baseplot + labs(title = \"Clustering of 2,700 PBMCs\") ``` ```sourceCode R Use community-created themes, overwriting the default Seurat-applied theme Install ggmin with remotes::install_github('sjessa/ggmin') baseplot + ggmin::theme_powerpoint() ``` ```sourceCode R Seurat also provides several built-in themes, such as DarkTheme; for more details see ?SeuratTheme baseplot + DarkTheme() ``` ```sourceCode R Chain themes together baseplot + FontSize(x.title = 20, y.title = 20) + NoLegend() ``` Interactive plotting features anchor Seurat utilizes R’s plotly graphing library to create interactive plots. This interactive plotting feature works with any ggplot2-based scatter plots (requires a geom_point layer). To use, simply make a ggplot2-based scatter plot (such as DimPlot() or FeaturePlot() ) and pass the resulting plot to HoverLocator() ```sourceCode R Include additional data to display alongside cell names by passing in a data frame of information. Works well when using FetchData plot <- FeaturePlot(pbmc3k.final, features = \"MS4A1\") HoverLocator(plot = plot, information = FetchData(pbmc3k.final, vars = c(\"ident\", \"PC_1\", \"nFeature_RNA\"))) ``` −10−50510−50510 MS4A1UMAP_1UMAP_2 plotly-logomark Another interactive feature provided by Seurat is being able to manually select cells for further investigation. We have found this particularly useful for small clusters that do not always separate using unbiased clustering, but which look tantalizingly distinct. You can now select these cells by creating a ggplot2-based scatter plot (such as with DimPlot() or FeaturePlot() , and passing the returned plot to CellSelector() . CellSelector() will return a vector with the names of the points selected, so that you can then set them to a new identity class and perform differential expression. For example, let’s pretend that DCs had merged with monocytes in the clustering, but we wanted to see what was unique about them based on their position in the tSNE plot. sourceCode R pbmc3k.final <- RenameIdents(pbmc3k.final, DC = \"CD14+ Mono\") plot <- DimPlot(pbmc3k.final, reduction = \"umap\") select.cells <- CellSelector(plot = plot) We can then change the identity of these cells to turn them into their own mini-cluster. sourceCode R head(select.cells) ``` [1] \"AAGATTACCGCCTT\" \"AAGCCATGAACTGC\" \"AATTACGAATTCCT\" \"ACCCGTTGCTTCTA\" [5] \"ACGAGGGACAGGAG\" \"ACGTGATGCCATGA\" ``` ```sourceCode R Idents(pbmc3k.final, cells = select.cells) <- \"NewCells\" Now, we find markers that are specific to the new cells, and find clear DC markers newcells.markers <- FindMarkers(pbmc3k.final, ident.1 = \"NewCells\", ident.2 = \"CD14+ Mono\", min.diff.pct = 0.3, only.pos = TRUE) head(newcells.markers) ``` ``` p_val avg_log2FC pct.1 pct.2 p_val_adj FCER1A 3.239004e-69 6.504163 0.800 0.017 4.441970e-65 SERPINF1 7.761413e-36 5.456560 0.457 0.013 1.064400e-31 HLA-DQB2 1.721094e-34 4.752397 0.429 0.010 2.360309e-30 CD1C 2.304106e-33 4.929607 0.514 0.025 3.159851e-29 ENHO 5.099765e-32 5.076634 0.400 0.010 6.993818e-28 ITM2C 4.299994e-29 5.660234 0.371 0.010 5.897012e-25 ``` Using CellSelector to Automatically Assign Cell Identities In addition to returning a vector of cell names, CellSelector() can also take the selected cells and assign a new identity to them, returning a Seurat object with the identity classes already set. This is done by passing the Seurat object used to make the plot into CellSelector() , as well as an identity class. As an example, we’re going to select the same set of cells as before, and set their identity class to “selected” sourceCode R pbmc3k.final <- CellSelector(plot = plot, object = pbmc3k.final, ident = \"selected\") sourceCode R levels(pbmc3k.final) ``` [1] \"selected\" \"Naive CD4 T\" \"Memory CD4 T\" \"CD14+ Mono\" \"B\" [6] \"CD8 T\" \"FCGR3A+ Mono\" \"NK\" \"Platelet\" ``` Plotting Accessories anchor Along with new functions add interactive functionality to plots, Seurat provides new accessory functions for manipulating and combining plots. ```sourceCode R LabelClusters and LabelPoints will label clusters (a coloring variable) or individual points on a ggplot2-based scatter plot plot <- DimPlot(pbmc3k.final, reduction = \"pca\") + NoLegend() LabelClusters(plot = plot, id = \"ident\") ``` ```sourceCode R Both functions support repel , which will intelligently stagger labels and draw connecting lines from the labels to the points or clusters LabelPoints(plot = plot, points = TopCells(object = pbmc3k.final[[\"pca\"]]), repel = TRUE) ``` Plotting multiple plots was previously achieved with the CombinePlot() function. We are deprecating this functionality in favor of the patchwork system. Below is a brief demonstration but please see the patchwork package website here for more details and examples. ```sourceCode R plot1 <- DimPlot(pbmc3k.final) Create scatter plot with the Pearson correlation value as the title plot2 <- FeatureScatter(pbmc3k.final, feature1 = \"LYZ\", feature2 = \"CCL5\") Combine two plots plot1 + plot2 ``` ```sourceCode R Remove the legend from all plots (plot1 + plot2) & NoLegend() ``` Session Info sourceCode R sessionInfo() ``` R version 4.2.2 Patched (2022-11-10 r83330) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.6 LTS Matrix products: default BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats graphics grDevices utils datasets methods base other attached packages: [1] patchwork_1.1.3 ggplot2_3.4.4 [3] thp1.eccite.SeuratData_3.1.5 stxBrain.SeuratData_0.1.1 [5] ssHippo.SeuratData_3.1.4 pbmcsca.SeuratData_3.0.0 [7] pbmcref.SeuratData_1.0.0 pbmcMultiome.SeuratData_0.1.4 [9] pbmc3k.SeuratData_3.1.4 panc8.SeuratData_3.0.2 [11] ifnb.SeuratData_3.0.0 hcabm40k.SeuratData_3.0.0 [13] cbmc.SeuratData_3.1.4 bmcite.SeuratData_0.3.0 [15] SeuratData_0.2.2.9001 Seurat_5.0.0 [17] SeuratObject_5.0.0 sp_2.1-1 loaded via a namespace (and not attached): [1] spam_2.10-0 systemfonts_1.0.4 plyr_1.8.9 [4] igraph_1.5.1 lazyeval_0.2.2 splines_4.2.2 [7] RcppHNSW_0.5.0 crosstalk_1.2.0 listenv_0.9.0 [10] scattermore_1.2 digest_0.6.33 htmltools_0.5.6.1 [13] fansi_1.0.5 magrittr_2.0.3 memoise_2.0.1 [16] tensor_1.5 cluster_2.1.4 ROCR_1.0-11 [19] limma_3.54.1 globals_0.16.2 matrixStats_1.0.0 [22] pkgdown_2.0.7 spatstat.sparse_3.0-3 colorspace_2.1-0 [25] rappdirs_0.3.3 ggrepel_0.9.4 textshaping_0.3.6 [28] xfun_0.40 dplyr_1.1.3 crayon_1.5.2 [31] jsonlite_1.8.7 progressr_0.14.0 spatstat.data_3.0-3 [34] survival_3.5-7 zoo_1.8-12 glue_1.6.2 [37] polyclip_1.10-6 gtable_0.3.4 leiden_0.4.3 [40] future.apply_1.11.0 abind_1.4-5 scales_1.2.1 [43] spatstat.random_3.2-1 miniUI_0.1.1.1 Rcpp_1.0.11 [46] viridisLite_0.4.2 xtable_1.8-4 reticulate_1.34.0 [49] dotCall64_1.1-0 ggmin_0.0.0.9000 htmlwidgets_1.6.2 [52] httr_1.4.7 RColorBrewer_1.1-3 ellipsis_0.3.2 [55] ica_1.0-3 farver_2.1.1 pkgconfig_2.0.3 [58] sass_0.4.7 uwot_0.1.16 deldir_1.0-9 [61] utf8_1.2.4 labeling_0.4.3 tidyselect_1.2.0 [64] rlang_1.1.1 reshape2_1.4.4 later_1.3.1 [67] munsell_0.5.0 tools_4.2.2 cachem_1.0.8 [70] cli_3.6.1 generics_0.1.3 ggridges_0.5.4 [73] evaluate_0.22 stringr_1.5.0 fastmap_1.1.1 [76] yaml_2.3.7 ragg_1.2.5 goftest_1.2-3 [79] knitr_1.45 fs_1.6.3 fitdistrplus_1.1-11 [82] purrr_1.0.2 RANN_2.6.1 pbapply_1.7-2 [85] future_1.33.0 nlme_3.1-162 mime_0.12 [88] formatR_1.14 ggrastr_1.0.1 compiler_4.2.2 [91] beeswarm_0.4.0 plotly_4.10.3 png_0.1-8 [94] spatstat.utils_3.0-4 tibble_3.2.1 bslib_0.5.1 [97] stringi_1.7.12 highr_0.10 desc_1.4.2 [100] RSpectra_0.16-1 lattice_0.21-9 Matrix_1.6-1.1 [103] vctrs_0.6.4 pillar_1.9.0 lifecycle_1.0.3 [106] spatstat.geom_3.2-7 lmtest_0.9-40 jquerylib_0.1.4 [109] RcppAnnoy_0.0.21 data.table_1.14.8 cowplot_1.1.1 [112] irlba_2.3.5.1 httpuv_1.6.12 R6_2.5.1 [115] promises_1.2.1 KernSmooth_2.23-22 gridExtra_2.3 [118] vipor_0.4.5 parallelly_1.36.0 codetools_0.2-19 [121] fastDummies_1.7.3 MASS_7.3-58.2 rprojroot_2.0.3 [124] withr_2.5.2 presto_1.0.0 sctransform_0.4.1 [127] parallel_4.2.2 grid_4.2.2 tidyr_1.3.0 [130] rmarkdown_2.25 Rtsne_0.16 spatstat.explore_3.2-5 [133] shiny_1.7.5.1 ggbeeswarm_0.7.1 ```",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/visualization_vignette",
      "title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat • Seurat",
      "ogTitle": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "language": "en",
      "og:title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "scrapeId": "df99488e-29dd-4b2e-be7b-a6ca53ed2f77",
      "viewport": "width=device-width, initial-scale=1.0",
      "sourceURL": "https://satijalab.org/seurat/articles/visualization_vignette",
      "statusCode": 200,
      "ogDescription": "Seurat",
      "og:description": "Seurat"
    }
  },
  {
    "processed_text": "",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/seurat5_interaction_vignette.html",
      "error": "Not Found",
      "scrapeId": "e02f7f01-cd13-41eb-b29d-37eab6fba357",
      "sourceURL": "https://satijalab.org/seurat/articles/seurat5_interaction_vignette.html",
      "statusCode": 404
    }
  },
  {
    "processed_text": "",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/seurat5_sctransform_vignette.html",
      "error": "Not Found",
      "scrapeId": "e0c77734-1e91-4189-b592-09e4afcbc7d2",
      "sourceURL": "https://satijalab.org/seurat/articles/seurat5_sctransform_vignette.html",
      "statusCode": 404
    }
  },
  {
    "processed_text": "Multimodal reference mapping Compiled: October 31, 2023 Source: vignettes/multimodal_reference_mapping.Rmd multimodal_reference_mapping.Rmd Intro: Seurat v4 Reference Mapping anchor This vignette introduces the process of mapping query datasets to annotated references in Seurat. In this example, we map one of the first scRNA-seq datasets released by 10X Genomics of 2,700 PBMC to our recently described CITE-seq reference of 162,000 PBMC measured with 228 antibodies . We chose this example to demonstrate how supervised analysis guided by a reference dataset can help to enumerate cell states that would be challenging to find with unsupervised analysis . In a second example, we demonstrate how to serially map Human Cell Atlas datasets of human BMNC profiled from different individuals onto a consistent reference. We have previously demonstrated how to use reference-mapping approach to annotate cell labels in a query dataset . In Seurat v4, we have substantially improved the speed and memory requirements for integrative tasks including reference mapping, and also include new functionality to project query cells onto a previously computed UMAP visualization. In this vignette, we demonstrate how to use a previously established reference to interpret an scRNA-seq query: Annotate each query cell based on a set of reference-defined cell states Project each query cell onto a previously computed UMAP visualization Impute the predicted levels of surface proteins that were measured in the CITE-seq reference To run this vignette please install Seurat v4, available on CRAN. Additionally, you will need to install the SeuratDisk package. sourceCode R library(Seurat) library(ggplot2) library(patchwork) sourceCode R options(SeuratData.repo.use = \"http://seurat.nygenome.org\") Example 1: Mapping human peripheral blood cells anchor A Multimodal PBMC Reference Dataset anchor We load the reference from our recent paper , and visualize the pre-computed UMAP. sourceCode R reference <- readRDS(\"/brahms/hartmana/vignette_data/pbmc_multimodal_2023.rds\") sourceCode R DimPlot(object = reference, reduction = \"wnn.umap\", group.by = \"celltype.l2\", label = TRUE, label.size = 3, repel = TRUE) + NoLegend() Mapping anchor To demonstrate mapping to this multimodal reference, we will use a dataset of 2,700 PBMCs generated by 10x Genomics and available via SeuratData . ```sourceCode R library(SeuratData) InstallData('pbmc3k') pbmc3k <- LoadData('pbmc3k') pbmc3k <- UpdateSeuratObject(pbmc3k) ``` The reference was normalized using SCTransform() , so we use the same approach to normalize the query here. sourceCode R pbmc3k <- SCTransform(pbmc3k, verbose = FALSE) We then find anchors between reference and query. As described in the manuscript , we used a precomputed supervised PCA (spca) transformation for this example. We recommend the use of supervised PCA for CITE-seq datasets, and demonstrate how to compute this transformation on the next tab of this vignette. However, you can also use a standard PCA transformation. sourceCode R anchors <- FindTransferAnchors( reference = reference, query = pbmc3k, normalization.method = \"SCT\", reference.reduction = \"spca\", dims = 1:50 ) We then transfer cell type labels and protein data from the reference to the query. Additionally, we project the query data onto the UMAP structure of the reference. sourceCode R pbmc3k <- MapQuery( anchorset = anchors, query = pbmc3k, reference = reference, refdata = list( celltype.l1 = \"celltype.l1\", celltype.l2 = \"celltype.l2\", predicted_ADT = \"ADT\" ), reference.reduction = \"spca\", reduction.model = \"wnn.umap\" ) What is MapQuery doing? MapQuery() is a wrapper around three functions: TransferData() , IntegrateEmbeddings() , and ProjectUMAP() . TransferData() is used to transfer cell type labels and impute the ADT values. IntegrateEmbeddings() and ProjectUMAP() are used to project the query data onto the UMAP structure of the reference. The equivalent code for doing this with the intermediate functions is below: sourceCode R pbmc3k <- TransferData( anchorset = anchors, reference = reference, query = pbmc3k, refdata = list( celltype.l1 = \"celltype.l1\", celltype.l2 = \"celltype.l2\", predicted_ADT = \"ADT\") ) pbmc3k <- IntegrateEmbeddings( anchorset = anchors, reference = reference, query = pbmc3k, new.reduction.name = \"ref.spca\" ) pbmc3k <- ProjectUMAP( query = pbmc3k, query.reduction = \"ref.spca\", reference = reference, reference.reduction = \"spca\", reduction.model = \"wnn.umap\" ) Explore the mapping results anchor We can now visualize the 2,700 query cells. They have been projected into a UMAP visualization defined by the reference, and each has received annotations at two levels of granularity (level 1, and level 2). sourceCode R p1 = DimPlot(pbmc3k, reduction = \"ref.umap\", group.by = \"predicted.celltype.l1\", label = TRUE, label.size = 3, repel = TRUE) + NoLegend() p2 = DimPlot(pbmc3k, reduction = \"ref.umap\", group.by = \"predicted.celltype.l2\", label = TRUE, label.size = 3 ,repel = TRUE) + NoLegend() p1 + p2 The reference-mapped dataset helps us identify cell types that were previously blended in an unsupervised analysis of the query dataset . Just a few examples include plasmacytoid dendritic cells (pDC), hematopoietic stem and progenitor cells (HSPC), regulatory T cells (Treg), CD8 Naive T cells, cells, CD56+ NK cells, memory, and naive B cells, and plasmablasts. Each prediction is assigned a score between 0 and 1. sourceCode R FeaturePlot(pbmc3k, features = c(\"pDC\", \"CD16 Mono\", \"Treg\"), reduction = \"ref.umap\", cols = c(\"lightgrey\", \"darkred\"), ncol = 3) & theme(plot.title = element_text(size = 10)) sourceCode R library(ggplot2) plot <- FeaturePlot(pbmc3k, features = \"CD16 Mono\", reduction = \"ref.umap\", cols = c(\"lightgrey\", \"darkred\")) + ggtitle(\"CD16 Mono\") + theme(plot.title = element_text(hjust = 0.5, size = 30)) + labs(color = \"Prediction Score\") + xlab(\"UMAP 1\") + ylab(\"UMAP 2\") + theme(axis.title = element_text(size = 18), legend.text = element_text(size = 18), legend.title = element_text(size = 25)) ggsave(filename = \"../output/images/multimodal_reference_mapping.jpg\", height = 7, width = 12, plot = plot, quality = 50) We can verify our predictions by exploring the expression of canonical marker genes. For example, CLEC4C and LIRA4 have been reported as markers of pDC identity, consistent with our predictions. Similarly, if we perform differential expression to identify markers of Tregs, we identify a set of canonical markers including RTKN2, CTLA4, FOXP3, and IL2RA. sourceCode R Idents(pbmc3k) <- 'predicted.celltype.l2' VlnPlot(pbmc3k, features = c(\"CLEC4C\", \"LILRA4\"), sort = TRUE) + NoLegend() sourceCode R treg_markers <- FindMarkers(pbmc3k, ident.1 = \"Treg\", only.pos = TRUE, logfc.threshold = 0.1) print(head(treg_markers)) ``` p_val avg_log2FC pct.1 pct.2 p_val_adj AC004854.4 4.795409e-26 7.800900 0.042 0.000 6.028789e-22 RP11-297N6.4 4.795409e-26 7.800900 0.042 0.000 6.028789e-22 RTKN2 4.795409e-26 7.800900 0.042 0.000 6.028789e-22 CTD-2020K17.4 4.795409e-26 7.800900 0.042 0.000 6.028789e-22 RP11-1399P15.1 2.782841e-18 4.172869 0.292 0.021 3.498588e-14 IL2RA 1.808612e-14 4.137935 0.208 0.014 2.273787e-10 ``` Finally, we can visualize the imputed levels of surface protein, which were inferred based on the CITE-seq reference. ```sourceCode R DefaultAssay(pbmc3k) <- 'predicted_ADT' see a list of proteins: rownames(pbmc3k) FeaturePlot(pbmc3k, features = c(\"CD3-1\", \"CD45RA\", \"IgD\"), reduction = \"ref.umap\", cols = c(\"lightgrey\", \"darkgreen\"), ncol = 3) ``` Computing a new UMAP visualiztion anchor In the previous examples, we visualize the query cells after mapping to the reference-derived UMAP. Keeping a consistent visualization can assist with the interpretation of new datasets. However, if there are cell states that are present in the query dataset that are not represented in the reference, they will project to the most similar cell in the reference. This is the expected behavior and functionality as established by the UMAP package, but can potentially mask the presence of new cell types in the query which may be of interest. In our manuscript , we map a query dataset containing developing and differentiated neutrophils, which are not included in our reference. We find that computing a new UMAP (‘de novo visualization’) after merging the reference and query can help to identify these populations, as demonstrated in Supplementary Figure 8. In the ‘de novo’ visualization, unique cell states in the query remain separated. In this example, the 2,700 PBMC does not contain unique cell states, but we demonstrate how to compute this visualization below. We emphasize that if users are attempting to map datasets where the underlying samples are not PBMC, or contain cell types that are not present in the reference, computing a ‘de novo’ visualization is an important step in interpreting their dataset. sourceCode R reference <- DietSeurat(reference, counts = FALSE, dimreducs = \"spca\") pbmc3k <- DietSeurat(pbmc3k, counts = FALSE, dimreducs = \"ref.spca\") ```sourceCode R merge reference and query reference$id <- 'reference' pbmc3k$id <- 'query' refquery <- merge(reference, pbmc3k) refquery[[\"spca\"]] <- merge(reference[[\"spca\"]], pbmc3k[[\"ref.spca\"]]) refquery <- RunUMAP(refquery, reduction = 'spca', dims = 1:50) DimPlot(refquery, group.by = 'id', shuffle = TRUE) ``` Example 2: Mapping human bone marrow cells anchor A Multimodal BMNC Reference Dataset anchor As a second example, we map a dataset of human bone marrow mononuclear (BMNC) cells from eight individual donors, produced by the Human Cell Atlas. As a reference, we use the CITE-seq reference of human BMNC that we analyzed using weighted-nearest neighbor analysis (WNN) . This vignette exhibits the same reference-mapping functionality as the PBMC example on the previous tab. In addition, we also demonstrate: How to construct a supervised PCA (sPCA) transformation How to serially map multiple datasets to the same reference Optimization steps to further enhance to speed of mapping ```sourceCode R Both datasets are available through SeuratData library(SeuratData) load reference data InstallData(\"bmcite\") bm <- LoadData(ds = \"bmcite\") load query data InstallData('hcabm40k') hcabm40k <- LoadData(ds = \"hcabm40k\") ``` The reference dataset contains a WNN graph , reflecting a weighted combination of the RNA and protein data in this CITE-seq experiment. We can compute a UMAP visualization based on this graph. We set return.model = TRUE , which will enable us to project query datasets onto this visualization. sourceCode R bm <- RunUMAP(bm, nn.name = \"weighted.nn\", reduction.name = \"wnn.umap\", reduction.key = \"wnnUMAP_\", return.model = TRUE) DimPlot(bm, group.by = \"celltype.l2\", reduction = \"wnn.umap\") Computing an sPCA transformation anchor As described in our manuscript , we first compute a ‘supervised’ PCA. This identifies the transformation of the transcriptome data that best encapsulates the structure of the WNN graph. This allows a weighted combination of the protein and RNA measurements to ‘supervise’ the PCA, and highlight the most relevant sources of variation. After computing this transformation, we can project it onto a query dataset. We can also compute and project a PCA projection, but recommend the use of sPCA when working with multimodal references that have been constructed with WNN analysis. The sPCA calculation is performed once, and then can be rapidly projected onto each query dataset. sourceCode R bm <- ScaleData(bm, assay = 'RNA') bm <- RunSPCA(bm, assay = 'RNA', graph = 'wsnn') Computing a cached neighbor index anchor Since we will be mapping multiple query samples to the same reference, we can cache particular steps that only involve the reference. This step is optional but will improve speed when mapping multiple samples. We compute the first 50 neighbors in the sPCA space of the reference. We store this information in the spca.annoy.neighbors object within the reference Seurat object and also cache the annoy index data structure (via cache.index = TRUE ). sourceCode R bm <- FindNeighbors( object = bm, reduction = \"spca\", dims = 1:50, graph.name = \"spca.annoy.neighbors\", k.param = 50, cache.index = TRUE, return.neighbor = TRUE, l2.norm = TRUE ) How can I save and load a cached annoy index? If you want to save and load a cached index for a Neighbor object generated with method = \"annoy\" and cache.index = TRUE , use the SaveAnnoyIndex() / LoadAnnoyIndex() functions. Importantly, this index cannot be saved normally to an RDS or RDA file, so it will not persist correctly across R session restarts or saveRDS / readRDS for the Seurat object containing it. Instead, use LoadAnnoyIndex() to add the Annoy index to the Neighbor object every time R restarts or you load the reference Seurat object from RDS. The file created by SaveAnnoyIndex() can be distributed along with a reference Seurat object, and added to the Neighbor object in the reference. sourceCode R bm[[\"spca.annoy.neighbors\"]] ``` A Neighbor object containing the 50 nearest neighbors for 30672 cells ``` sourceCode R SaveAnnoyIndex(object = bm[[\"spca.annoy.neighbors\"]], file = \"/brahms/shared/vignette-data/reftmp.idx\") bm[[\"spca.annoy.neighbors\"]] <- LoadAnnoyIndex(object = bm[[\"spca.annoy.neighbors\"]], file = \"/brahms/shared/vignette-data/reftmp.idx\") Query dataset preprocessing anchor Here we will demonstrate mapping multiple donor bone marrow samples to the multimodal bone marrow reference. These query datasets are derived from the Human Cell Atlas (HCA) Immune Cell Atlas Bone marrow dataset and are available through SeuratData. This dataset is provided as a single merged object with 8 donors. We first split the data back into 8 separate Seurat objects, one for each original donor to map individually. sourceCode R library(dplyr) library(SeuratData) InstallData('hcabm40k') hcabm40k.batches <- SplitObject(hcabm40k, split.by = \"orig.ident\") We then normalize the query in the same manner as the reference. Here, the reference was normalized using log-normalization via NormalizeData() . If the reference had been normalized using SCTransform() , the query must be normalized with SCTransform() as well. sourceCode R hcabm40k.batches <- lapply(X = hcabm40k.batches, FUN = NormalizeData, verbose = FALSE) Mapping anchor We then find anchors between each donor query dataset and the multimodal reference. This command is optimized to minimize mapping time, by passing in a pre-computed set of reference neighbors, and turning off anchor filtration. sourceCode R anchors <- list() for (i in 1:length(hcabm40k.batches)) { anchors[[i]] <- FindTransferAnchors( reference = bm, query = hcabm40k.batches[[i]], k.filter = NA, reference.reduction = \"spca\", reference.neighbors = \"spca.annoy.neighbors\", dims = 1:50 ) } We then individually map each of the datasets. sourceCode R for (i in 1:length(hcabm40k.batches)) { hcabm40k.batches[[i]] <- MapQuery( anchorset = anchors[[i]], query = hcabm40k.batches[[i]], reference = bm, refdata = list( celltype = \"celltype.l2\", predicted_ADT = \"ADT\"), reference.reduction = \"spca\", reduction.model = \"wnn.umap\" ) } Explore the mapping results anchor Now that mapping is complete, we can visualize the results for individual objects sourceCode R p1 <- DimPlot(hcabm40k.batches[[1]], reduction = 'ref.umap', group.by = 'predicted.celltype', label.size = 3) p2 <- DimPlot(hcabm40k.batches[[2]], reduction = 'ref.umap', group.by = 'predicted.celltype', label.size = 3) p1 + p2 + plot_layout(guides = \"collect\") We can also merge all the objects into one dataset. Note that they have all been integrated into a common space, defined by the reference. We can then visualize the results together. ```sourceCode R Merge the batches hcabm40k <- merge(hcabm40k.batches[[1]], hcabm40k.batches[2:length(hcabm40k.batches)], merge.dr = \"ref.umap\") DimPlot(hcabm40k, reduction = \"ref.umap\", group.by = \"predicted.celltype\", label = TRUE, repel = TRUE, label.size = 3) + NoLegend() ``` We can visualize gene expression, cluster prediction scores, and (imputed) surface protein levels in the query cells: ```sourceCode R p3 <- FeaturePlot(hcabm40k, features = c(\"rna_TRDC\", \"rna_MPO\", \"rna_AVP\"), reduction = 'ref.umap', max.cutoff = 3, ncol = 3) cell type prediction scores DefaultAssay(hcabm40k) <- 'prediction.score.celltype' p4 <- FeaturePlot(hcabm40k, features = c(\"CD16 Mono\", \"HSC\", \"Prog-RBC\"), ncol = 3, cols = c(\"lightgrey\", \"darkred\")) imputed protein levels DefaultAssay(hcabm40k) <- 'predicted_ADT' p5 <- FeaturePlot(hcabm40k, features = c(\"CD45RA\", \"CD16\", \"CD161\"), reduction = 'ref.umap', min.cutoff = 'q10', max.cutoff = 'q99', cols = c(\"lightgrey\", \"darkgreen\") , ncol = 3) p3 / p4 / p5 ``` Session Info sourceCode R sessionInfo() ``` R version 4.2.2 Patched (2022-11-10 r83330) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.6 LTS Matrix products: default BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats graphics grDevices utils datasets methods base other attached packages: [1] dplyr_1.1.3 thp1.eccite.SeuratData_3.1.5 [3] stxBrain.SeuratData_0.1.1 ssHippo.SeuratData_3.1.4 [5] pbmcsca.SeuratData_3.0.0 pbmcref.SeuratData_1.0.0 [7] pbmcMultiome.SeuratData_0.1.4 pbmc3k.SeuratData_3.1.4 [9] panc8.SeuratData_3.0.2 ifnb.SeuratData_3.0.0 [11] hcabm40k.SeuratData_3.0.0 cbmc.SeuratData_3.1.4 [13] bmcite.SeuratData_0.3.0 SeuratData_0.2.2.9001 [15] patchwork_1.1.3 ggplot2_3.4.4 [17] Seurat_5.0.0 SeuratObject_5.0.0 [19] sp_2.1-1 loaded via a namespace (and not attached): [1] utf8_1.2.4 spatstat.explore_3.2-5 [3] reticulate_1.34.0 tidyselect_1.2.0 [5] htmlwidgets_1.6.2 grid_4.2.2 [7] Rtsne_0.16 munsell_0.5.0 [9] codetools_0.2-19 ragg_1.2.5 [11] ica_1.0-3 future_1.33.0 [13] miniUI_0.1.1.1 withr_2.5.2 [15] spatstat.random_3.2-1 colorspace_2.1-0 [17] progressr_0.14.0 Biobase_2.58.0 [19] highr_0.10 knitr_1.45 [21] stats4_4.2.2 ROCR_1.0-11 [23] tensor_1.5 listenv_0.9.0 [25] MatrixGenerics_1.10.0 labeling_0.4.3 [27] GenomeInfoDbData_1.2.9 polyclip_1.10-6 [29] farver_2.1.1 rprojroot_2.0.3 [31] parallelly_1.36.0 vctrs_0.6.4 [33] generics_0.1.3 xfun_0.40 [35] R6_2.5.1 GenomeInfoDb_1.34.9 [37] ggbeeswarm_0.7.1 bitops_1.0-7 [39] spatstat.utils_3.0-4 cachem_1.0.8 [41] DelayedArray_0.24.0 promises_1.2.1 [43] scales_1.2.1 beeswarm_0.4.0 [45] gtable_0.3.4 globals_0.16.2 [47] goftest_1.2-3 spam_2.10-0 [49] rlang_1.1.1 systemfonts_1.0.4 [51] splines_4.2.2 lazyeval_0.2.2 [53] spatstat.geom_3.2-7 yaml_2.3.7 [55] reshape2_1.4.4 abind_1.4-5 [57] httpuv_1.6.12 tools_4.2.2 [59] ellipsis_0.3.2 jquerylib_0.1.4 [61] RColorBrewer_1.1-3 BiocGenerics_0.44.0 [63] ggridges_0.5.4 Rcpp_1.0.11 [65] plyr_1.8.9 sparseMatrixStats_1.10.0 [67] zlibbioc_1.44.0 purrr_1.0.2 [69] RCurl_1.98-1.12 deldir_1.0-9 [71] pbapply_1.7-2 cowplot_1.1.1 [73] S4Vectors_0.36.2 zoo_1.8-12 [75] SummarizedExperiment_1.28.0 ggrepel_0.9.4 [77] cluster_2.1.4 fs_1.6.3 [79] magrittr_2.0.3 data.table_1.14.8 [81] RSpectra_0.16-1 glmGamPoi_1.10.2 [83] scattermore_1.2 lmtest_0.9-40 [85] RANN_2.6.1 fitdistrplus_1.1-11 [87] matrixStats_1.0.0 mime_0.12 [89] evaluate_0.22 xtable_1.8-4 [91] fastDummies_1.7.3 IRanges_2.32.0 [93] gridExtra_2.3 compiler_4.2.2 [95] tibble_3.2.1 KernSmooth_2.23-22 [97] crayon_1.5.2 htmltools_0.5.6.1 [99] later_1.3.1 tidyr_1.3.0 [101] MASS_7.3-58.2 rappdirs_0.3.3 [103] Matrix_1.6-1.1 cli_3.6.1 [105] parallel_4.2.2 dotCall64_1.1-0 [107] igraph_1.5.1 GenomicRanges_1.50.2 [109] pkgconfig_2.0.3 pkgdown_2.0.7 [111] plotly_4.10.3 spatstat.sparse_3.0-3 [113] vipor_0.4.5 bslib_0.5.1 [115] XVector_0.38.0 stringr_1.5.0 [117] digest_0.6.33 sctransform_0.4.1 [119] RcppAnnoy_0.0.21 spatstat.data_3.0-3 [121] rmarkdown_2.25 leiden_0.4.3 [123] uwot_0.1.16 DelayedMatrixStats_1.20.0 [125] shiny_1.7.5.1 lifecycle_1.0.3 [127] nlme_3.1-162 jsonlite_1.8.7 [129] limma_3.54.1 desc_1.4.2 [131] viridisLite_0.4.2 fansi_1.0.5 [133] pillar_1.9.0 lattice_0.21-9 [135] ggrastr_1.0.1 fastmap_1.1.1 [137] httr_1.4.7 survival_3.5-7 [139] glue_1.6.2 png_0.1-8 [141] presto_1.0.0 stringi_1.7.12 [143] sass_0.4.7 textshaping_0.3.6 [145] RcppHNSW_0.5.0 memoise_2.0.1 [147] irlba_2.3.5.1 future.apply_1.11.0 ```",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/multimodal_reference_mapping",
      "title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat • Seurat",
      "ogTitle": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "language": "en",
      "og:title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "scrapeId": "e2103077-d282-4c80-a220-ab376b9bb0ba",
      "viewport": "width=device-width, initial-scale=1.0",
      "sourceURL": "https://satijalab.org/seurat/articles/multimodal_reference_mapping",
      "statusCode": 200,
      "ogDescription": "Seurat",
      "og:description": "Seurat"
    }
  },
  {
    "processed_text": "Using sctransform in Seurat Saket Choudhary, Christoph Hafemeister & Rahul Satija Compiled: 2023-10-31 Source: vignettes/sctransform_vignette.Rmd sctransform_vignette.Rmd Biological heterogeneity in single-cell RNA-seq data is often confounded by technical factors including sequencing depth. The number of molecules detected in each cell can vary significantly between cells, even within the same celltype. Interpretation of scRNA-seq data requires effective pre-processing and normalization to remove this technical variability. In our manuscript we introduce a modeling framework for the normalization and variance stabilization of molecular count data from scRNA-seq experiments. This procedure omits the need for heuristic steps including pseudocount addition or log-transformation and improves common downstream analytical tasks such as variable gene selection, dimensional reduction, and differential expression. We named this method sctransform . Inspired by important and rigorous work from Lause et al , we released an updated manuscript and updated the sctransform software to a v2 version, which is now the default in Seurat v5. sourceCode R library(Seurat) library(ggplot2) library(sctransform) Load data and create Seurat object anchor sourceCode R pbmc_data <- Read10X(data.dir = \"/brahms/shared/vignette-data/pbmc3k/filtered_gene_bc_matrices/hg19/\") pbmc <- CreateSeuratObject(counts = pbmc_data) Apply sctransform normalization anchor Note that this single command replaces NormalizeData() , ScaleData() , and FindVariableFeatures() . Transformed data will be available in the SCT assay, which is set as the default after running sctransform During normalization, we can also remove confounding sources of variation, for example, mitochondrial mapping percentage In Seurat v5, SCT v2 is applied by default. You can revert to v1 by setting vst.flavor = 'v1' The glmGamPoi package substantially improves speed and is used by default if installed, with instructions here ```sourceCode R store mitochondrial percentage in object meta data pbmc <- PercentageFeatureSet(pbmc, pattern = \"^MT-\", col.name = \"percent.mt\") run sctransform pbmc <- SCTransform(pbmc, vars.to.regress = \"percent.mt\", verbose = FALSE) ``` Perform dimensionality reduction by PCA and UMAP embedding anchor ```sourceCode R These are now standard steps in the Seurat workflow for visualization and clustering pbmc <- RunPCA(pbmc, verbose = FALSE) pbmc <- RunUMAP(pbmc, dims = 1:30, verbose = FALSE) pbmc <- FindNeighbors(pbmc, dims = 1:30, verbose = FALSE) pbmc <- FindClusters(pbmc, verbose = FALSE) DimPlot(pbmc, label = TRUE) ``` Why can we choose more PCs when using sctransform? In the standard Seurat workflow we focus on 10 PCs for this dataset, though we highlight that the results are similar with higher settings for this parameter. Interestingly, we’ve found that when using sctransform, we often benefit by pushing this parameter even higher. We believe this is because the sctransform workflow performs more effective normalization, strongly removing technical effects from the data. Even after standard log-normalization, variation in sequencing depth is still a confounding factor (see Figure 1 ), and this effect can subtly influence higher PCs. In sctransform, this effect is substantially mitigated (see Figure 3 ). This means that higher PCs are more likely to represent subtle, but biologically relevant, sources of heterogeneity – so including them may improve downstream analysis. In addition, sctransform returns 3,000 variable features by default, instead of 2,000. The rationale is similar, the additional variable features are less likely to be driven by technical differences across cells, and instead may represent more subtle biological fluctuations. In general, we find that results produced with sctransform are less dependent on these parameters (indeed, we achieve nearly identical results when using all genes in the transcriptome, though this does reduce computational efficiency). This can help users generate more robust results, and in addition, enables the application of standard analysis pipelines with identical parameter settings that can quickly be applied to new datasets: For example, the following code replicates the full end-to-end workflow, in a single command: sourceCode R pbmc <- CreateSeuratObject(pbmc_data) %>% PercentageFeatureSet(pattern = \"^MT-\", col.name = \"percent.mt\") %>% SCTransform(vars.to.regress = \"percent.mt\") %>% RunPCA() %>% FindNeighbors(dims = 1:30) %>% RunUMAP(dims = 1:30) %>% FindClusters() Where are normalized values stored for sctransform? The results of sctransfrom are stored in the “SCT” assay. You can learn more about multi-assay data and commands in Seurat in our vignette , command cheat sheet , or developer guide . pbmc[[\"SCT\"]]$scale.data contains the residuals (normalized values), and is used directly as input to PCA. Please note that this matrix is non-sparse, and can therefore take up a lot of memory if stored for all genes. To save memory, we store these values only for variable genes, by setting the return.only.var.genes = TRUE by default in the SCTransform() function call. To assist with visualization and interpretation, we also convert Pearson residuals back to ‘corrected’ UMI counts. You can interpret these as the UMI counts we would expect to observe if all cells were sequenced to the same depth. If you want to see exactly how we do this, please look at the correct function here . The ‘corrected’ UMI counts are stored in pbmc[[\"SCT\"]]$counts . We store log-normalized versions of these corrected counts in pbmc[[\"SCT\"]]$data , which are very helpful for visualization. Users can individually annotate clusters based on canonical markers. However, the sctransform normalization reveals sharper biological distinctions compared to the standard Seurat workflow , in a few ways: Clear separation of at least 3 CD8 T cell populations (naive, memory, effector), based on CD8A, GZMK, CCL5, CCR7 expression Clear separation of three CD4 T cell populations (naive, memory, IFN-activated) based on S100A4, CCR7, IL32, and ISG15 Additional developmental sub-structure in B cell cluster, based on TCL1A, FCER2 Additional separation of NK cells into CD56dim vs. bright clusters, based on XCL1 and FCGR3A ```sourceCode R These are now standard steps in the Seurat workflow for visualization and clustering Visualize canonical marker genes as violin plots. VlnPlot(pbmc, features = c(\"CD8A\", \"GZMK\", \"CCL5\", \"S100A4\", \"ANXA1\", \"CCR7\", \"ISG15\", \"CD3D\"), pt.size = 0.2, ncol = 4) ``` ```sourceCode R Visualize canonical marker genes on the sctransform embedding. FeaturePlot(pbmc, features = c(\"CD8A\", \"GZMK\", \"CCL5\", \"S100A4\", \"ANXA1\", \"CCR7\"), pt.size = 0.2, ncol = 3) ``` sourceCode R FeaturePlot(pbmc, features = c(\"CD3D\", \"ISG15\", \"TCL1A\", \"FCER2\", \"XCL1\", \"FCGR3A\"), pt.size = 0.2, ncol = 3) Session Info sourceCode R sessionInfo() ``` R version 4.2.2 Patched (2022-11-10 r83330) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.6 LTS Matrix products: default BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats graphics grDevices utils datasets methods base other attached packages: [1] sctransform_0.4.1 ggplot2_3.4.4 Seurat_5.0.0 SeuratObject_5.0.0 [5] sp_2.1-1 loaded via a namespace (and not attached): [1] spam_2.10-0 systemfonts_1.0.4 [3] plyr_1.8.9 igraph_1.5.1 [5] lazyeval_0.2.2 splines_4.2.2 [7] RcppHNSW_0.5.0 listenv_0.9.0 [9] scattermore_1.2 GenomeInfoDb_1.34.9 [11] digest_0.6.33 htmltools_0.5.6.1 [13] fansi_1.0.5 magrittr_2.0.3 [15] memoise_2.0.1 tensor_1.5 [17] cluster_2.1.4 ROCR_1.0-11 [19] globals_0.16.2 matrixStats_1.0.0 [21] R.utils_2.12.2 pkgdown_2.0.7 [23] spatstat.sparse_3.0-3 colorspace_2.1-0 [25] ggrepel_0.9.4 textshaping_0.3.6 [27] xfun_0.40 dplyr_1.1.3 [29] RCurl_1.98-1.12 jsonlite_1.8.7 [31] progressr_0.14.0 spatstat.data_3.0-3 [33] survival_3.5-7 zoo_1.8-12 [35] glue_1.6.2 polyclip_1.10-6 [37] gtable_0.3.4 zlibbioc_1.44.0 [39] XVector_0.38.0 leiden_0.4.3 [41] DelayedArray_0.24.0 future.apply_1.11.0 [43] BiocGenerics_0.44.0 abind_1.4-5 [45] scales_1.2.1 spatstat.random_3.2-1 [47] miniUI_0.1.1.1 Rcpp_1.0.11 [49] viridisLite_0.4.2 xtable_1.8-4 [51] reticulate_1.34.0 dotCall64_1.1-0 [53] stats4_4.2.2 htmlwidgets_1.6.2 [55] httr_1.4.7 RColorBrewer_1.1-3 [57] ellipsis_0.3.2 ica_1.0-3 [59] farver_2.1.1 pkgconfig_2.0.3 [61] R.methodsS3_1.8.2 sass_0.4.7 [63] uwot_0.1.16 deldir_1.0-9 [65] utf8_1.2.4 labeling_0.4.3 [67] tidyselect_1.2.0 rlang_1.1.1 [69] reshape2_1.4.4 later_1.3.1 [71] munsell_0.5.0 tools_4.2.2 [73] cachem_1.0.8 cli_3.6.1 [75] generics_0.1.3 ggridges_0.5.4 [77] evaluate_0.22 stringr_1.5.0 [79] fastmap_1.1.1 yaml_2.3.7 [81] ragg_1.2.5 goftest_1.2-3 [83] knitr_1.45 fs_1.6.3 [85] fitdistrplus_1.1-11 purrr_1.0.2 [87] RANN_2.6.1 sparseMatrixStats_1.10.0 [89] pbapply_1.7-2 future_1.33.0 [91] nlme_3.1-162 mime_0.12 [93] formatR_1.14 ggrastr_1.0.1 [95] R.oo_1.25.0 compiler_4.2.2 [97] beeswarm_0.4.0 plotly_4.10.3 [99] png_0.1-8 spatstat.utils_3.0-4 [101] tibble_3.2.1 bslib_0.5.1 [103] glmGamPoi_1.10.2 stringi_1.7.12 [105] highr_0.10 desc_1.4.2 [107] RSpectra_0.16-1 lattice_0.21-9 [109] Matrix_1.6-1.1 vctrs_0.6.4 [111] pillar_1.9.0 lifecycle_1.0.3 [113] spatstat.geom_3.2-7 lmtest_0.9-40 [115] jquerylib_0.1.4 RcppAnnoy_0.0.21 [117] bitops_1.0-7 data.table_1.14.8 [119] cowplot_1.1.1 irlba_2.3.5.1 [121] GenomicRanges_1.50.2 httpuv_1.6.12 [123] patchwork_1.1.3 R6_2.5.1 [125] promises_1.2.1 KernSmooth_2.23-22 [127] gridExtra_2.3 vipor_0.4.5 [129] IRanges_2.32.0 parallelly_1.36.0 [131] codetools_0.2-19 fastDummies_1.7.3 [133] MASS_7.3-58.2 SummarizedExperiment_1.28.0 [135] rprojroot_2.0.3 withr_2.5.2 [137] GenomeInfoDbData_1.2.9 S4Vectors_0.36.2 [139] parallel_4.2.2 grid_4.2.2 [141] tidyr_1.3.0 DelayedMatrixStats_1.20.0 [143] rmarkdown_2.25 MatrixGenerics_1.10.0 [145] Rtsne_0.16 spatstat.explore_3.2-5 [147] Biobase_2.58.0 shiny_1.7.5.1 [149] ggbeeswarm_0.7.1 ```",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/sctransform_vignette",
      "title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat • Seurat",
      "ogTitle": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "language": "en",
      "og:title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "scrapeId": "e23cf5d9-0301-4e74-9a06-bec16cfef9d6",
      "viewport": "width=device-width, initial-scale=1.0",
      "sourceURL": "https://satijalab.org/seurat/articles/sctransform_vignette",
      "statusCode": 200,
      "ogDescription": "Seurat",
      "og:description": "Seurat"
    }
  },
  {
    "processed_text": "",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/seurat5_pbmc3k_tutorial.html",
      "error": "Not Found",
      "scrapeId": "e18d1927-5b0e-406b-a23d-1900245115ab",
      "sourceURL": "https://satijalab.org/seurat/articles/seurat5_pbmc3k_tutorial.html",
      "statusCode": 404
    }
  },
  {
    "processed_text": "",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/atacseq_integration_vignette.html",
      "error": "Not Found",
      "scrapeId": "e326e071-9d71-4acd-bf35-3a6552645035",
      "sourceURL": "https://satijalab.org/seurat/articles/atacseq_integration_vignette.html",
      "statusCode": 404
    }
  },
  {
    "processed_text": "",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/seurat5_cell_cycle_vignette.html",
      "error": "Not Found",
      "scrapeId": "e43cad78-0948-4bfc-956a-c53139b61e09",
      "sourceURL": "https://satijalab.org/seurat/articles/seurat5_cell_cycle_vignette.html",
      "statusCode": 404
    }
  },
  {
    "processed_text": "",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/seurat5_hashing_vignette.html",
      "error": "Not Found",
      "scrapeId": "eb389257-2d66-47df-b2bb-e8cc5705bbf0",
      "sourceURL": "https://satijalab.org/seurat/articles/seurat5_hashing_vignette.html",
      "statusCode": 404
    }
  },
  {
    "processed_text": "",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/sctransform_v2_vignette.html",
      "error": "Not Found",
      "scrapeId": "eb1cd2a7-573a-416d-9ee1-a7041ce86ecb",
      "sourceURL": "https://satijalab.org/seurat/articles/sctransform_v2_vignette.html",
      "statusCode": 404
    }
  },
  {
    "processed_text": "",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/seurat5_multimodal_reference_mapping.html",
      "error": "Not Found",
      "scrapeId": "f09b2492-a327-4d6f-b70a-21c0ab9bcaef",
      "sourceURL": "https://satijalab.org/seurat/articles/seurat5_multimodal_reference_mapping.html",
      "statusCode": 404
    }
  },
  {
    "processed_text": "Analysis of Image-based Spatial Data in Seurat Compiled: October 31, 2023 Source: vignettes/seurat5_spatial_vignette_2.Rmd seurat5_spatial_vignette_2.Rmd Overview anchor In this vignette, we introduce a Seurat extension to analyze new types of spatially-resolved data. We have previously introduced a spatial framework which is compatible with sequencing-based technologies, like the 10x Genomics Visium system, or SLIDE-seq. Here, we extend this framework to analyze new data types that are captured via highly multiplexed imaging. In contrast to sequencing-based technologies, these datasets are often targeted (i.e. they profile a pre-selected set of genes). However they can resolve individual molecules - retaining single-cell (and subcellular) resolution. These approaches also often capture cellular boundaries (segmentations). We update the Seurat infrastructure to enable the analysis, visualization, and exploration of these exciting datasets. In this vignette, we focus on three datasets produced by different multiplexed imaging technologies, each of which is publicly available. We will be adding support for additional imaging-based technologies in the coming months. Vizgen MERSCOPE (Mouse Brain) Nanostring CosMx Spatial Molecular Imager (FFPE Human Lung) Akoya CODEX (Human Lymph Node) First, we load the packages necessary for this vignette. sourceCode R library(Seurat) library(future) plan(\"multisession\", workers = 10) library(ggplot2) Mouse Brain: Vizgen MERSCOPE anchor This dataset was produced using the Vizgen MERSCOPE system, which utilizes the MERFISH technology. The total dataset is available for public download , and contains nine samples (three full coronal slices of the mouse brain, with three biological replicates per slice). The gene panel consists of 483 gene targets, representing known anonical cell type markers, nonsensory G-Protein coupled receptors (GPCRs), and Receptor Tyrosine Kinases (RTKs). In this vignette, we analyze one of the samples - slice 2, replicate 1. The median number of transcripts detected in each cell is 206. First, we read in the dataset and create a Seurat object. We use the LoadVizgen() function, which we have written to read in the output of the Vizgen analysis pipeline. The resulting Seurat object contains the following information: A count matrix, indicating the number of observed molecules for each of the 483 transcripts in each cell. This matrix is analogous to a count matrix in scRNA-seq, and is stored by default in the RNA assay of the Seurat object ```sourceCode R Loading segmentations is a slow process and multi processing with the future pacakge is recommended vizgen.obj <- LoadVizgen(data.dir = \"/brahms/hartmana/vignette_data/vizgen/s2r1/\", fov = \"s2r1\") ``` The next pieces of information are specific to imaging assays, and is stored in the images slot of the resulting Seurat object: Cell Centroids: The spatial coordinates marking the centroid for each cell being profiled ```sourceCode R Get the center position of each centroid. There is one row per cell in this dataframe. head(GetTissueCoordinates(vizgen.obj[[\"s2r1\"]][[\"centroids\"]])) ``` ``` x y cell 1 638.5640 4594.216 149164679103246548309819743981609972453 2 593.8034 4516.240 215843146921706462965382248182021894607 3 597.3134 4566.676 230248905804673613678286091156141465134 4 613.2434 4609.498 237155298815097057940587033798543926454 5 609.1934 4603.180 256099454901769634241742157204636917386 6 623.8814 4642.708 52442222147121971758529793775250916001 ``` Cell Segmentation Boundaries: The spatial coordinates that describe the polygon segmentation of each single cell ```sourceCode R Get the coordinates for each segmentation vertice. Each cell will have a variable number of vertices describing its shape. head(GetTissueCoordinates(vizgen.obj[[\"s2r1\"]][[\"segmentation\"]])) ``` ``` x y cell 1 644.0774 4589.022 149164679103246548309819743981609972453 2 643.9694 4589.022 149164679103246548309819743981609972453 3 643.8614 4589.022 149164679103246548309819743981609972453 4 643.7642 4588.924 149164679103246548309819743981609972453 5 643.7534 4588.914 149164679103246548309819743981609972453 6 643.6454 4588.914 149164679103246548309819743981609972453 ``` Molecule positions: The spatial coordinates for each individual molecule that was detected during the multiplexed smFISH experiment. ```sourceCode R Fetch molecules positions for Chrm1 head(FetchData(vizgen.obj[[\"s2r1\"]][[\"molecules\"]], vars = \"Chrm1\")) ``` ``` x y molecule 1 577.3373 4205.977 Chrm1 2 600.0218 3917.781 Chrm1 3 508.2736 3934.063 Chrm1 4 630.7590 3948.586 Chrm1 5 635.1143 3969.567 Chrm1 6 582.7043 4021.577 Chrm1 ``` Preprocessing and unsupervised analysis anchor We start by performing a standard unsupervised clustering analysis, essentially first treating the dataset as an scRNA-seq experiment. We use SCTransform-based normalization, though we slightly modify the default clipping parameters to mitigate the effect of outliers that we occasionally observe in smFISH experiments. After normalization, we can run dimensional reduction and clustering. sourceCode R vizgen.obj <- SCTransform(vizgen.obj, assay = \"Vizgen\", clip.range = c(-10, 10)) vizgen.obj <- RunPCA(vizgen.obj, npcs = 30, features = rownames(vizgen.obj)) vizgen.obj <- RunUMAP(vizgen.obj, dims = 1:30) vizgen.obj <- FindNeighbors(vizgen.obj, reduction = \"pca\", dims = 1:30) vizgen.obj <- FindClusters(vizgen.obj, resolution = 0.3) We can then visualize the results of the clustering either in UMAP space (with DimPlot() ) or overlaid on the image with ImageDimPlot() . sourceCode R DimPlot(vizgen.obj, reduction = \"umap\") sourceCode R ImageDimPlot(vizgen.obj, fov = \"s2r1\", cols = \"polychrome\", axes = TRUE) You can also customize multiple aspect of the plot, including the color scheme, cell border widths, and size (see below). Customizing spatial plots in Seurat The ImageDimPlot() and ImageFeaturePlot() functions have a few parameters which you can customize individual visualizations. These include: alpha: Ranges from 0 to 1. Sets the transparency of within-cell coloring. size: determines the size of points representing cells, if centroids are being plotted cols: Sets the color scheme for the internal shading of each cell. Examples settings are polychrome , glasbey , Paired , Set3 , and parade . Default is the ggplot2 color palette shuffle.cols: In some cases the selection of cols is more effective when the same colors are assigned to different clusters. Set shuffle.cols = TRUE to randomly shuffle the colors in the palette. border.size: Sets the width of the cell segmentation borders. By default, segmentations are plotted with a border size of 0.3 and centroids are plotted without border. border.color: Sets the color of the cell segmentation borders dark.background: Sets a black background color (TRUE by default) axes: Display Since it can be difficult to visualize the spatial localization patterns of an individual cluster when viewing them all together, we can highlight all cells that belong to a particular cluster: sourceCode R p1 <- ImageDimPlot(vizgen.obj, fov = \"s2r1\", cols = \"red\", cells = WhichCells(vizgen.obj, idents = 1)) p2 <- ImageDimPlot(vizgen.obj, fov = \"s2r1\", cols = \"red\", cells = WhichCells(vizgen.obj, idents = 15)) p1 + p2 We can find markers of individual clusters and visualize their spatial expression pattern. We can color cells based on their quantified expression of an individual gene, using ImageFeaturePlot() , which is analagous to the FeaturePlot() function for visualizing expression on a 2D embedding. Since MERFISH images individual molecules, we can also visualize the location of individual molecules . sourceCode R p1 <- ImageFeaturePlot(vizgen.obj, features = \"Slc17a7\") p2 <- ImageDimPlot(vizgen.obj, molecules = \"Slc17a7\", nmols = 10000, alpha = 0.3, mols.cols = \"red\") p1 + p2 Note that the nmols parameter can be used to reduce the total number of molecules shown to reduce overplotting. You can also use the mols.size , mols.cols , and mols.alpha parameter to further optimize. Plotting molecules is especially useful for visualizing co-expression of multiple genes on the same plot. sourceCode R p1 <- ImageDimPlot(vizgen.obj, fov = \"s2r1\", alpha = 0.3, molecules = c(\"Slc17a7\", \"Olig1\"), nmols = 10000) markers.14 <- FindMarkers(vizgen.obj, ident.1 = \"14\") p2 <- ImageDimPlot(vizgen.obj, fov = \"s2r1\", alpha = 0.3, molecules = rownames(markers.14)[1:4], nmols = 10000) p1 + p2 The updated Seurat spatial framework has the option to treat cells as individual points, or also to visualize cell boundaries (segmentations). By default, Seurat ignores cell segmentations and treats each cell as a point (‘centroids’). This speeds up plotting, especially when looking at large areas, where cell boundaries are too small to visualize. We can zoom into a region of tissue, creating a new field of view. For example, we can zoom into a region that contains the hippocampus. Once zoomed-in, we can set DefaultBoundary() to show cell segmentations. You can also ‘simplify’ the cell segmentations, reducing the number of edges in each polygon to speed up plotting. ```sourceCode R create a Crop cropped.coords <- Crop(vizgen.obj[[\"s2r1\"]], x = c(1750, 3000), y = c(3750, 5250), coords = \"plot\") set a new field of view (fov) vizgen.obj[[\"hippo\"]] <- cropped.coords visualize FOV using default settings (no cell boundaries) p1 <- ImageDimPlot(vizgen.obj, fov = \"hippo\", axes = TRUE, size = 0.7, border.color = \"white\", cols = \"polychrome\", coord.fixed = FALSE) visualize FOV with full cell segmentations DefaultBoundary(vizgen.obj[[\"hippo\"]]) <- \"segmentation\" p2 <- ImageDimPlot(vizgen.obj, fov = \"hippo\", axes = TRUE, border.color = \"white\", border.size = 0.1, cols = \"polychrome\", coord.fixed = FALSE) simplify cell segmentations vizgen.obj[[\"hippo\"]][[\"simplified.segmentations\"]] <- Simplify(coords = vizgen.obj[[\"hippo\"]][[\"segmentation\"]], tol = 3) DefaultBoundary(vizgen.obj[[\"hippo\"]]) <- \"simplified.segmentations\" visualize FOV with simplified cell segmentations DefaultBoundary(vizgen.obj[[\"hippo\"]]) <- \"simplified.segmentations\" p3 <- ImageDimPlot(vizgen.obj, fov = \"hippo\", axes = TRUE, border.color = \"white\", border.size = 0.1, cols = \"polychrome\", coord.fixed = FALSE) p1 + p2 + p3 ``` What is the tol parameter? The tol parameter determines how simplified the resulting segmentations are. A higher value of tol will reduce the number of vertices more drastically which will speed up plotting, but some segmentation detail will be lost. See https://rgeos.r-forge.r-project.org/reference/topo-unary-gSimplify.html for examples using different values for tol. We can visualize individual molecules plotted at higher resolution after zooming-in ```sourceCode R Since there is nothing behind the segmentations, alpha will slightly mute colors ImageDimPlot(vizgen.obj, fov = \"hippo\", molecules = rownames(markers.14)[1:4], cols = \"polychrome\", mols.size = 1, alpha = 0.5, mols.cols = c(\"red\", \"blue\", \"yellow\", \"green\")) ``` Mouse Brain: 10x Genomics Xenium In Situ anchor In this section we’ll analyze data produced by the Xenium platform. The vignette demonstrates how to load the per-transcript location data, cell x gene matrix, cell segmentation, and cell centroid information available in the Xenium outputs. The resulting Seurat object will contain the gene expression profile of each cell, the centroid and boundary of each cell, and the location of each individual detected transcript. The per-cell gene expression profiles are similar to standard single-cell RNA-seq and can be analyzed using the same tools. This uses the Tiny subset dataset from 10x Genomics provided in the Fresh Frozen Mouse Brain for Xenium Explorer Demo which can be downloaded as described below. These analysis steps are also compatible with the larger Full coronal section , but will take longer to execute. sourceCode bash wget https://cf.10xgenomics.com/samples/xenium/1.0.2/Xenium_V1_FF_Mouse_Brain_Coronal_Subset_CTX_HP/Xenium_V1_FF_Mouse_Brain_Coronal_Subset_CTX_HP_outs.zip unzip Xenium_V1_FF_Mouse_Brain_Coronal_Subset_CTX_HP_outs.zip First we read in the dataset and create a Seurat object. Provide the path to the data folder for a Xenium run as the input path. The RNA data is stored in the Xenium assay of the Seurat object. This step should take about a minute. ```sourceCode R path <- \"/brahms/hartmana/vignette_data/xenium_tiny_subset\" Load the Xenium data xenium.obj <- LoadXenium(path, fov = \"fov\") remove cells with 0 counts xenium.obj <- subset(xenium.obj, subset = nCount_Xenium > 0) ``` Spatial information is loaded into slots of the Seurat object, labelled by the name of “field of view” (FOV) being loaded. Initially all the data is loaded into the FOV named fov . Later, we will make a cropped FOV that zooms into a region of interest. Standard QC plots provided by Seurat are available via the Xenium assay. Here are violin plots of genes per cell ( nFeature_Xenium ) and transcript counts per cell ( nCount_Xenium ) sourceCode R VlnPlot(xenium.obj, features = c(\"nFeature_Xenium\", \"nCount_Xenium\"), ncol = 2, pt.size = 0) Next, we plot the positions of the pan-inhibitory neuron marker Gad1, inhibitory neuron sub-type markers Pvalb, and Sst, and astrocyte marker Gfap on the tissue using ImageDimPlot() . sourceCode R ImageDimPlot(xenium.obj, fov = \"fov\", molecules = c(\"Gad1\", \"Sst\", \"Pvalb\", \"Gfap\"), nmols = 20000) Here we visualize the expression level of some key layer marker genes at the per-cell level using ImageFeaturePlot() which is analogous to the FeaturePlot() function for visualizing expression on a 2D embedding. We manually adjust the max.cutoff for each gene to roughly the 90th percentile (which can be specified with max.cutoff='q90' ) of it’s count distribution to improve contrast. sourceCode R ImageFeaturePlot(xenium.obj, features = c(\"Cux2\", \"Rorb\", \"Bcl11b\", \"Foxp2\"), max.cutoff = c(25, 35, 12, 10), size = 0.75, cols = c(\"white\", \"red\")) We can zoom in on a chosen area with the Crop() function. Once zoomed-in, we can visualize cell segmentation boundaries along with individual molecules. ```sourceCode R cropped.coords <- Crop(xenium.obj[[\"fov\"]], x = c(1200, 2900), y = c(3750, 4550), coords = \"plot\") xenium.obj[[\"zoom\"]] <- cropped.coords visualize cropped area with cell segmentations & selected molecules DefaultBoundary(xenium.obj[[\"zoom\"]]) <- \"segmentation\" ImageDimPlot(xenium.obj, fov = \"zoom\", axes = TRUE, border.color = \"white\", border.size = 0.1, cols = \"polychrome\", coord.fixed = FALSE, molecules = c(\"Gad1\", \"Sst\", \"Npy2r\", \"Pvalb\", \"Nrn1\"), nmols = 10000) ``` Next, we use SCTransform for normalization followed by standard dimensionality reduction and clustering. This step takes about 5 minutes from start to finish. sourceCode R xenium.obj <- SCTransform(xenium.obj, assay = \"Xenium\") xenium.obj <- RunPCA(xenium.obj, npcs = 30, features = rownames(xenium.obj)) xenium.obj <- RunUMAP(xenium.obj, dims = 1:30) xenium.obj <- FindNeighbors(xenium.obj, reduction = \"pca\", dims = 1:30) xenium.obj <- FindClusters(xenium.obj, resolution = 0.3) We can then visualize the results of the clustering by coloring each cell according to its cluster either in UMAP space with DimPlot() or overlaid on the image with ImageDimPlot() . sourceCode R DimPlot(xenium.obj) We can visualize the expression level of the markers we looked at earlier on the UMAP coordinates. sourceCode R FeaturePlot(xenium.obj, features = c(\"Cux2\", \"Bcl11b\", \"Foxp2\", \"Gad1\", \"Sst\", \"Gfap\")) We can now use ImageDimPlot() to color the cell positions colored by the cluster labels determined in the previous step. sourceCode R ImageDimPlot(xenium.obj, cols = \"polychrome\", size = 0.75) Using the positional information of each cell, we compute spatial niches. We use a cortex reference from the the Allen Brain Institute to annotate cells, so we first crop the dataset to the cortex. The Allen Brain reference can be installed here . Below, we use Slc17a7 expression to help determine the cortical region. sourceCode R xenium.obj <- LoadXenium(\"/brahms/hartmana/vignette_data/xenium_tiny_subset\") p1 <- ImageFeaturePlot(xenium.obj, features = \"Slc17a7\", axes = TRUE, max.cutoff = \"q90\") p1 sourceCode R crop <- Crop(xenium.obj[[\"fov\"]], x = c(600, 2100), y = c(900, 4700)) xenium.obj[[\"crop\"]] <- crop p2 <- ImageFeaturePlot(xenium.obj, fov = \"crop\", features = \"Slc17a7\", size = 1, axes = TRUE, max.cutoff = \"q90\") p2 While FindTransferAnchors can be used to integrate spot-level data from spatial transcriptomic datasets, Seurat v5 also includes support for the Robust Cell Type Decomposition , a computational approach to deconvolve spot-level data from spatial datasets, when provided with an scRNA-seq reference. RCTD has been shown to accurately annotate spatial data from a variety of technologies, including SLIDE-seq, Visium, and the 10x Xenium in-situ spatial platform. To run RCTD, we first install the spacexr package from GitHub which implements RCTD. sourceCode R devtools::install_github(\"dmcable/spacexr\", build_vignettes = FALSE) Counts, cluster, and spot information is extracted from the Seurat query and reference objects to construct Reference and SpatialRNA objects used by RCTD for annotation. The output of the annotation is then added to the Seurat object. ```sourceCode R library(spacexr) query.counts <- GetAssayData(xenium.obj, assay = \"Xenium\", slot = \"counts\")[, Cells(xenium.obj[[\"crop\"]])] coords <- GetTissueCoordinates(xenium.obj[[\"crop\"]], which = \"centroids\") rownames(coords) <- coords$cell coords$cell <- NULL query <- SpatialRNA(coords, query.counts, colSums(query.counts)) ``` ```sourceCode R allen.corted.ref can be downloaded here: https://www.dropbox.com/s/cuowvm4vrf65pvq/allen_cortex.rds?dl=1 allen.cortex.ref <- readRDS(\"/brahms/shared/vignette-data/allen_cortex.rds\") allen.cortex.ref <- UpdateSeuratObject(allen.cortex.ref) Idents(allen.cortex.ref) <- \"subclass\" remove CR cells because there aren't enough of them for annotation allen.cortex.ref <- subset(allen.cortex.ref, subset = subclass != \"CR\") counts <- GetAssayData(allen.cortex.ref, assay = \"RNA\", slot = \"counts\") cluster <- as.factor(allen.cortex.ref$subclass) names(cluster) <- colnames(allen.cortex.ref) nUMI <- allen.cortex.ref$nCount_RNA names(nUMI) <- colnames(allen.cortex.ref) nUMI <- colSums(counts) levels(cluster) <- gsub(\"/\", \"-\", levels(cluster)) reference <- Reference(counts, cluster, nUMI) ``` ```sourceCode R run RCTD with many cores RCTD <- create.RCTD(query, reference, max_cores = 8) RCTD <- run.RCTD(RCTD, doublet_mode = \"doublet\") ``` sourceCode R annotations.df <- RCTD@results$results_df annotations <- annotations.df$first_type names(annotations) <- rownames(annotations.df) xenium.obj$predicted.celltype <- annotations keep.cells <- Cells(xenium.obj)[!is.na(xenium.obj$predicted.celltype)] xenium.obj <- subset(xenium.obj, cells = keep.cells) While the previous analyses consider each cell independently, spatial data enables cells to be defined not just by their neighborhood, but also by their broader spatial context. In Seurat v5, we introduce support for ‘niche’ analysis of spatial data, which demarcates regions of tissue (‘niches’), each of which is defined by a different composition of spatially adjacent cell types. Inspired by methods in Goltsev et al, Cell 2018 and He et al, NBT 2022 , we consider the ‘local neighborhood’ for each cell - consisting of its k.neighbor spatially closest neighbors, and count the occurrences of each cell type present in this neighborhood. We then use k-means clustering to group cells that have similar neighborhoods together, into spatial niches. We call the BuildNicheAssay function from within Seurat to construct a new assay called niche containing the cell type composition spatially neighboring each cell. A metadata column called niches is also returned, which contains cluster assignments based on the niche assay. sourceCode R xenium.obj <- BuildNicheAssay(object = xenium.obj, fov = \"crop\", group.by = \"predicted.celltype\", niches.k = 5, neighbors.k = 30) We can then group cells either by their cell type identity, or their niche identity. The niches identified clearly demarcate the neuronal layers in the cortex. sourceCode R celltype.plot <- ImageDimPlot(xenium.obj, group.by = \"predicted.celltype\", size = 1.5, cols = \"polychrome\", dark.background = F) + ggtitle(\"Cell type\") niche.plot <- ImageDimPlot(xenium.obj, group.by = \"niches\", size = 1.5, dark.background = F) + ggtitle(\"Niches\") + scale_fill_manual(values = c(\"#442288\", \"#6CA2EA\", \"#B5D33D\", \"#FED23F\", \"#EB7D5B\")) celltype.plot | niche.plot Further, we observe that the composition of each niche is enriched for distinct cell types. sourceCode R table(xenium.obj$predicted.celltype, xenium.obj$niches) ``` 1 2 3 4 5 Astro 115 484 241 146 89 Endo 27 250 66 62 45 L2-3 IT 0 1749 14 5 6 L4 2 2163 3 94 14 L5 IT 2 66 2 627 84 L5 PT 2 92 4 711 21 L6 CT 82 2 0 34 857 L6 IT 4 22 1 56 275 L6b 95 0 0 2 2 Lamp5 4 77 61 8 7 Macrophage 7 48 15 16 10 Meis2 0 0 0 0 0 NP 0 1 0 78 9 Oligo 305 130 42 76 70 Peri 6 40 4 10 12 Pvalb 5 155 0 75 54 Serpinf1 0 5 0 1 1 SMC 2 34 2 12 2 Sncg 3 15 1 0 5 Sst 0 53 0 55 26 Vip 3 85 5 14 4 VLMC 2 31 257 7 2 ``` Human Lung: Nanostring CosMx Spatial Molecular Imager anchor This dataset was produced using Nanostring CosMx Spatial Molecular Imager (SMI). The CosMX SMI performs multiplexed single molecule profiling, can profile both RNA and protein targets, and can be applied directly to FFPE tissues. The dataset represents 8 FFPE samples taken from 5 non-small-cell lung cancer (NSCLC) tissues, and is available for public download . The gene panel consists of 960 transcripts. In this vignette, we load one of 8 samples (lung 5, replicate 1). We use the LoadNanostring() function, which parses the outputs available on the public download site. Note that the coordinates for the cell boundaries were provided by Nanostring by request, and are available for download here . For this dataset, instead of performing unsupervised analysis, we map the Nanostring profiles to our Azimuth Healthy Human Lung reference, which was defined by scRNA-seq. We used Azimuth version 0.4.3 with the human lung reference version 1.0.0. You can download the precomputed results here , which include annotations, prediction scores, and a UMAP visualization. The median number of detected transcripts/cell is 249, which does create uncertainty for the annotation process. sourceCode R nano.obj <- LoadNanostring(data.dir = \"/brahms/hartmana/vignette_data/nanostring/lung5_rep1\", fov = \"lung5.rep1\") ```sourceCode R add in precomputed Azimuth annotations azimuth.data <- readRDS(\"/brahms/hartmana/vignette_data/nanostring_data.Rds\") nano.obj <- AddMetaData(nano.obj, metadata = azimuth.data$annotations) nano.obj[[\"proj.umap\"]] <- azimuth.data$umap Idents(nano.obj) <- nano.obj$predicted.annotation.l1 set to avoid error exceeding max allowed size of globals options(future.globals.maxSize = 8000 * 1024^2) nano.obj <- SCTransform(nano.obj, assay = \"Nanostring\", clip.range = c(-10, 10), verbose = FALSE) text display of annotations and prediction scores head(slot(object = nano.obj, name = \"meta.data\")[2:5]) ``` ``` nCount_Nanostring nFeature_Nanostring predicted.annotation.l1 1_1 23 19 Dendritic 2_1 26 23 Macrophage 3_1 74 51 Neuroendocrine 4_1 60 48 Macrophage 5_1 52 39 Macrophage 6_1 5 5 CD4 T predicted.annotation.l1.score 1_1 0.5884506 2_1 0.5707920 3_1 0.5449661 4_1 0.6951970 5_1 0.8155319 6_1 0.5677324 ``` We can visualize the Nanostring cells and annotations, projected onto the reference-defined UMAP. Note that for this NSCLC sample, tumor samples are annotated as ‘basal’, which is the closest cell type match in the healthy reference. sourceCode R DimPlot(nano.obj) Visualization of cell type and expression localization patterns anchor As in the previous example, ImageDimPlot() plots c ells based on their spatial locations, and colors them based on their assigned cell type. Notice that the basal cell population (tumor cells) is tightly spatially organized, as expected. sourceCode R ImageDimPlot(nano.obj, fov = \"lung5.rep1\", axes = TRUE, cols = \"glasbey\") Since there are many cell types present, we can highlight the localization of a few select groups. sourceCode R ImageDimPlot(nano.obj, fov = \"lung5.rep1\", cells = WhichCells(nano.obj, idents = c(\"Basal\", \"Macrophage\", \"Smooth Muscle\", \"CD4 T\")), cols = c(\"red\", \"green\", \"blue\", \"orange\"), size = 0.6) We can also visualize gene expression markers a few different ways: sourceCode R VlnPlot(nano.obj, features = \"KRT17\", assay = \"Nanostring\", layer = \"counts\", pt.size = 0.1, y.max = 30) + NoLegend() sourceCode R FeaturePlot(nano.obj, features = \"KRT17\", max.cutoff = \"q95\") sourceCode R p1 <- ImageFeaturePlot(nano.obj, fov = \"lung5.rep1\", features = \"KRT17\", max.cutoff = \"q95\") p2 <- ImageDimPlot(nano.obj, fov = \"lung5.rep1\", alpha = 0.3, molecules = \"KRT17\", nmols = 10000) + NoLegend() p1 + p2 We can plot molecules in order to co-visualize the expression of multiple markers, including KRT17 (basal cells), C1QA (macrophages), IL7R (T cells), and TAGLN (Smooth muscle cells). ```sourceCode R Plot some of the molecules which seem to display spatial correlation with each other ImageDimPlot(nano.obj, fov = \"lung5.rep1\", group.by = NA, alpha = 0.3, molecules = c(\"KRT17\", \"C1QA\", \"IL7R\", \"TAGLN\"), nmols = 20000) ``` We zoom in on one basal-rich region using the Crop() function. Once zoomed-in, we can visualize individual cell boundaries as well in all visualizations. sourceCode R basal.crop <- Crop(nano.obj[[\"lung5.rep1\"]], x = c(159500, 164000), y = c(8700, 10500)) nano.obj[[\"zoom1\"]] <- basal.crop DefaultBoundary(nano.obj[[\"zoom1\"]]) <- \"segmentation\" sourceCode R ImageDimPlot(nano.obj, fov = \"zoom1\", cols = \"polychrome\", coord.fixed = FALSE) ```sourceCode R note the clouds of TPSAB1 molecules denoting mast cells ImageDimPlot(nano.obj, fov = \"zoom1\", cols = \"polychrome\", alpha = 0.3, molecules = c(\"KRT17\", \"IL7R\", \"TPSAB1\"), mols.size = 0.3, nmols = 20000, border.color = \"black\", coord.fixed = FALSE) ``` Human Lymph Node: Akoya CODEX system anchor This dataset was produced using Akoya CODEX system. The CODEX system performs multiplexed spatially-resolved protein profiling, iteratively visualizing antibody-binding events. The dataset here represents a tissue section from a human lymph node, and was generated by the University of Florida as part of the Human Biomolecular Atlas Program (HuBMAP). More information about the sample and experiment is available here . The protein panel in this dataset consists of 28 markers, and protein intensities were quantified as part of the Akoya processor pipeline, which outputs a CSV file providing the intensity of each marker in each cell, as well as the cell coordinates. The file is available for public download via Globus here . First, we load in the data of a HuBMAP dataset using the LoadAkoya() function in Seurat: sourceCode R codex.obj <- LoadAkoya(filename = \"/brahms/hartmana/vignette_data/LN7910_20_008_11022020_reg001_compensated.csv\", type = \"processor\", fov = \"HBM754.WKLP.262\") We can now run unsupervised analysis to identify cell clusters. To normalize the protein data, we use centered log-ratio based normalization, as we typically apply to the protein modality of CITE-seq data. We then run dimensional reduction and graph-based clustering. sourceCode R codex.obj <- NormalizeData(object = codex.obj, normalization.method = \"CLR\", margin = 2) codex.obj <- ScaleData(codex.obj) VariableFeatures(codex.obj) <- rownames(codex.obj) # since the panel is small, treat all features as variable. codex.obj <- RunPCA(object = codex.obj, npcs = 20, verbose = FALSE) codex.obj <- RunUMAP(object = codex.obj, dims = 1:20, verbose = FALSE) codex.obj <- FindNeighbors(object = codex.obj, dims = 1:20, verbose = FALSE) codex.obj <- FindClusters(object = codex.obj, verbose = FALSE, resolution = 0.4, n.start = 1) We can visualize the cell clusters based on a protein intensity-based UMAP embedding, or also based on their spatial location. sourceCode R DimPlot(codex.obj, label = TRUE, label.box = TRUE) + NoLegend() sourceCode R ImageDimPlot(codex.obj, cols = \"parade\") The expression patters of individual markers clearly denote different cell types and spatial structures, including Lyve1 (lymphatic endothelial cells), CD34 (blood endothelial cells), and CD21 (B cells). As expected, endothelial cells group together into vessels, and B cells are key components of specialized microstructures known as germinal zones. You can read more about protein markers in this dataset, as well as cellular networks in human lynmphatic tissues, in this preprint . sourceCode R p1 <- ImageFeaturePlot(codex.obj, fov = \"HBM754.WKLP.262\", features = c(\"CD34\", \"CD21\", \"Lyve1\"), min.cutoff = \"q10\", max.cutoff = \"q90\") p2 <- ImageDimPlot(codex.obj, fov = \"HBM754.WKLP.262\", cols = \"parade\") p1 + p2 Each of these datasets represents an opportunity to learn organizing principles that govern the spatial localization of different cell types. Stay tuned for future updates to Seurat enabling further exploration and characterization of the relationship between spatial position and molecular state. Session Info sourceCode R sessionInfo() ``` R version 4.2.2 Patched (2022-11-10 r83330) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.6 LTS Matrix products: default BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats graphics grDevices utils datasets methods base other attached packages: [1] spacexr_2.2.1 ggplot2_3.4.4 future_1.33.0 Seurat_5.0.0 [5] SeuratObject_5.0.0 sp_2.1-1 loaded via a namespace (and not attached): [1] utf8_1.2.4 spatstat.explore_3.2-5 [3] reticulate_1.34.0 R.utils_2.12.2 [5] tidyselect_1.2.0 htmlwidgets_1.6.2 [7] grid_4.2.2 Rtsne_0.16 [9] munsell_0.5.0 codetools_0.2-19 [11] ragg_1.2.5 ica_1.0-3 [13] units_0.8-4 miniUI_0.1.1.1 [15] withr_2.5.2 spatstat.random_3.2-1 [17] colorspace_2.1-0 progressr_0.14.0 [19] Biobase_2.58.0 highr_0.10 [21] knitr_1.45 stats4_4.2.2 [23] ROCR_1.0-11 tensor_1.5 [25] listenv_0.9.0 MatrixGenerics_1.10.0 [27] labeling_0.4.3 GenomeInfoDbData_1.2.9 [29] polyclip_1.10-6 bit64_4.0.5 [31] farver_2.1.1 rprojroot_2.0.3 [33] parallelly_1.36.0 vctrs_0.6.4 [35] generics_0.1.3 xfun_0.40 [37] doParallel_1.0.17 R6_2.5.1 [39] GenomeInfoDb_1.34.9 ggbeeswarm_0.7.1 [41] hdf5r_1.3.8 bitops_1.0-7 [43] spatstat.utils_3.0-4 cachem_1.0.8 [45] DelayedArray_0.24.0 promises_1.2.1 [47] scales_1.2.1 beeswarm_0.4.0 [49] gtable_0.3.4 Cairo_1.6-0 [51] globals_0.16.2 goftest_1.2-3 [53] spam_2.10-0 rlang_1.1.1 [55] systemfonts_1.0.4 splines_4.2.2 [57] lazyeval_0.2.2 spatstat.geom_3.2-7 [59] yaml_2.3.7 reshape2_1.4.4 [61] abind_1.4-5 httpuv_1.6.12 [63] tools_4.2.2 ellipsis_0.3.2 [65] jquerylib_0.1.4 RColorBrewer_1.1-3 [67] proxy_0.4-27 BiocGenerics_0.44.0 [69] ggridges_0.5.4 Rcpp_1.0.11 [71] plyr_1.8.9 zlibbioc_1.44.0 [73] classInt_0.4-10 purrr_1.0.2 [75] RCurl_1.98-1.12 deldir_1.0-9 [77] pbapply_1.7-2 cowplot_1.1.1 [79] S4Vectors_0.36.2 zoo_1.8-12 [81] SummarizedExperiment_1.28.0 ggrepel_0.9.4 [83] cluster_2.1.4 fs_1.6.3 [85] magrittr_2.0.3 data.table_1.14.8 [87] RSpectra_0.16-1 glmGamPoi_1.10.2 [89] scattermore_1.2 lmtest_0.9-40 [91] RANN_2.6.1 fitdistrplus_1.1-11 [93] matrixStats_1.0.0 patchwork_1.1.3 [95] mime_0.12 evaluate_0.22 [97] xtable_1.8-4 fastDummies_1.7.3 [99] IRanges_2.32.0 gridExtra_2.3 [101] compiler_4.2.2 tibble_3.2.1 [103] KernSmooth_2.23-22 R.oo_1.25.0 [105] htmltools_0.5.6.1 later_1.3.1 [107] tidyr_1.3.0 DBI_1.1.3 [109] formatR_1.14 MASS_7.3-58.2 [111] sf_1.0-14 Matrix_1.6-1.1 [113] cli_3.6.1 R.methodsS3_1.8.2 [115] parallel_4.2.2 dotCall64_1.1-0 [117] igraph_1.5.1 GenomicRanges_1.50.2 [119] pkgconfig_2.0.3 pkgdown_2.0.7 [121] plotly_4.10.3 spatstat.sparse_3.0-3 [123] foreach_1.5.2 vipor_0.4.5 [125] bslib_0.5.1 XVector_0.38.0 [127] stringr_1.5.0 digest_0.6.33 [129] sctransform_0.4.1 RcppAnnoy_0.0.21 [131] spatstat.data_3.0-3 rmarkdown_2.25 [133] leiden_0.4.3 uwot_0.1.16 [135] shiny_1.7.5.1 lifecycle_1.0.3 [137] nlme_3.1-162 jsonlite_1.8.7 [139] desc_1.4.2 viridisLite_0.4.2 [141] limma_3.54.1 fansi_1.0.5 [143] pillar_1.9.0 lattice_0.21-9 [145] ggrastr_1.0.1 fastmap_1.1.1 [147] httr_1.4.7 survival_3.5-7 [149] glue_1.6.2 iterators_1.0.14 [151] png_0.1-8 bit_4.0.5 [153] class_7.3-21 presto_1.0.0 [155] stringi_1.7.12 sass_0.4.7 [157] textshaping_0.3.6 RcppHNSW_0.5.0 [159] memoise_2.0.1 dplyr_1.1.3 [161] irlba_2.3.5.1 e1071_1.7-13 [163] future.apply_1.11.0 ```",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/seurat5_spatial_vignette_2",
      "title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat • Seurat",
      "ogTitle": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "language": "en",
      "og:title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "scrapeId": "f8348d44-8ac8-476a-b6ae-9df17295ae1c",
      "viewport": "width=device-width, initial-scale=1.0",
      "sourceURL": "https://satijalab.org/seurat/articles/seurat5_spatial_vignette_2",
      "statusCode": 200,
      "ogDescription": "Seurat",
      "og:description": "Seurat"
    }
  },
  {
    "processed_text": "",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/seurat5_spatial_vignette.html",
      "error": "Not Found",
      "scrapeId": "ef53420b-36b3-4ad1-9bf0-e69b70c3fa0c",
      "sourceURL": "https://satijalab.org/seurat/articles/seurat5_spatial_vignette.html",
      "statusCode": 404
    }
  },
  {
    "processed_text": "Installation Instructions for Seurat Source: vignettes/install.Rmd install.Rmd To install Seurat, R version 4.0 or greater is required. We also recommend installing R Studio . Seurat 5: Install from GitHub anchor Copy the code below to install Seurat v5: sourceCode R remotes::install_github(\"satijalab/seurat\", \"seurat5\", quiet = TRUE) The following packages are not required but are used in many Seurat v5 vignettes: SeuratData: automatically load datasets pre-packaged as Seurat objects Azimuth: local annotation of scRNA-seq and scATAC-seq queries across multiple organs and tissues SeuratWrappers: enables use of additional integration and differential expression methods Signac: analysis of single-cell chromatin data sourceCode R remotes::install_github(\"satijalab/seurat-data\", \"seurat5\", quiet = TRUE) remotes::install_github(\"satijalab/azimuth\", \"seurat5\", quiet = TRUE) remotes::install_github(\"satijalab/seurat-wrappers\", \"seurat5\", quiet = TRUE) remotes::install_github(\"stuart-lab/signac\", \"seurat5\", quiet = TRUE) Seurat v5 utilizes BPCells to support analysis of extremely large datasets: sourceCode R remotes::install_github(\"bnprks/BPCells/r\") For more information on BPCells installation, please see the installation instructions . For macOS users, the following GitHub issues concerning M1 chip installation and compiler compatibility may be of use. Install from CRAN anchor Seurat is available on CRAN for all platforms. To install, run: ```sourceCode R Enter commands in R (or R studio, if installed) install.packages('Seurat') library(Seurat) ``` If you see the warning message below, enter y : sourceCode r package which is only available in source form, and may need compilation of C/C++/Fortran: 'Seurat' Do you want to attempt to install these from sources? y/n: Install previous versions of Seurat anchor Install any version 3 release anchor Any of the Seurat version 3 releases can be installed with the following command: sourceCode R remotes::install_version(\"Seurat\", version = \"3.X.X\") Install the last version 2 release (2.3.4) anchor To facilitate easy re-installation of the last version 2 release, we are hosting the binaries on our website. These can be installed with the following command: sourceCode R source(\"https://z.umn.edu/archived-seurat\") View the script | | | | --- | --- | | | #!/usr/bin/env Rscript | | | | | | # Detach any thing for Seurat | | | if ('package:Seurat'%in% search()) { | | | detach(name='package:Seurat') | | | } | | | | | | if ('Seurat'%in% loadedNamespaces()) { | | | unloadNamespace(ns='Seurat') | | | } | | | | | | local(expr= { | | | # Prep for future Seurat version argument | | | # Get latest archived version from CRAN | | | archive.meta<- gzcon(con= url( | | | description='https://cran.r-project.org/src/contrib/Meta/archive.rds', | | | open='rb' | | | )) | | | archive<- readRDS(file=archive.meta)[['Seurat']] | | | close(con=archive.meta) | | | default.version<- rownames(x=archive)[nrow(x=archive)] | | | default.version<- basename(path=tools::file_path_sans_ext( | | | x=default.version, | | | compression=TRUE | | | )) | | | default.version<- unlist(x= strsplit(x=default.version, split='_')) | | | default.version<-default.version[length(x=default.version)] | | | # Get which version we're installing here | | | target.version<- getOption(x='Seurat.installer.version', default=default.version) | | | target.version<- package_version(x= as.character(x=target.version)) | | | if (target.version!= package_version(x=default.version)) { | | | warning( | | | \"The 'Seurat.installer.version' option is not currently used\", | | | immediate.=TRUE, | | | call.=FALSE | | | ) | | | } | | | # Ensure we aren't wasting our time | | | repo<-'https://satijalab.org/ran' | | | remote.version<- package_version(x=utils::available.packages(repos=repo)['Seurat', 'Version']) | | | installed.version<- tryCatch( | | | expr= packageVersion(pkg='Seurat'), | | | error=function(...) { | | | return(NULL) | | | } | | | ) | | | if (!is.null(x=installed.version) &&installed.version==remote.version) { | | | message(\"Seurat v\", as.character(x=remote.version), \" already installed\") | | | } else { | | | if (!is.null(x=installed.version) &&installed.version>=remote.version) { | | | warning( | | | \"Downgrading Seurat from v\", | | | as.character(x=installed.version), | | | \" to v\", | | | as.character(x=remote.version), | | | immediate.=TRUE, | | | call.=FALSE | | | ) | | | } | | | # This works since we only host Seurat 2.3.4 on satijalab.org/ran | | | desc.file<- file(description= paste0(repo, '/src/contrib/PACKAGES')) | | | # Taken from remotes:::read_dcf | | | fields<- colnames(x= read.dcf(file=desc.file)) | | | seurat.desc<- as.list(x= read.dcf( | | | file=desc.file, | | | keep.white=fields | | | )[1, ]) | | | close(con=desc.file) | | | # Taken from remotes:::parse_deps | | | seurat.deps<- lapply( | | | X=seurat.desc[c('Depends', 'Imports', 'LinkingTo')], | | | FUN=function(x) { | | | parts<- unlist(x= strsplit(x=x, split='[[:space:]]*,[[:space:]]*')) | | | names<- gsub( | | | pattern='^\\\\s+\\|\\\\s^$', | | | replacement='', | | | x= gsub( | | | pattern='\\\\s*\\(.*?\\)', | | | replacement='', | | | x=parts | | | ) | | | ) | | | versions<-parts | | | versions[!grepl(pattern='\\(.*\\)', x=versions)] <-NA | | | compare<- sub( | | | pattern='.*\\(\\\\s*(\\\\S+)\\\\s+.*\\\\s*\\)', | | | replacement='\\\\1', | | | x=versions | | | ) | | | versions<- sub( | | | pattern='.*\\(\\\\s*\\\\S+\\\\s+(\\\\S*)\\\\s*\\)', | | | replacement='\\\\1', | | | versions | | | ) | | | deps<-data.frame( | | | names=names, | | | compare=compare, | | | version=versions, | | | stringsAsFactors=FALSE | | | ) | | | return(deps) | | | } | | | ) | | | seurat.deps<- do.call( | | | what='rbind', | | | args= c(seurat.deps, make.row.names=FALSE) | | | ) | | | # Get R version information | | | min.version<-seurat.deps[seurat.deps$names=='R', 'version'] | | | r.version<- package_version(x= paste(R.Version()[c('major', 'minor')], collapse='.')) | | | # Get package type | | | type<- getOption(x='pkgType', default='source') | | | # Simplify package type | | | if (grepl(pattern='mac\\.binary', x=type) &&type!='mac.binary.el-capitan') { | | | type<-'source' | | | } elseif (type=='both') { | | | type<-switch( | | | EXPR=.Platform$OS.type, | | | 'windows'='win.binary', | | | 'mac.binary.el-capitan' | | | ) | | | } elseif (type=='binary') { | | | type<-if (.Platform$OS.type=='windows') { | | | 'win.binary' | | | } elseif (Sys.info()$sysname=='Darwin'&& package_version(x= Sys.info()$release) > package_version(x='15.0.0')) { | | | 'mac.binary.el-capitan' | | | } else { | | | 'source' | | | } | | | } | | | # Figure out the URL for binaries | | | repo.platform<-switch( | | | EXPR=type, | | | 'win.binary'='windows', | | | 'mac.binary.el-capitan'='macosx/el-capitan', | | | NA | | | ) | | | # Ensure that we can actually install this version of Seurat | | | if (r.version< package_version(x=min.version)) { | | | stop(\"Seurat v\", remote.version, \" requires R \", min.version, \" or higher\", call.=FALSE) | | | } elseif (!is.na(x=repo.platform)) { | | | tryCatch( | | | expr= { | | | test<- file(description= paste( | | | repo, | | | 'bin', | | | repo.platform, | | | 'contrib', | | | tools::file_path_sans_ext(x=r.version), | | | 'PACKAGES', | | | sep='/' | | | )) | | | tmp<- suppressWarnings(expr= read.dcf(file=test)) | | | close(con=test) | | | }, | | | error=function(...) { | | | warning( | | | \"Seurat v\", | | | remote.version, | | | \" binaries for \", | | | switch(EXPR=type, 'win.binary'='Windows', 'macOS'), | | | \" have not been built for R \", | | | r.version, | | | \", installing from source instead\", | | | immediate.=TRUE, | | | call.=FALSE | | | ) | | | close(con=test) | | | type<<-'source' | | | } | | | ) | | | } | | | # Remove base packages | | | seurat.deps<-seurat.deps[seurat.deps$names!='R', ] | | | inst.pkgs<-utils::installed.packages() | | | base.pkgs<- unname(obj=inst.pkgs[inst.pkgs[, 'Priority'] %in% c('base', 'recommended', 'Package'), 'Package']) | | | seurat.deps<- subset( | | | x=seurat.deps, | | | subset=names%in% setdiff(x=seurat.deps$names, y=base.pkgs) | | | ) | | | # Find which dependencies we need to install | | | deps.to.install<- apply( | | | X=seurat.deps, | | | MARGIN=1, | | | FUN=function(x) { | | | x<- unname(obj=x) | | | dep<-x[1] | | | comp<-x[2] | | | req<-x[3] | | | inst<- tryCatch( | | | expr= as.character(x=utils::packageVersion(pkg=dep)), | | | error=function(...) { | | | return(NULL) | | | } | | | ) | | | if (!is.null(x=inst)) { | | | dep<-if (is.na(x=comp)) { | | | NA | | | } else { | | | ifelse( | | | test= do.call( | | | what=comp, | | | args=list(package_version(x=inst), package_version(x=req)) | | | ), | | | yes=NA, | | | no=dep | | | ) | | | } | | | } | | | return(dep) | | | } | | | ) | | | deps.to.install<- unname(obj= as.character(x= na.omit(object=deps.to.install))) | | | if (length(x=deps.to.install) >0) { | | | install.packages(pkgs=deps.to.install) | | | } | | | install.packages('Seurat', repos='https://satijalab.org/ran', type=type) | | | } | | | }) | | | | | | tryCatch( | | | expr= attachNamespace(ns='Seurat'), | | | error=function(...) { | | | return(invisible(x=NULL)) | | | } | | | ) | view raw archived_seurat.R hosted with ❤ by GitHub Older versions of Seurat anchor Old versions of Seurat, from Seurat v2.0.1 and up, are hosted in CRAN’s archive. To install an old version of Seurat, run: ```sourceCode R Enter commands in R (or R studio, if installed) Install the remotes package install.packages('remotes') Replace '2.3.0' with your desired version remotes::install_version(package = 'Seurat', version = package_version('2.3.0')) library(Seurat) ``` For versions of Seurat older than those not hosted on CRAN (versions 1.3.0 and 1.4.0), please download the packaged source code from our releases page and install from the tarball . Install the development version of Seurat anchor Install the development version of Seurat - directly from GitHub . ```sourceCode R Enter commands in R (or R studio, if installed) Install the remotes package install.packages('remotes') remotes::install_github(repo = 'satijalab/seurat', ref = 'develop') library(Seurat) ``` Docker anchor We provide docker images for Seurat via dockerhub . To pull the latest image from the command line: sourceCode bash docker pull satijalab/seurat:latest To use as a base image in a new Dockerfile: sourceCode bash FROM satijalab/seurat:latest",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/install",
      "title": "Installation Instructions for Seurat • Seurat",
      "ogTitle": "Installation Instructions for Seurat",
      "language": "en",
      "og:title": "Installation Instructions for Seurat",
      "scrapeId": "f88f2017-4eb6-4b35-a29a-6d8a8f9ca9f7",
      "viewport": "width=device-width, initial-scale=1.0",
      "sourceURL": "https://satijalab.org/seurat/articles/install",
      "statusCode": 200,
      "ogDescription": "Seurat",
      "og:description": "Seurat"
    }
  },
  {
    "processed_text": "Sketch integration using a 1 million cell dataset from Parse Biosciences Compiled: 2023-11-15 Source: vignettes/ParseBio_sketch_integration.Rmd ParseBio_sketch_integration.Rmd The recent increase in publicly available single-cell datasets poses a significant challenge for integrative analysis. For example, multiple tissues have now been profiled across dozens of studies, representing hundreds of individuals and millions of cells. In Hao et al, 2023 proposed a dictionary learning based method, atomic sketch integration, could also enable efficient and large-scale integrative analysis. Our procedure enables the integration of large compendiums of datasets without ever needing to load the full scale of data into memory. In our manuscript we use atomic sketch integration to integrate millions of scRNA-seq from human lung and human PBMC. In this vignette, we demonstrate how to use atomic sketch integration to harmonize scRNA-seq experiments 1M cells, though we have used this procedure to integrate datasets of 10M+ cells as well. We analyze a dataset from Parse Biosciences, in which PBMC from 24 human samples (12 healthy donors, 12 Type-1 diabetes donors), which is available here . Sample a representative subset of cells (‘atoms’) from each dataset Integrate the atoms from each dataset, and define a set of cell states Reconstruct (integrate) the full datasets, based on the atoms Annotate all cells in the full datasets Identify cell-type specific differences between healthy and diabetic patients Prior to running this vignette, please install Seurat v5 , as well as the BPCells package, which we use for on-disk storage. You can read more about using BPCells in Seurat v5 here . We also recommend reading the Sketch-based analysis in Seurat v5 vignette, which introduces the concept of on-disk and in-memory storage in Seurat v5. ```sourceCode R library(Seurat) library(BPCells) library(dplyr) library(ggplot2) library(ggrepel) library(patchwork) set this option when analyzing large datasets options(future.globals.maxSize = 3e+09) ``` Create a Seurat object containing data from 24 patients anchor We downloaded the original dataset and donor metadata from Parse Biosciences . While the BPCells package can work directly with h5ad files, for optimal performance, we converted the dataset to the compressed sparse format used by BPCells, as described here . We create a Seurat object for this dataset. Since the input to CreateSeuratObject is a BPCells matrix, the data remains on-disk and is not loaded into memory. After creating the object, we split the dataset into 24 layers , one for each sample (i.e. patient), to facilitate integration. ```sourceCode R parse.mat <- open_matrix_dir(dir = \"/brahms/hartmana/vignette_data/bpcells/parse_1m_pbmc\") need to move metadata <- readRDS(\"/brahms/haoy/vignette_data/ParseBio_PBMC_meta.rds\") object <- CreateSeuratObject(counts = parse.mat, meta.data = metadata) object <- NormalizeData(object) split assay into 24 layers object[[\"RNA\"]] <- split(object[[\"RNA\"]], f = object$sample) object <- FindVariableFeatures(object, verbose = FALSE) ``` Sample representative cells from each dataset anchor Inspired by pioneering work aiming to identify ‘sketches’ of scRNA-seq data, our first step is to sample a representative set of cells from each dataset. We compute a leverage score (estimate of ‘statistical leverage’ ) for each cell, which helps to identify cells that are likely to be member of rare subpopulations and ensure that these are included in our representative sample. Importantly, the estimation of leverage scores only requires data normalization, can be computed efficiently for sparse datasets, and does not require any intensive computation or dimensional reduction steps. We load each object separately, perform basic preprocessing (normalization and variable feature selection), and select and store 5,000 representative cells from each dataset. Since there are 24 datasets, the sketched dataset now contains 120,000 cells. These cells are stored in a new sketch assay, and are loaded in-memory. sourceCode R object <- SketchData(object = object, ncells = 5000, method = \"LeverageScore\", sketched.assay = \"sketch\") object ``` An object of class Seurat 121328 features across 966344 samples within 2 assays Active assay: sketch (60664 features, 2000 variable features) 48 layers present: counts.H_3128, counts.H_3060, counts.H_409, counts.H_7108, counts.H_120, counts.D_504, counts.H_2928, counts.H_727, counts.H_4579, counts.H_6625, counts.H_630, counts.D_500, counts.D_501, counts.D_610, counts.H_4119, counts.D_609, counts.D_644, counts.D_498, counts.H_1334, counts.D_497, counts.D_505, counts.D_506, counts.D_502, counts.D_503, data.H_3128, data.H_3060, data.H_409, data.H_7108, data.H_120, data.D_504, data.H_2928, data.H_727, data.H_4579, data.H_6625, data.H_630, data.D_500, data.D_501, data.D_610, data.H_4119, data.D_609, data.D_644, data.D_498, data.H_1334, data.D_497, data.D_505, data.D_506, data.D_502, data.D_503 1 other assay present: RNA ``` Perform integration on the sketched cells across samples anchor Next we perform integrative analysis on the ‘atoms’ from each of the datasets. Here, we perform integration using the streamlined Seurat v5 integration worfklow , and utilize the reference-based RPCAIntegration method. The function performs all corrections in low-dimensional space (rather than on the expression values themselves) to further improve speed and memory usage, and outputs a merged Seurat object where all cells have been placed in an integrated low-dimensional space (stored as integrated.rpca ). However, we emphasize that you can perform integration here using any analysis technique that places cells across datasets into a shared space. This includes CCA Integration, Harmony, and scVI. We demonstrate how to use these tools in Seurat v5 here . ```sourceCode R DefaultAssay(object) <- \"sketch\" object <- FindVariableFeatures(object, verbose = F) object <- ScaleData(object, verbose = F) object <- RunPCA(object, verbose = F) integrate the datasets object <- IntegrateLayers(object, method = RPCAIntegration, orig = \"pca\", new.reduction = \"integrated.rpca\", dims = 1:30, k.anchor = 20, reference = which(Layers(object, search = \"data\") %in% c(\"data.H_3060\")), verbose = F) cluster the integrated data object <- FindNeighbors(object, reduction = \"integrated.rpca\", dims = 1:30) object <- FindClusters(object, resolution = 2) ``` ``` Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck Number of nodes: 120000 Number of edges: 5137782 Running Louvain algorithm... Maximum modularity in 10 random starts: 0.8765 Number of communities: 47 Elapsed time: 83 seconds ``` sourceCode R object <- RunUMAP(object, reduction = \"integrated.rpca\", dims = 1:30, return.model = T, verbose = F) ```sourceCode R you can now rejoin the layers in the sketched assay this is required to perform differential expression object[[\"sketch\"]] <- JoinLayers(object[[\"sketch\"]]) c10_markers <- FindMarkers(object = object, ident.1 = 10, max.cells.per.ident = 500, only.pos = TRUE) head(c10_markers) ``` ``` p_val avg_log2FC pct.1 pct.2 p_val_adj BANK1 8.652285e-142 3.183046 0.980 0.183 5.248822e-137 RALGPS2 1.870876e-134 3.168787 0.949 0.215 1.134948e-129 OSBPL10 4.406924e-133 3.556864 0.890 0.118 2.673417e-128 ARHGAP24 1.666152e-121 2.957065 0.916 0.263 1.010754e-116 AFF3 6.864595e-107 2.248398 0.978 0.306 4.164338e-102 EBF1 7.805461e-107 2.994191 0.841 0.126 4.735105e-102 ``` ```sourceCode R You can now annotate clusters using marker genes. We performed this step, and include the results in the 'sketch.celltype' metadata column plot.s1 <- DimPlot(object, group.by = \"sample\", reduction = \"umap\") plot.s2 <- DimPlot(object, group.by = \"celltype.manual\", reduction = \"umap\") ``` sourceCode R plot.s1 + plot.s2 + plot_layout(ncol = 1) Integrate the full datasets anchor Now that we have integrated the subset of atoms of each dataset, placing them each in an integrated low-dimensional space, we can now place each cell from each dataset in this space as well. We load the full datasets back in individually, and use the ProjectIntegration function to integrate all cells. After this function is run, the integrated.rpca.full space now embeds all cells in the dataset.Even though all cells in the dataset have been integrated together, the non-sketched cells are not loaded into memory. Users can still switch between the sketch (sketched cells, in-memory) and RNA (full dataset, on disk) for analysis. After integration, we can also project cell type labels from the sketched cells onto the full dataset using ProjectData . ```sourceCode R resplit the sketched cell assay into layers this is required to project the integration onto all cells object[[\"sketch\"]] <- split(object[[\"sketch\"]], f = object$sample) object <- ProjectIntegration(object = object, sketched.assay = \"sketch\", assay = \"RNA\", reduction = \"integrated.rpca\") object <- ProjectData(object = object, sketched.assay = \"sketch\", assay = \"RNA\", sketched.reduction = \"integrated.rpca.full\", full.reduction = \"integrated.rpca.full\", dims = 1:30, refdata = list(celltype.full = \"celltype.manual\")) ``` sourceCode R object <- RunUMAP(object, reduction = \"integrated.rpca.full\", dims = 1:30, reduction.name = \"umap.full\", reduction.key = \"UMAP_full_\") sourceCode R p1 <- DimPlot(object, reduction = \"umap.full\", group.by = \"sample\", alpha = 0.1) p2 <- DimPlot(object, reduction = \"umap.full\", group.by = \"celltype.full\", alpha = 0.1) p1 + p2 + plot_layout(ncol = 1) Compare healthy and diabetic samples anchor By integrating all samples together, we can now compare healthy and diabetic cells in matched cell states. To maximize statistical power, we want to use all cells - not just the sketched cells - to perform this analysis. As recommended by Soneson et all. and Crowell et al. , we use an aggregation-based (pseudobulk) workflow. We aggregate all cells within the same cell type and sample using the AggregateExpression function. This returns a Seurat object where each ‘cell’ represents the pseudobulk profile of one cell type in one individual. After we aggregate cells, we can perform celltype-specific differential expression between healthy and diabetic samples using DESeq2. We demonstrate this for CD14 monocytes. sourceCode R bulk <- AggregateExpression(object, return.seurat = T, slot = \"counts\", assays = \"RNA\", group.by = c(\"celltype.full\", \"sample\", \"disease\")) ```sourceCode R each sample is an individual-specific celltype-specific pseudobulk profile tail(Cells(bulk)) ``` ``` [1] \"Treg_H-4119_H\" \"Treg_H-4579_H\" \"Treg_H-630_H\" \"Treg_H-6625_H\" [5] \"Treg_H-7108_H\" \"Treg_H-727_H\" ``` sourceCode R cd14.bulk <- subset(bulk, celltype.full == \"CD14 Mono\") Idents(cd14.bulk) <- \"disease\" de_markers <- FindMarkers(cd14.bulk, ident.1 = \"D\", ident.2 = \"H\", slot = \"counts\", test.use = \"DESeq2\", verbose = F) de_markers$gene <- rownames(de_markers) ggplot(de_markers, aes(avg_log2FC, -log10(p_val))) + geom_point(size = 0.5, alpha = 0.5) + theme_bw() + ylab(\"-log10(unadjusted p-value)\") + geom_text_repel(aes(label = ifelse(p_val_adj < 0.01, gene, \"\")), colour = \"red\", size = 3) Session Info sourceCode R sessionInfo() ``` R version 4.2.2 Patched (2022-11-10 r83330) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.6 LTS Matrix products: default BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats graphics grDevices utils datasets methods base other attached packages: [1] patchwork_1.1.3 ggrepel_0.9.4 ggplot2_3.4.4 dplyr_1.1.3 [5] BPCells_0.1.0 Seurat_5.0.1 SeuratObject_5.0.1 sp_2.1-1 loaded via a namespace (and not attached): [1] spam_2.10-0 systemfonts_1.0.4 plyr_1.8.9 [4] igraph_1.5.1 lazyeval_0.2.2 splines_4.2.2 [7] RcppHNSW_0.5.0 listenv_0.9.0 scattermore_1.2 [10] GenomeInfoDb_1.34.9 digest_0.6.33 htmltools_0.5.6.1 [13] fansi_1.0.5 magrittr_2.0.3 memoise_2.0.1 [16] tensor_1.5 cluster_2.1.4 ROCR_1.0-11 [19] limma_3.54.1 globals_0.16.2 matrixStats_1.0.0 [22] pkgdown_2.0.7 spatstat.sparse_3.0-3 colorspace_2.1-0 [25] textshaping_0.3.6 xfun_0.40 RCurl_1.98-1.12 [28] jsonlite_1.8.7 progressr_0.14.0 spatstat.data_3.0-3 [31] survival_3.5-7 zoo_1.8-12 glue_1.6.2 [34] polyclip_1.10-6 gtable_0.3.4 zlibbioc_1.44.0 [37] XVector_0.38.0 leiden_0.4.3 future.apply_1.11.0 [40] BiocGenerics_0.44.0 abind_1.4-5 scales_1.2.1 [43] spatstat.random_3.2-1 miniUI_0.1.1.1 Rcpp_1.0.11 [46] viridisLite_0.4.2 xtable_1.8-4 reticulate_1.34.0 [49] dotCall64_1.1-0 stats4_4.2.2 htmlwidgets_1.6.2 [52] httr_1.4.7 RColorBrewer_1.1-3 ellipsis_0.3.2 [55] ica_1.0-3 farver_2.1.1 pkgconfig_2.0.3 [58] sass_0.4.7 uwot_0.1.16 deldir_1.0-9 [61] utf8_1.2.4 labeling_0.4.3 tidyselect_1.2.0 [64] rlang_1.1.1 reshape2_1.4.4 later_1.3.1 [67] munsell_0.5.0 tools_4.2.2 cachem_1.0.8 [70] cli_3.6.1 generics_0.1.3 ggridges_0.5.4 [73] evaluate_0.22 stringr_1.5.0 fastmap_1.1.1 [76] yaml_2.3.7 ragg_1.2.5 goftest_1.2-3 [79] knitr_1.45 fs_1.6.3 fitdistrplus_1.1-11 [82] purrr_1.0.2 RANN_2.6.1 pbapply_1.7-2 [85] future_1.33.0 nlme_3.1-162 mime_0.12 [88] formatR_1.14 compiler_4.2.2 plotly_4.10.3 [91] png_0.1-8 spatstat.utils_3.0-4 tibble_3.2.1 [94] bslib_0.5.1 stringi_1.7.12 highr_0.10 [97] desc_1.4.2 RSpectra_0.16-1 lattice_0.21-9 [100] Matrix_1.6-1.1 vctrs_0.6.4 pillar_1.9.0 [103] lifecycle_1.0.4 spatstat.geom_3.2-7 lmtest_0.9-40 [106] jquerylib_0.1.4 RcppAnnoy_0.0.21 data.table_1.14.8 [109] cowplot_1.1.1 bitops_1.0-7 irlba_2.3.5.1 [112] httpuv_1.6.12 GenomicRanges_1.50.2 R6_2.5.1 [115] promises_1.2.1 KernSmooth_2.23-22 gridExtra_2.3 [118] IRanges_2.32.0 parallelly_1.36.0 codetools_0.2-19 [121] fastDummies_1.7.3 MASS_7.3-58.2 rprojroot_2.0.4 [124] withr_2.5.2 presto_1.0.0 sctransform_0.4.1 [127] S4Vectors_0.36.2 GenomeInfoDbData_1.2.9 parallel_4.2.2 [130] grid_4.2.2 tidyr_1.3.0 rmarkdown_2.25 [133] Rtsne_0.16 spatstat.explore_3.2-5 shiny_1.7.5.1 ```",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/parsebio_sketch_integration",
      "title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat • Seurat",
      "ogTitle": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "language": "en",
      "og:title": "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat",
      "scrapeId": "fc9d96ad-acd3-4a3d-8fe0-c079e9a7ecec",
      "viewport": "width=device-width, initial-scale=1.0",
      "sourceURL": "https://satijalab.org/seurat/articles/parsebio_sketch_integration",
      "statusCode": 200,
      "ogDescription": "Seurat",
      "og:description": "Seurat"
    }
  },
  {
    "processed_text": "",
    "metadata": {
      "url": "https://satijalab.org/seurat/articles/merge_vignette.html",
      "error": "Not Found",
      "scrapeId": "fcd238bb-7f79-498f-8b6d-27f5e972c784",
      "sourceURL": "https://satijalab.org/seurat/articles/merge_vignette.html",
      "statusCode": 404
    }
  }
]